<?xml version="1.0" encoding="UTF-8"?>
<add>
  <doc>
    <field name="type">page</field>
    <field name="name">doc_read_guide</field>
    <field name="url">d0/dac/doc_read_guide.html</field>
    <field name="keywords"></field>
    <field name="text">Document Reading Guide Document Reading Guide When using the Ambarella Cooper Linux software development kit SDK for the first time Ambarella recommends starting with the following documents Getting Started Guide SDK Code Building Ambarella Cooper Linux SDK Release Notes The two webpage documents provide information that familiarizes the user with the basic environment and functions of the CV5x CV7x evaluation kit EVK and SDK The release note PDF document offers the detailed feature updates information for the SDK release The key updates sent with the release mail is an abstract of the release note document Most CV5x and CV7x documents share the same Doxygen content because most of their software architectures and hardware components are identical or similar however their performance aspects are different In this section the Ambarella Cooper Linux SDK documents are divided into four main categories Platform Camera CVflow® Security Some platform documents are released together with the SDK source code They can be accessed from the webpage BASE AMBoot and BASE Kernel There are multiple chapters in the document Peripherals which provide more descriptions for the different peripheral devices and their operations The following are PDF-format documents Ambarella DG Flexible Linux SDK JTAG Setup Ambarella AN SDK Approved Vendor List In the Ambarella Cooper Linux SDK cameras can be made to function using either input output controls IOCTLs or using Oryx middleware IAV Driver API introduces the image audio video IAV driver application programming interface API information and offers some examples demonstrating the basic API calling sequence Feature Sets provides more details and examples from the feature wise perspective Users can explore these webpages to obtain more information on the different drivers libraries and features Oryx documents can be generated using the commands below CVflow documents are in webpage and PDF formats Users can refer to Overview How To Start for more information in the Doxygen webpage documents Users can follow the commands below to generate the Doxygen webpage documents with the CVflow CNNGen sample package A series of CNNGen training videos are available for users in addition to the documents Contact the Ambarella support team to obtain these training videos The videos are based on the Ambarella CNNGen Introduction Customer PDF document Ambarella_CNNGen_Training_Video_Introduction_1.mp4 Ambarella_CNNGen_Training_Video_Porting_Workflow_2.mp4 Ambarella_CNNGen_Training_Video_Porting_Workflow_3.mp4 Ambarella_CNNGen_Training_Video_deployment_4.mp4 Ambarella_CNNGen_Training_Video_GSG_5.mp4 Ambarella_CNNGen_Training_Video_GSG_6.mp4 Ambarella provides two major security documents currently maintained in Doxygen format Security Overview OTP Operations The security document Ambarella DG Flexible Linux SDK Secure Boot by Built-In Hardware Engine is in PDF format</field>
  </doc>
  <doc>
    <field name="type">source</field>
    <field name="name">overview_chapters_page.h</field>
    <field name="url">d4/dc1/overview__chapters__page_8h_source.html#l00001</field>
    <field name="keywords"></field>
    <field name="text"></field>
  </doc>
  <doc>
    <field name="type">source</field>
    <field name="name">overview_main_page.h</field>
    <field name="url">d5/d71/overview__main__page_8h_source.html#l00001</field>
    <field name="keywords"></field>
    <field name="text"></field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">page_getting_start_guide</field>
    <field name="url">d7/d6c/page_getting_start_guide.html</field>
    <field name="keywords"></field>
    <field name="text">Getting Started Guide Getting Started Guide SDK Version Updated Date Modification CV5x_SDK_0.1 2 0 2 1 1 0 2 1 Initial Version CV5x_SDK_0.5 2 0 2 2 0 1 1 4 Updated Section 7.1 Enter USB Download Mode Updated Section 7.2 Fastboot Tool for Ubuntu Updated Section 7.3 Fastboot Tool for Windows Added Section 7.4 AmbaUSB for Ubuntu Added Section 7.5 AmbaUSB for Windows Updated Chapter CV5x_SDK_1.0 2 0 2 2 0 4 1 5 Updated Chapter 2 Setting up the CV5 EVK Hardware Added Chapter 3 Setting up the CV52N EVK Hardware Added Chapter 4 Setting up the CV52 EVK Hardware Updated Section 6.1 Building the Binary for the Board Updated Chapter 8 SDK Documents on the Website CV5x_SDK_1.5 2 0 2 2 0 7 2 0 Removed Section CV5 EVK Rev 1.x 0 System I/O and Hardware Control Updated Chapter 2 Setting up the CV5 EVK Hardware Updated Chapter 4 Setting up the CV52 EVK Hardware Updated Section 7.3 Fastboot Tool for Windows Updated Chapter 8 SDK Documents on the Website CV5x_SDK_2.0 2 0 2 2 0 8 2 9 Migrate this Getting Started Guide document from Word form into Doxygen form Updated Section 6.7 Run CNN 2 0 2 2 0 9 1 6 Added Chapter 9 CPU Performance Benchmarks 2 0 2 2 1 0 2 5 Upgrade Cortex Toolchain to 12.1 Cooper_SDK_0.5 2 0 2 3 0 4 2 0 Added Chapter 10 SD Card Added Chapter 5 Setting Up the CV72 EVK Hardware Initial Version of Cooper SDK Cooper_SDK_1.0 2 0 2 3 0 7 2 6 Added new building method to support both Amba-Build-v2 and Yocto-Build Since SDK 1.0 it supports CV2x CV5x and CV72 chips Cooper_SDK_1.6 2 0 2 3 1 2 2 8 Updated Section 8.2 Generated CNNGen Document Website 2 0 2 4 0 1 0 5 Updated Section 6.1.2 Evaluation Package This document guides users through the environment setup process for evaluating the Ambarella Cooper Linux Evaluation Kit EVK and the system on chip SoC Users with little or no previous experience using Ambarella devices are encouraged to proceed sequentially through this guide and become familiar with the complete range of hardware and software features For users with prior experience setting up Ambarella devices this document provides a quick introduction to EVK board setup before starting hands-on work with the Cooper chip family A PC connected to the internet is used to download the software development kit SDK and or upgrade the firmware For more details on upgrading the firmware refer to Upgrading the Firmware The PC must be equipped with the following Table 1 1 PC Requirements Category Requirement CPU Intel® i7 or higher grade Memory 8 GB system memory or more Hard disk 1 2 0 GB or more Video card 3 D hardware accelerator card required 1 0 0 DirectX 9.0c compatible NVIDIA® GeForce GT520 or above to assure full frame rate of HD Monitor 2 4 inch LCD or larger with a digital visual interface DVI input A Dell UltraSharp 2 7 0 9 W VA panel is preferred LCD TV 2 9 inch LCD TV or larger with YPbPr input 1 0 8 0 p resolution Ethernet card 1 0 0 0 Mbps adaptive I/O interfaces RS232 Operating system Windows 7 8 6 4 bit or Ubuntu 20.04 LTS 6 4 bit Virtual machine Oracle® VirtualBox 5.0.32 or later For more information about setting up the CV5 EVK hardware refer to Board CV5 Titanium For more information about setting up the CV52 EVK hardware refer to Board CV52 Co Cr For more information about setting up the CV72 EVK hardware refer to Board CV72 Ga Ge Before proceeding to the steps in this chapter review the software and PC requirements listed in 1.1 PC Requirements and set up the EVK hardware following the steps in Chapter 2 Setting up the CV5 EVK Hardware Chapter 3 Setting up the CV52 EVK Hardware Chapter 4 Setting up the CV72 EVK Hardware This chapter describes how to perform the following Section 5.1 Installing the EVK Software Section 5.2 Setting Up the Network Section 5.3 Connecting to a Console Window The following tools folders will be installed on the host PC AmbaUSB for Windows Linux and Mac for upgrading firmware via USB Contact Ambarella for tool release UART Serial Console Tool Users can download and install any universal asynchronous receiver transmitter UART serial terminal tool for console access such as PuTTY mini-com MobaXterm and more Google USB driver for the fastboot device CH340 driver for USB to serial drivers including Windows Linux and Mac versions When a CV5x CV7x board connects to an Ubuntu PC USB-to-serial chip may use the default Linux driver and this driver cannot receive any input To let serial accept input CH343 driver needs to download compile and load manually Download the driver from Run make command to compile source code and generate ch343.ko Remove the default driver usually contains with or by executing command sudo rmmod $module_name Using command sudo insmod ch343.ko to load the new driver If there are no issues in commands above users will find a new UART device This section details the procedure for using a static IP Use the following steps to enable access for the host PC to the EVK board via Ethernet Change the IP address of the PC network adaptor connected to the EVK board to 10.0.0.1 Note that the default IP address of the EVK board is 10.0.0.2 The following figure provides an example of the IP configuration on a Windows PC Figure 5-1 IP Address of Windows Host PC The destination is the IP address of the EVK board 10.0.0.2 The console window enables users to view the system boot sequence messages and run the demonstration applications from the Linux shell Connect a serial cable between the serial port on the EVK and the serial port for example COM1 on the host PC Open a terminal emulator such as Minicom on Linux or PuTTY HyperTerminal on Windows on the host PC Ambarella recommends using PuTTY on Windows PuTTY can be found in the EVK tools Configure the terminal emulator to connect to the serial port using the following data Speed 1 1 5 2 0 0 baud Data Bits 8 Parity None Stop Bits 1 Flow Control None The following provides the steps for connecting to a console window using PuTTY as an example From the PuTTY Configuration dialogue choose Category Connection Serial For Serial Line to Connect To enter the correct port for example COM1 Use the settings below for speed data bits parity stop bits and flow control Figure 5-2 PuTTY Serial Configuration 1 Using the PuTTY Configuration dialogue choose Category Session for the Connection type Then enter in the following parameters Connection type Serial Serial line COM 1 Speed 1 1 5 2 0 Figure 5-3 PuTTY Serial Configuration 2 Save the current session for example Amba Serial so it can be reused Click Open and the following console will appear Figure 5-4 Connecting to a Serial Console Power on the EVK board and wait for the console to read the boot sequence messages After Linux boots up log in as root Figure 5-5 Boot Sequence Messages on the Serial Console Connect the EVK and the host PC using an Ethernet cable Open a terminal emulator such as Minicom on Linux or PuTTY HyperTerminal on Windows on the host PC Ambarella recommends using PuTTY on Windows which can be found in the EVK tools Configure the terminal emulator to the Telnet connection type using Host Name or IP address 10.0.0.2 default Port 2 3 The following provides steps for connecting to a console window using PuTTY as an example From the PuTTY Configuration window choose Session In the right panel select Telnet as the connection type For Host Name or IP address enter 10.0.0.2 For Port enter 2 3 Save the session and click Open Log in as root Figure 5-6 PuTTY Telnet Configuration This chapter describes how to perform the following Section 6.1 Building the Binary for the Board Section 6.2 Initializing the Board Section 6.3 Lua Introduction Section 6.4 Previewing HDMI CVBS Section 6.5 Recording a Stream Section 6.6 Viewing Streams through VLC Section 6.7 Run CNN Users new to the Linux SDK demo applications are encouraged to carefully follow the instructions in this chapter Advanced options with unit tests are explained in the Doxygen document within the SDK package The applications referenced in this EVK getting started guide demonstrate the use of IAV input output control IOCTL The benefits of the unit test include the following Minimizes the number of steps required to configure an individual feature such as the configuration of the stream and starting the encoding process Stream a video that does not require application-level streaming protocol such as real-time streaming protocol RTSP as it is possible to save the video on the host PC Advanced options such as on-screen display OSD privacy mask and region of interest ROI Hands-on experience with the unit test applications and source codes Decompress the SDK package file on the appropriate Linux building server Verify that Arm® Linux Toolchain is installed before compiling the SDK For Cooper Amba build For Cooper Yocto build Enter the board directory BOARD_NAME can be be cv5_timn cv52_crco or cv72_gage There are several default configuration files in the directory ambarella/boards/ $BOARD_NAME For Cooper Amba build For Cooper Yocto build Compile the binary for the specified CV5x CV7x chips Different chips will vary in their clock frequencies and performance To evaluate CV5_Timn use ipcam_config To evaluate CV52_Cr use ipcam_lp5_config and to evaluate CV52_Co use ipcam_lp4_config To evaluate CV72_Ga use ipcam_lp5_config and to evaluate CV72_Ge use ipcam_lp4_config Begin compiling the binary for the specified CV5x CV7x chips For more details refer to the page SDK Code Building The purpose of evaluation SDK package is to help initial customers to evaluate the standard SDK features with prebuild firmware FW on EVK As long as customers kick off the formal project with Cooper SDK they will receive the formal SDK package release This evaluation package provides the necessary header files and prebuild libraries for the user s application Because the package cannot generate a full binary that can run on the EVK board users must flash the binary in the package to the board upload the application to the board and then run it What users can do with evaluation package Run the existing unit test utility and applications with instructions on EVK board for the standard SDK features Convert the open source model or their own neural network NN model with CV toolchain and run one EVK board Build their own application or unit test from the evaluation package What users cannot do with evaluation package Verify advanced features such as secure boot eMMC boot or others Upgrade the software modules with new versions of bug fixes Build the entire FW with the updated driver Linux kernel and bootloader Here are the steps for users to build applications Decompress the SDK package file on the Linux-based building server Ensure that the folder name is not or Using the same build name as CV5x CV7x creates a conflict with the build script Verify that the Arm® Linux toolchain is installed before compiling the SDK For Cooper Amba build Change the configuration options and rebuild the application following the same steps as in CV5_Timn For Cooper Amba build User is required to configure the max video input VIN channel number as it is configured in the prebuild binary for a four-sensor VIN For more details refer to the page SDK Code Building Open a console window connected to the evaluation board and log in as root no password is required Refer to Section 5.3 Connecting to a Console Window for how to connect to a console window Initialize the board Load the script init.sh into the essential drivers and microcode The command for imx274_mipi is as follows The following messages will print if the initialization is successful Confirm that the sensor name is in the message This section provides examples of how CV5x or CV7x uses a Lua script to configure the system Locate cv5_vin0_1080p_linear.lua for the 7 2 0 p example in ambarella/unit_test/private/iav_test/dsp_v6/scripts/cv5 Configure the VIN The following example uses VIN0 as a linear 1 0 8 0 p30 Configure the channel buffer The example below uses VIN0 for the input source of channel0 which includes three buffers The main buffer is 1 0 8 0 p the second buffer is 4 8 0 p and the third buffer is 7 2 0 p The pyramid buffer is used for the vector processor VP input Configure the stream The following example uses three streams two streams as 1 0 8 0 p and one stream as 4 8 0 p This is a basic stream setting that does not specify the canvas buffer or encode solution Configure the canvas buffer The following example shows three configured buffers two buffers that are used for encoding and one buffer used for preview This setting binds the canvas buffer to two different places the channel buffer and the stream or preview buffer The setting shown above is for the 7 2 0 p preview To use the 1 0 8 0 p preview modify the script as shown in the example below The script can be adapted to fit additional resolutions in the same manner For more information about this script refer to Section 6.5 Recording a Stream In order to obtain a video preview the board must be initialized as described in Section 6.1 Building the Binary for the Board Additionally users must prepare the Lua script Refer to Section 6.3 Lua Introduction For the preview ensure that the high-definition multimedia interface HDMI® cable is connected to the board The serial console sends the message The demo below is only applicable for running image digital signal processing IDSP HDMI preview 7 2 0 p HDMI preview 1 0 8 0 p HDMI preview 4 K If the user possesses a different version of the Lua script from those shown above the script must be modified to accommodate a different solution The following steps demonstrate how to record a stream in H.264 H.265 file formats Initialize the board See Section 6.1 Building the Binary for the Board for detailed steps on how to initialize other sensors Enter preview to start the image process See section 6.3 Lua Introduction for more details on how to get previews of other resolutions Start the streaming application and specify the record directory on the Cooper platform Start the encoding stream(s) in H.264 format The default value for the canvas buffer is 0 therefore it is important to pick a specific canvas buffer Additionally if two streams use the same buffer add extra_dram_buf Switch to the test_stream console The message shown below indicates that the stream(s) is starting to encode and record the stream Successfully begin the encoding for stream 0 x1 Stop encoding Or Once the stream has been terminated users can check the record file and send the file to the PC through file transfer protocol FTP The video file can be played via VideoLAN Client VLC Ensure that the VLC configuration is as per 6.6 Viewing Streams through VLC To restart encoding for a new stream repeat steps 4 through 7 When the RTSP server is running view livestreams using the VLC media player as an RTSP client The following steps describe viewing streams through VLC Initialize run the RTSP server and start encoding Launch VLC Confirm that the VLC is configured as described in Section 5.2 Setting Up the Network Select Media Open Network Stream Figure 6-1 Open Network Stream in VLC Input the RTSP URL that coordinates with the desired stream rtsp 0.0.2 identifies the first stream rtsp 0.0.2 identifies the second stream rtsp 0.0.2 identifies the third stream rtsp 0.0.2 identifies the fourth stream Select Enter a smaller value for caching such as 2 0 0 ms Click Figure 6-2 RTSP URL of the First Stream in VLC The livestream plays in VLC Figure 6-3 View the First Stream in VLC The computer vision CV demonstrations below are based on public network files with public data sets except OpenNet and BiSeNet which are trained with Ambarella data For public network use follow the original license statement for the model files For the detailed URL of these model files refer to the CNNGen samples package Contact the Ambarella support team for assistance with Ambarella models Compile the binary with for CV5x and for CV7x The default configuration file is located in $SDK_ROOT $BOARD_NAME The demonstration network models are not included in the SDK package The following text provides two methods to get the network deployment binaries Use the CNNGen samples package to generate the network deployment binaries For more details refer to fs_cnngen_samples_pacakge.html in the Doxygen document which can be found in the CNNGen samples package Users can also use CNNGUI to easily set up these demos which is described in this section Contact the Ambarella support team to share the pre-converted network binary Resnet50 with sensor input This demonstration is not selected in the default configuration Select the option below to enable it For Cooper Amba build For Cooper Yocto build Use make resnet50 to generate resnet50_cavalry_fix8_full.bin in the CNNGen samples package The imagenet_1000.txt is located in the folder path ambarella/app/ai_cam/cvflow/imagenet YOLO-v3 with sensor input This demonstration is not selected in the default configuration Select the option below to enable it For Cooper Amba build For Cooper Yocto build Use make yolo_v3_sp50_amb_quant to generate yolo_v3_sp50_amb_quant_cavalry.bin in the CNNGen samples package YOLO-v3 with YUV input If LT6911 is unstable delete the LT6911 default microcontroller unit MCU code using the command test_vin w 0 xffff If the YUV input is selected set the mode to for the vsrc_id option in the Lua script FD MTCNN with the sensor input This demonstration is not selected in the default configuration To enable it select the option below For Cooper Amba build For Cooper Yocto build Place the files on the SD card with the following structure Use make pnet to generate ten PNet binaries with the input resolution modification for prototxt and make menuconfig in the CNNGen samples package Then use make onet and make rnet for onet and rnet For more details refer to fs_cnngen_caffe_demos.html::sec_caffe_mtcnn in the Doxygen document in the CNNGen samples package Use the CNNGen samples package to generate ten PNet models with different input resolutions one RNet model and one ONet model The PNet models name must be pnet* bin the RNet model name must be rnet* bin and the ONet model name must be onet* bin to be read by the test_mtcnn demonstration Place all Cavalry bin models on the SD card such as under Face detection and face recognition FDFR RetinaFace and MobileFaceNet with sensor input This demonstration is not selected in the default configuration To enable the demonstration select the option below For Cooper Amba build For Cooper Yocto build Place the files on the SD card with the following structure Use make onnx_retinaface to generate the Cavalry binary in the CNNGen samples package and rename it to onnx_retinaface_cavalry.bin Then place it in Use make mobilefacenets to generate the Cavalry binary in the CNNGen samples package and rename it to mobilefacenets_cavalry.bin Then place it in BiSeNet with sensor input This demonstration is not selected in the default configuration Select the option below to enable it For Cooper Amba build For Cooper Yocto build Use make bisenet to generate bisenet_cavalry.bin in the CNNGen samples package Set the input buffer resolution to 1 2 8 0 x720 and the frame buffer to 3 2 0 x180 The real network input is 1 2 8 0 x512 and the network output is 3 2 0 x128 The bottom has no detection as it is the headstock On the top of the screen it will detect and which are used for auto-driving Ambarella recommends using HDMI VIN as a test case OpenNet with sensor input This demonstration is not selected in the default configuration Select the option below to enable it For Cooper amba build For Cooper Yocto build Use make opennet to generate opennet_cavalry.bin in the CNNGen samples package The arm_priorbox.bin is located in the path cnngen_samples caffe demo_networks opennet models and demonstrated in the following example The code is similar to BiSeNet Do not modify any of the commands Follow the steps below to run the demonstration using the evaluation package Flash the binary released together with the evaluation package cv5_ipcam_config_evaluation_sdk_* bin For the CV5 EVK board that is compiled into a maximum of four channels cv52_ipcam_lp4/lp5_config_evaluation_sdk_* bin For the CV52 EVK board that is compiled into a maximum of four channels cv72_ipcam_lp4/lp5_config_evaluation_sdk_* bin For the CV72 EVK board that is compiled into a maximum of four channels Run the applications using the EVK board The demonstration network models are not included in the SDK package The following text provides two methods for the user to get the network deployment binary Use the CNNGen samples package to generate For more details refer to fs_cnngen_samples_pacakge.html in the Doxygen document in the CNNGen samples package Users also can use CNNGUI to easily set up these demos which are mentioned in this section Contact the Ambarella support team to share the pre-converted network binary Resnet50 with sensor input This demonstration is not selected in the default configuration Select the option below to enable it For Cooper Amba build Use make resnet50 to generate resnet50_cavalry_fix8_full.bin in the CNNGen samples package The imagenet_1000.txt is located in the folder path ambarella/app/ai_cam/cvflow/imagenet YOLO-v3 with sensor input This demonstration is not selected in the default configuration Select the option below to enable it For Cooper Amba build Use make yolo_v3_sp50_amb_quant to generate yolo_v3_sp50_amb_quant_cavalry.bin in the CNNGen samples package YOLO-v3 with YUV input If LT6911 is unstable delete the LT6911 default MCU code using the command test_vin w 0 xffff If YUV input is selected set the mode to for the vsrc_id option in the Lua script FD MTCNN with the sensor input This demonstration is not selected in the default configuration To enable it select the option below For Cooper Amba build Place the files on the SD card with the following structure Use make pnet to generate ten PNet binaries with the input resolution modification for prototxt and make menuconfig in the CNNGen samples package Then use make onet and make rnet for onet and rnet For more details refer to fs_cnngen_caffe_demos.html::sec_caffe_mtcnn in the Doxygen document in the CNNGen samples package Use the CNNGen samples package to generate ten PNet models with different input resolutions one RNet model and one ONet model The PNet models name must be pnet* bin the RNet model name must be rnet* bin and the ONet model name must be onet* bin to be read by the test_mtcnn demonstration Place all Cavalry bin models on the SD card such as under FDFR RetinaFace and MobileFaceNet with sensor input This demonstration is not selected in the default configuration To enable the demonstration select the option below For Cooper Amba build Place the files on the SD card with the following structure Use make onnx_retinaface to generate the Cavalry binary in the CNNGen samples package and rename it to onnx_retinaface_cavalry.bin Then place it in Use make mobilefacenets to generate the Cavalry binary in the CNNGen samples package and rename it to mobilefacenets_cavalry.bin Then place it in BiSeNet with the sensor input This demonstration is not selected in the default configuration Select the option below to enable it For Cooper amba build Use make bisenet to generate bisenet_cavalry.bin in the CNNGen samples package Set the input buffer resolution to 1 2 8 0 x720 and the frame buffer to 3 2 0 x180 The real network input is 1 2 8 0 x512 and the network output is 3 2 0 x128 The bottom has no detection as it is the headstock On the top of the screen it will detect and which are used for auto-driving Ambarella recommends using HDMI VIN as a test case OpenNet with sensor input This demonstration is not selected in the default configuration Select the option below to enable it For Cooper Amba build Use make opennet to generate opennet_cavalry.bin in the CNNGen samples package The arm_priorbox.bin is located in the path cnngen_samples caffe demo_networks opennet models and demonstrated in the following example The code is similar to BiSeNet Do not modify any of the commands This chapter includes the following sections Section 7.1 Enter USB Download Mode Section 7.2 Fastboot Tool for Ubuntu Section 7.3 Fastboot Tool for Windows Section 7.4 AmbaUSB for Ubuntu Section 7.5 AmbaUSB for Windows There are two ways to switch the platform to USB download mode Enter USB download mode from AMBoot shell Enter USB download mode from USB boot which is used when the bootloader BLD malfunctions Steps 1 through 3 below describe how to enter USB download mode from the AMBoot shell If the console shows no response from the platform proceed to step 4 Connect the platform and the PC using a USB cable Verify that the dual in-line package DIP switches are in NAND boot mode Figure 7-1 DIP Switches in NAND Boot Mode Connect to the serial console In the serial console press and hold the Enter key on the keyboard and then press the hardware RESET button The development platform will switch to the AMBoot shell as shown in the below If the readout above appears on the console the platform has successfully entered USB download mode If the development platform does not respond or fails to enter the AMBoot shell proceed to step 6 Commands to be typed in the AMBoot shell are indicated by the AMBoot prompt Type or to enter USB download mode for fastboot tools Or type or to enter USB download mode for AmbaUSB If the platform fails to enter USB download mode from the AMBoot shell set the DIP switches as shown in the figures below Then power on the platform The platform enters USB download mode using the USB Boot Figure 7-2 DIP Switches in USB Boot Mode After the development platform enters USB download mode the PC will recognize the USB device The PC display will pop up a message to indicate that the platform is connected as a USB device If the PC cannot recognize the platform upgrade the Ambarella USB driver On a Windows 7 PC select Device Manager Universal Serial Bus controllers Unknown device Update the driver from this device The Ambarella USB driver can be found in $(Where AmbaUSB is installed) Driver AmbaUSB is the tool used to upgrade the platform on Ubuntu PC using a USB Locate the installation programs in Tools/AmbaUSB Operating system OS requirement Ubuntu 16.04 LTS 18.04 LTS If this is the first time connecting the CV5 or CV72 EVK to Ubuntu proceed with the following commands to set up a basic burning environment Refer to the following steps to download new firmware if the EVK enters into download mode by setting DIP switches If the EVK enters into download mode by typing or in AMBoot proceed to step 4 Open a new console and switch to the fastboot tool folder in the folder platform-tools_rxx.x.x linux Connect the board to the PC using a USB cable and ensure that the board enters into USB download mode Ensure that the USB can successfully identify the USB device with Execute pack_image_usb to bring up fastboot Once the EVK enters fastboot is the critical word to find the correct device recognized by Ubuntu Execute fastboot to download the binary firmware The serial console of the development platform indicates the upgrading progress The fastboot tool platform-tools_rxx.x.x windows is used to upgrade the platform on a PC via USB OS requirement 3 2 bit or 6 4 bit Windows 7 or above Refer to the following steps to download the new firmware if the EVK enters download mode by setting DIP switches If the EVK enters into download mode by typing or in AMBoot proceed to step 4 Open a new console and switch to the fastboot tool folder found in the folder platform-tools_rxx.x.x windows Connect the board to the PC using a USB cable and ensure that the board enters into USB download mode Ensure that the driver has been updated by checking the driver version Figure 7-3 AmbaUSB Driver Execute pack_image_usb.exe to initiate fastboot Once the EVK enters fastboot the word is required to ensure that the correct device is recognized by the PC Figure 7-4 Fastboot Android Device Execute fastboot.exe to download the binary firmware The serial console of the development platform indicates the upgrading progress AmbaUSB is the tool used to upgrade the platform on Ubuntu PC using the USB Locate the installation programs in Tools/AmbaUSB OS Requirement Ubuntu 16.04 LTS 18.04 LTS Select the appropriate installation program then double-click to install it Connect the board to the PC using a USB cable Before burning the firmware to the platform ensure that the platform has entered USB download mode as described in Section 7.1 Enter USB Download Mode Figure 7-5 Assign the Ambarella USB Device to the Virtual Machine Before using AmbaUSB in the Linux virtual machine assign the Ambarella USB device to the virtual machine Launch AmbaUSB Select the proper chip model for the boards s filter and flash configuration according to the table below AmbaUSB will recognize the connected board automatically if all options are consistent with the board connected to the host in the figure below Core Board Titanium Manganese Cr Co Chip CV5 CV5 CV52 CV52 Board configuration CV5.LPDDR5.NAND CV5.LPDDR4.NAND CV52_DDRC1.LPDDR5.NAND CV52_DDRC1.LPDDR4.NAND Click the Find button beside the firmware to browse the images that will be flashed to the board Figure 7-6 Downloading the Firmware Click the button with the blue arrow icon on the right to start downloading the firmware The serial console of the development platform will indicate the upgrading process When the image is downloaded the message appears on the serial console Refer to the code below The firmware will reboot automatically and load after it is downloaded with the DIP settings in NAND boot mode If it fails to flash the firmware into the board from the AMBoot shell enter USB boot mode as described in the previous section and try again If the DIP switches have been set to USB boot mode see the previous section set the DIP switches to NAND boot mode in Figure 7.1 Enter USB Download Mode and reboot AmbaUSB is used to upgrade the platform on a PC via USB The installation programs located in Tools/AmbaUSB include 3 2 bit and 6 4 bit PC versions of AmbaUSB OS Requirement 3 2 bit or 6 4 bit Windows 7 Choose the correct OS and double-click the installation program to install Connect the board and PC using a USB cable Verify that the board can enter USB download mode Ensure that the driver has been updated Check the driver version as shown in the following figure Select the proper chip model for the boards s filter and the proper flash configuration according to the table Board Configuration AmbaUSB will recognize the board automatically if the options are consistent with the board connected to the host as shown in the figure below Figure 7-7 AmbaUSB Driver Locate the firmware and click on the blue download icon to start the download See the following figure Figure 7-8 Auto-detection of the CV5 Timn Board Figure 7-9 Auto-detection of the CV52 CR CO Board Figure 7-10 Auto-detection of the CV72 GA GE Board Notes for CV52 boards Select CV5 for the board in the middle right Select LINUX.CV52_DDRC1.LPDDR4.NAND.540MHz for the CV52 CO board and select LINUX.CV52_DDRC1.LPDDR5.NAND.540MHz for the CV52 CR board The serial console of the development platform will indicate the upgrading process When the download is complete the message will be displayed on the serial console Ambarella uses Doxygen a tool for writing software documentation to generate SDK documents from the source code ensuring their alignment with rapid code development The SDK documents appear on webpages Currently Ambarella uses Doxygen to create webpages for the following Table 8 1 Ambarella Doxygen Webpages Catalog Content Ambarella Linux SDK System Overview Document Reading Guide Market Segments Getting Start Guide SDK Deliverables SDK Code Building Glossary and Abbreviations Hardware Hardware HW Modules Board CV5 Titanium Board CV52 Co Cr Board CV72 Ga Ge Build System Building System Introduction and Guidance Yocto Recipe Yocto FAQ Driver Cavalry Driver Application Programming Interface API Continuous Memory Allocator CMA Driver API IAV Driver API Sensor Parameters and Tuning Table Sensor and SERDES Driver Installation Library Advanced Software Framework ASF Library API Cavalry_Mem Library API Amba GStreamer Plugins Cavalry Opt Layers Library API CGPP Library API Data Process Library API EazyAI Library API Electronic Image Stabilization EIS Library API FAST_IO Library API Image Library API Image Flow Library API Neural Network Control NNCtrl Library API NNStreamer Library API Sensor Calibration Library API SmartFB Library API Smart Rate Control SmartRC V3 Library API Stitch Library API VPROC Library API Video BASIC Video Input BASIC Video Output BASIC RAW BASIC Channel BASIC Source Buffer BASIC Pyramid BASIC Canvas BASIC Stream BASIC H.264 H.265 Codec BASIC Group of Pictures GOP BASIC On the Fly Settings BASIC Privacy Mask BASIC Blur on Streams BASIC Overlay on Streams BASIC Data Dumping BASIC Frame Rate BASIC High Dynamic Range HDR ADVANCED Encode Mode ADVANCED Configure with Lua Script ADVANCED Lens Distortion Correction LDC ADVANCED Vsync Loss ADVANCED Arbitrary Image Scaler ADVANCED Encode from Memory ADVANCED Encode from RAW ADVANCED Pipeline Latency ADVANCED Poll Interface ADVANCED Bypass IDSP for YUV input OTHER Debug Option OTHER Miscellaneous OTHER Dynamic Random-Access Memory DRAM Bandwidth Statistics Security Overview System Migration Guide from CV2x Boot and Upgrade DRAM Optimization Hardware Presentation Time Stamp PTS Power Management Sensor Calibration User Guide Multi-VIN Design AMBoot Documents AMBA System Document PDF Documents Kernel Documents Peripherals Audio File System NAND eMMC Debugfs USB SD Card WiFi Bluetooth SPI I2C Peripheral Component Interconnect Express PCIe Express Ethernet Misellaneous Joint Test Action Group JTAG Applications Ambarella Applications Document Access Control Camera Future SDK versions will include additional webpages Users can visit for more information about the Doxygen software This chapter includes the following sections Section 8.1 Generating the SDK Document Website Section 8.2 Generated CNNGen Document Website To view the document webpages Go to download a suitable binary and install the Doxygen software Ensure that the software is functioning correctly In the build PC go to the CNNGen samples package build folder Webpages are located in ambarella/out/doc_out/cv5x_doc/doc/overview/ Use the browser to open the index.html and display the webpage as shown below Figure 8-1 Generated Document Webpages Follow the steps below to find the document website Download the cvflow_cnngen_samples_ version _ date tar.xz from PRO system Find cvflow_cnngen_documents_ version _ date tar.bz2 in above package And open feature_sets/index.html with browser Then the document is displayed as in the example below Figure 8-2 Generated CNNGen Document Websites Dhrystone is a synthetic computing benchmark program developed in 1 9 8 4 by Reinhold P Weicker intended to be representative of system integer programming Dhrystone grew to become representative of general processor CPU performance The Dhrystone benchmark contains no floating point operations thus the name is a pun on the then-popular Whetstone benchmark for floating point operations The output from the benchmark is the number of Dhrystones per second the number of iterations of the main code loop per second Both Whetstone and Dhrystone are synthetic benchmarks meaning that they are simple programs that are carefully designed to statistically mimic the processor usage of some common sets of programs Dhrystone may represent a result more meaningfully than millions of instructions per second MIPS A common representation of the Dhrystone benchmark is the DMIPS Dhrystone MIPS obtained when the Dhrystone score is divided by 1 7 5 7 the number of Dhrystones per second obtained on the VAX 1 1 nominally a 1 MIPS machine Dhrystone s open source code has been introduced into the Ambarella SDKs It is located in the ambarella/unit_test/linux/benchmark/dhrystone folder Users can enable the Dhrystone compile when building the firmware Use the following command to perform the test CoreMark®-PRO is a comprehensive advanced processor benchmark that functions with and enhances the market-proven industry-standard EEMBC CoreMark® benchmark While CoreMark stresses the CPU pipeline CoreMark-PRO tests the entire processor adding comprehensive support for multicore technology a combination of integer and floating-point workloads and data sets for utilizing larger memory subsystems Together EEMBC CoreMark and CoreMark-PRO provide a standard benchmark covering the spectrum from low-end microcontrollers to high-performance computing processors The EEMBC CoreMark-PRO benchmark contains five prevalent integer workloads and four popular floating-point workloads The integer workloads include JPEG compression ZIP compression XML parsing SHA-256 Secure Hash Algorithm A more memory-intensive version of the original CoreMark The floating-point workloads include Radix-2 Fast Fourier Transform FFT Gaussian elimination with partial pivoting derived from LINPACK A simple neural-net A greatly improved version of the Livermore loops benchmark using the following 2 4 FORTRAN kernels CoreMark-PRO s open source code has been introduced into the Ambarella SDKs It is located in the ambarella/unit_test/linux/benchmark/coremark-pro folder Users can enable the CoreMark-PRO compile when building the firmware For Cooper Amba build For Cooper Yocto build Use the following command to execute the test where 6 represents the number of runs and the default is 1 The CV5x EVK board has two secure digital SD interfaces The larger slot is used for the SD card and the smaller slot is used for the secure digital input output SDIO WiFi card The two SD slots are independent they possess their own SD controllers The SDIO controller does not support the UHS-I mode SD slot 0 can support booting with embedded multi-media controller card eMMC while SD slot 1 cannot The maximum frequency of the SD controller is 1 5 0 MHz This chapter includes the following sections Section 10.1 SD Slot Section 10.2 SD Card Type Section 10.3 Hardware and Software Preparation Section 10.4 Format and Mount The following figure shows the bottom of the CV5 Timn board The SD card is visible in the top slot Figure 10-1 SD Slots The default value of fixed_cd is 1 1 Auto detect 0 No detection 1 Force detect once Turn off the slot if it is not in use Too many unused SD interrupts can lead to a heavy system load impacting network performance To trigger the CD to scan the SD bus manually modify the value of fixed_cd For the CV5 Timn board the must be modified to to TF card or to SD card SD is a non-volatile memory card format developed by the SD Card Association for use in portable devices See for further details Users can also refer to for SD card standards Figure 10-2 SD SDHC SDXC MMC Cards from Various Vendors Figure 10-3 Pins on an SD Card If the application requires continuous data storage Ambarella recommends using high speed high quality SD cards High speed high quality SD cards write data in less time and require less CPU for I/O The following sections provide information about SD card format speed and design notes Ambarella does not recommend normal-speed SD cards low-speed SD cards low-speed multi-media cards MMC or small-capacity SD cards for typical internet protocol camera IPCAM system designs or car DV designs As an alternative Ambarella recommends using the secure digital high capacity SDHC class 4 or above for continuous data writing applications If applications require long-time continuous data writing Ambarella recommends using SDHC class 4 or above for typical IPCAM or car DV products Although various SD cards may be usable with CV5x CV7x only the SD cards in the following list are verified on the CV5x CV7x EVK board Table 1 0 1 Verified SD Card Brand Class Capacity Type Kingston Normal 2 GB MicroSD card Class 4 4 GB MicroSD card 2 GB SD card 4 GB SD card Class 4 4 GB SDHC card Kingmax Normal 2 GB MicroSD card Class 6 4 GB Micro-SDHC card SanDisk Class 2 4 GB MicroSD card Class 4 4 GB MicroSD card Normal 5 1 2 MB SD card Class 2 4 GB SDHC card Class 4 4 GB SDHC card Toshiba Class 4 4 GB MicroSD card Class 1 0 1 6 GB SDHC card Apacer 2 GB MicroSD card Class 4 4 GB MicroSD card PNY 2 GB MicroSD card Class 4 4 GB MicroSD card PQI 2 GB MicroSD card Esuninfo 2 GB MicroSD card Verbatim 2 GB MicroSD card SONY Class 4 3 2 GB MicroSD card Lenovo 1 GB SD card Adata 2 5 6 MB SD card Transcend Class 1 0 8 GB SDHC card Class 1 0 3 2 GB SDHC card For CV5 Timn EVK the pin function of the SD card and the TransFlash TF card are multiplexed with I2C VSYNC SPI bus With the default settings the I2C VSYNC SPI bus are enabled Follow the steps below to enable the SD card or TF card function SD card Enable SDIO0 before building the firmware For Cooper Amba build For Cooper Yocto build Modify the hardware power-on configuration POC and jumpers Set SW2_1 SW2_2 SW2_3 off SW2 is close to the senor slots Switch the jumper from J18 to J16 TF card Enable SDIO1 before building the firmware For Cooper Amba build For Cooper Yocto build Modify hardware POC and Jumpers Set SW2_1 SW2_2 SW2_4 off Switch the jumper from J24 to J22 Although the Cooper SDK has an integrated common file system users must open the corresponding configuration when building the firmware exFAT EXT4 The CV5x CV7x board recognizes the SD card after the card is inserted into the SD card slot and it is automatically mounted to Enter on the CV5x CV7x board to see the mounting information Before removing the SD card close all files and then unmount the SD card see the following If the message appears ensure that all files on the SD card are closed and is not being accessed type to go to the root directory Format an SD card Although the SD card may come pre-formatted Ambarella recommends formatting the card manually to avoid potential errors and to maximize the performance The SD card can be formatted to FAT32 NTFS ext3 and other file systems For SD cards equal to or less than 3 2 GB Ambarella recommends FAT32 For SD cards greater than 3 2 GB NTFS is preferred as Windows limits FAT32 partitions to 3 2 GB Windows 7 also supports exFAT but exFAT is not formally supported by the Linux kernel Ext3 is supported by Linux to support big SDHC or SDXC cards but Windows does not recognize ext3 There are three main options to format the SD cards to the required format To successfully format an SD card the write protection lock on the side of the card must be in the position SD mini and micro SD cards must be used with an adapter or specialized USB card reader when a computer is formatting them Use a format utility Most computer systems include generic formatting utilities for nearly every format of writable media For example in Windows OS users can access the format option by right-clicking an driver in the folder Use the default settings to format the SD card The SD Association SD Formatter is the recommended option for the Windows OS platform The SD Formatter is recommended because the generic format utilities are not designed to format the SD cards to their official SD memory format requirements that enable them to run on devices at their optimum performance The SD formatter offered by the SD Association is free and can be found at SDcard.org The tool mkdosfs is included in the Cooper Linux SDK The tool mkdosfs can format an SD card to the FAT32 format It is used to create a disk operating system DOS file system under Linux If users intend to use an SD card as common data storage they must format the card in their products under Linux using mkdosfs to ensure the optimal performance An SD card formatted by a different tool on Windows can potentially result in lower performance Check file system integrity The tool fsck is used to check and repair the MS-DOS file system If the SD card is removed before unmounting users must check the integrity of the file system again before using the card Removing the SD card before unmounting can cause inconsistent data storage and reduce the integrity of the file system To avoid this potential issue good product design should include unmounting the SD card before removing Alternatively it should call the power-off command to enable the system to close all open files and flush the data to synchronize and then unmount Partition an SD card Occasionally users must partition the SD card For example if a user must format a 6 4 GB secure digital extended capacity SDXC card to the FAT32 file system note the following because Windows limits FAT32 to 3 2 GB multiple partitions are required However only the first partition can be seen on Windows while Linux can display all partitions Gparted is a software utility which scans a storage device It examines the data in order to detect partitions which may exist but are absent from the disk s partition tables For more details go to If users must access all partitions in Windows Ambarella does not recommend using the Linux tool to partition As an alternative users can attempt to port exFAT to Linux or use NTFS on the SD card to support large partitions that can be recognized on Windows Copyright c 2 0 2 4 Ambarella International LP This file and its contents are protected by intellectual property rights including without limitation U.S and/or foreign copyrights This Software is also the confidential and proprietary information of Ambarella International LP and its licensors You may not use reproduce disclose distribute modify or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates In the absence of such an agreement you agree to promptly notify and return this Software to Ambarella International LP THIS SOFTWARE IS PROVIDED AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS COMPUTER FAILURE OR MALFUNCTION OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">doc_abbr</field>
    <field name="url">d9/d09/doc_abbr.html</field>
    <field name="keywords"></field>
    <field name="text">Glossary and Abbreviations Glossary and Abbreviations This page provides a table of abbreviations and terminologies used throughout the Ambarella CV2x CV5x Flexible Linux Software Development Kit SDK Initial Abbreviation Full Name 0 9 3 A AE AWB ADJ A ADJ Auto adjustment AE Auto exposure AF Auto focus AGC Automatic gain control AR Aspect ratio AVC Advanced video coding H.264 AWB Auto white balance B BLD Boot loader BPC Bad pixel correction BSB Bitstream buffer BST Bootstrap BW Bandwidth C CBR Constant bit rate a rate control method CCM Color conversion matrix converts color space typically from the YUV domain to RGB domain CE Contrast enhancement CEC Consumer electronics control CFA Color filter array CIF Common intermediate format resolution is 3 5 2 x288 CLUT Color look-up table CMA Contiguous memory allocation CMOS Complementary metal-oxide semiconductor CNN Convolutional neural network codec Refers to COmpressor DECompressor or COder DECoder CTB Coding tree block H.265 HEVC coding block CTU Coding tree unit minimum coding unit of H.265 HEVC CV Computer Vision CVBS Composite video with blanking and sync VOUT format D DAG Directed acylic graphs DCG Dual conversion gain related to HCG-LCG DIS Digital image stabilization DOL Digital overlap HDR technology related to LEF-SEF DPTZ Digital pan tilt zoom DRA Dynamic range analysis CNN processing method DSP Digital signal processor E ECC Error-correcting code EFM Encode from memory EFR Encode from RAW EIS Electronic image stabilization EoF End of frame describes the end of a VIN frame similar to SoF ES Elementary stream raw bitstream content without a file container EV Evaluation EVK Evaluation kit F FoV Field of view FPS Frames per second G GDC Geometry distortion correction same as LDC GOP Group of pictures AVC HEVC encode term H HCG High-conversion gain type of gain in sensor DCG mode HDR High dynamic range HEVC High-efficiency video coding H.265 I IAV Image audio video ICE Inception convolution engine hardware block inside the vision processor IDR Instantaneous decoding refresh AVC HEVC frame type ISO Light sensibility ordinance L LCG Low conversion gain type of gain in sensor DCG mode LEF Long exposure frame type of frame in sensor DOL-HDR mode LDC Lens distortion correction same as GDC M MB Macroblock H.264 AVC coding block MCTF Motion-compensated temporal filter MD Motion detection ME Motion estimation codec term MMB Memory management block MV Motion vector codec term N NTP Network time protocol O Oryx Camera middleware in the Linux SDK OSD Onscreen display means that the content is displayed onscreen above the video layer P PM Privacy mask PWC Power controller Q QP Quantization parameter AVC HEVC encoding term QPM QP matrix controls AVC HEVC encode quality MB- or CTB-level R RC Rate control RGB-IR Red green blue infrared CMOS sensor format ROI Region of interest RTC Real-time clock S SDK Software development kit SEF Short exposure frame type of frame in sensor DOL-HDR mode SNR Signal-noise ratio SoC System on chip SoF Start of frame describe the start of the VIN frame similar to EoF SPU Stereo processing unit SVC Scalable video coding AVC HEVC encoding term W WDT Watchdog timer Z ZMV Zero motion vector related to MV</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">ov_sensor_bringup_guide</field>
    <field name="url">d9/d1e/ov_sensor_bringup_guide.html</field>
    <field name="keywords"></field>
    <field name="text">Sensor Bring-Up Guide Sensor Bring-Up Guide This document guides users through the video input VIN bring-up process on the Ambarella platform This section is divided into the following sections 1.1 Key Updates Table 1 1 Key Updates Version Updated Date Modification 1.0 2 0 2 3 0 2 0 2 Initial Version 1.1 2 0 2 3 0 9 2 2 Move to common directory and add other SoC support To aid customers through bringing-up the VIN and sensor Ambarella provides the following guide to prepare configure and test the VIN and sensor on the Ambarella platform This section describes the general Vin sensor bring-up steps Upon the arrival of a new sensor the following steps must be performed Verify that the sensor driver exists in the software development kit SDK If not Ambarella will add the sensor driver Connect the sensor to the main board Verify that the sensor module uses an internal crystal or an external clock Check if the sensor module s output format can be supported by the serializer deserializer SERDES For example a sensor module s output may be 1 6 bit RAW but SERDES can only accept 1 4 bit RAW To remedy this situation users must modify the sensor s configuration or replace the SERDES group Check if the sensor module includes an image signal processor ISP If the ISP is in the YUV module the dummy sensor driver can be attempted for example Sensor type AR0231 AR0239 OV9706 Sensor interface mobile industry processer interface MIPI® parallel HiSPi™ Sensor bits 1 0 bits 1 2 bits 1 6 bits Sensor work voltage 5 V 1 2 V Sensor clock 2 4 MHz 2 7 MHz external oscillator or from another source such as from the CV2x clock source gclk_so and from the serializer Sensor reset pin RC circuit or controlled by another general purpose input output GPIO Sensor I2C address Similar to configuring most devices in Linux VIN must be configured in the device trees DTS For example when a sensor module is connected in I2C bus 3 the module should be configured as shown below Figure 3-1 DTS Configuration of Local Sensor There are many sensors that can be supported in the Ambarella platform The user must select the corresponding sensor driver when compiling the Ambarella SDK An IMX335 sensor is used in the example below For CV2x SDK 3 0 Amba build For Cooper SDK Amba build For Cooper SDK Yocto build When the firmware is generated and downloaded onto the board all sensor drivers are located in Users can use the insmod or modprobe commands to load the correct sensor driver Some parameters such as bus_id addr vinc_id can be specified when a sensor driver is loaded Serializer Serializer type MAX96705 TI953 TI913 TI935 Serializer power source power can come from a coaxial cable via power-on configuration POC Important pins for serializer MAX96705 BWS and HIM pins connecting the HIM pin to IOVDD is prefered LCCEN pin LCCEN typically connects to IOVDD It can also connect to MAX96705 s GPIO Other pins include PWDNB CONF0 CONF1 TI953 TI913 TI935 PDB pin MODE_SET CLK_IN Clock source can be an external oscillator or be supplied by deserializer through BC-ward Deserializer Deserializer type MAX9286 TI954 TI936 Power to deserializer Important pins for deserializer MAX9286 BWS and HIM pins connecting HIM pin to IOVDD is preferred Others pins include PWDNB CONF0 CONF1 TI954(clock, PDB pin, IDX, MODE, ...) IDX determines TI954 s I2C bus address MODE pin determines the TI954 s receiver RX mode and it can be programmed by the driver For more information on how to configure the SERDES driver users can take reference from 3.4 Sensors with SERDES Bridge Select the correct SERDES driver such as B8 imx290_brg For CV2x SDK 3 0 Amba build For Cooper SDK Amba build For Cooper SDK Yocto build When the firmware is generated and downloaded into board all sensor drivers are located in Users can use insmod or modprobe command to load the correct sensor driver For information on how to load the SERDES driver users can reference Driver Installation Guide The Ambarella video driver is called the image audio video IAV device driver It includes a set of Linux device drivers that encapsulate the lower-level complexities of digital signal processor DSP core functionalities The driver exposes a series of APIs that can be invoked using device IOCTL system calls Figure 4-1 displays the IAV structure Figure 4-1 IAV Driver Structure The following figure is the system architecture of the sensor driver Figure 4-2 Sensor Driver Architecture Because there are so many sensor drivers IMX335 is used as an example The sensor ID is defined in ambarella/include/iav_vin_common.h for CV2x SDK 3.0 and ambarella/drv_modules/private/video/dsp_ h for Cooper SDK When a new sensor driver is added for Cooper SDK ambarella/build/bin/common/gen_build_chain.py automatically manages the configuration of the compile switch for CV2x SDK 3.0 the configuration for must be added into ambarella/kernel/private/platform/vin/sensors/AmbaConfig There are five files for sony_imx335_mipi listed below Figure 4-3 Tree of IMX335 Driver on CV2x SDK 3 0 Figure 4-4 Tree of IMX335 Driver on Cooper SDK Many constants are defined in imx335.h The register table and video modes that can be supported by IMX335 are listed in imx335_table.c the main source code of the IMX335 sensor driver is included in imx335.c The entry point of this driver is imx335_probe it will be called when the user loads this driver After initialization operations are completed in the probe function the sensor driver will register the current sensor driver into the IAV module by calling the ambarella_vin_register_device interface This interface passes an important parameter imx335_ops to the VIN module Figure 4-5 IMX335_MIPI OPS Users can find the declaration of the vin_ops structure in ambarella/kernel/private/include/vin_api.h for CV2x SDK 3.0 and ambarella/drv_modules/private/video/dsp_ h for Cooper SDK Figure 4-6 VIN OPS When the user wants to execute an operation such as adjusting the frame rate of a sensor an IOCTL system call must be executed at the application level Then the IAV s VIN module accepts this IOCTL system call and the function pointer set_frame_rate in vin_ops is called Finally imx335_set_fps is executed because it is assigned to the set_frame_rate function pointer The following figure is the system architecture of SERDES driver Figure 4-7 SERDES Driver Architecture Similar to imx335_mipi imx335_mipi_brg is used as an example The sensor ID is defined in ambarella/include/iav_vin_common.h for CV2x SDK 3.0 and ambarella/drv_modules/private/video/dsp_ h for Cooper SDK When a new bridge sensor driver is added for Cooper SDK ambarella/build/bin/common/gen_build_chain.py automatically manages the configuration of the compile switch for CV2x SDK 3.0 the configuration for must be added into ambarella/kernel/private/platform/vin/sensors/AmbaConfig Video modes and operations are similar to IMX335 the differences of IMX335_BRG are located in imx335_probe For imx335_mipi after initialization operations are completed in the probe interface ambarella_vin_register_device is called to create a connection with the IAV s VIN module For imx335_mipi_brg the VIN module calls amba_brg_register_device to create a connection with the bridge driver Then the bridge driver ambrg.c calls ambarella_vin_register_device with imx335_mipi_brg s OPS to create a connection with the IAV s VIN module Device Tree Figure 4-8 SERDES Device Trees brgpwr-gpios power GPIO for deserializer brgrst-gpios reset GPIO for deserializer bus-addr related to the specified driver s parameter dts_addr vinc_id related to the bridge driver parameter vinc_id Power-on and Reset In the amba_register_vin_brg ambrg.c function ambrg_init_pwr_rst_gpio will be called to get GPIO definitions from the device table Power-on and reset operations are executed in the ambarella_vin_register_device function Bridge Driver Operations Interfaces to read and write registers Table 4 1 Interfaces to Read and Write Registers Hardware Read Write Interfaces Name Serializer Deserializer Read brg_read_reg Write brg_write_reg Sensor Read brg_read_chan_reg Write brg_write_chan_reg brg_hw_init_pre This interface is used to initialize SERDES and remap the I2C address of the serializer and sensor Table 4 2 Hardware Address and Remapping I2C Address Hardware Hardware Address I2C Address Remapping Serializer pinfo- i2c_ctrl.addr.ser_def pinfo- i2c_ctrl.addr.ser_chan0 Sensor pinfo- sensor_ctrl.dev_addr 1 pinfo- i2c_ctrl.add.sen_all 2 IDC_ADDR_SEN_BASE Texas Instrument s TI deserializer can automatically obtain the I2C address Before remapping the I2C address the deserializer will choose one port and turn off others MAXIM requires software to specify the hardware address Before remapping the i2c address MAXIM will choose one link and turn off others MAX9296 is used as an example brg_set_clk_si Some sensors do not use a crystal to provide a clock but instead require SERDES to output an external clock brg_vin_config_pre This interface is used to initialize connecting the configuration for the serializer and sensor Table 4 3 Parameters in brg_vin_config_pre Parameter Name Description Lane_number SENSOR_2_LANE SENSOR_4_LANE Lane mapping Lane order can change Lane speed Bandwidth to receive sensor data Pipeline streamID Related to vender brg_vout_config This interface is used to configure parameters between the deserializer and the SoC Table 4 4 Parameters in brg_vout_config Parameter Name Description lane_number SENSOR_2_LANE SENSOR_4_LANE interface_type SENSOR_MIPI SENSOR_MIPI_VC data_rate Choose the closest speed otherwise the video frame may be a single line enum SENSOR_MIPI_BIT_RATE_M 0 default 4 0 0 Mbps SENSOR_MIPI_BIT_RATE_H 8 0 0 Mbps SENSOR_MIPI_BIT_RATE_L 2 0 0 Mbps SENSOR_MIPI_BIT_RATE_UH 2 2 0 0 Mbps SENSOR_MIPI_BIT_RATE_NA for non-MIPI sensor brg_get_status This interface is used to check SERDES status When SERDES is locked the serializer registers can be read When a new sensor cannot function normally MIPI CLK DATA and SYNC signals must be checked first Certain I2C tools can be used to debug such as i2cdetect and i2ctranfer The command scans all I2C devices mounted on I2C bus 2 The command reads register 0 x5b s data from I2C device which is mounted on I2C bus 2 with an I2C address equal to 0 x38 The command writes 0 x13 to the register 0 x11 of the I2C device which is mounted on I2C bus 2 with an I2C address equal to 0 x38 The command manually pulls GPIO 8 1 to a high level The unit test program test_vin is located in ambarella/unit_test/private/vin_test/test_vin.c for CV2x SDK 3.0 and ambarella/unit_test/private/iav_test/dsp_ c By default it is compiled into te firmware with $board_ipcam_config selected The following is the usage information of test_vin Here users can use the test_vin options and to read and write registers Users can use amba_debug to dump SoC s registers as follows When the system is abnormal or in reset status value of register 0 xed1c800 CV2x 0 x20ed1e8000 CV5x and 0 xffed1e8000 are 0 x00000001 The normal value of register 0 xed1c00c8 in master mode is 0 x2841 CV2x The normal value of register 0 x20ed1e00bc in master mode is 0 xf CV5x The normal value of register 0 xffed1e00bc in master mode is 0 xf CV7x the normal value in slave mode is 0 x3841 CV2x the normal value in slave mode is 0 x40f CV5x and CV7x Ambarella provides the tool dsplog_cap to capture the DSP log Detailed debug information can help users locate issues Following steps will display how to configure and use this tool 1 Enable building dsplog_cap For CV2x SDK 3 0 Amba build For Cooper SDK Yocto build 2 Start to capture the DSP log board init.sh na board modprobe ambad board modprobe dsplog board dsplog_cap m all b all l 3 r 0 o bin p 1 0 0 0 0 0 0 0 3 When DSP enters into abnormal status 4 Then users can send dsplog.txt to the Ambarella support team to receive help When this issue occurs check if FSYNC pin is connected The wait time before synchronization is insufficient When this issue occurs follow the steps below Enssure that auto white balance AWB auto exposure AE auto focus AF 3 A parameters are correct Verify if VIN outputs video data dump the VIN register and check the number of lanes Ensure that SERDES has data Ensure that the sensor has data and check the data pin wave If multiple sensors are connected ensure that FSYNC TRIGGER pins are connected Users can use the unit test programs test_encode and test_stream to check if frame drop issues occur Below is an example on CV25 Hazelnut Evaluation Kit EVK with an IMX274 sensor Then users can watch the average frames per second FPS printed by test_stream unit test commands Along with the method mentioned above the feature detects frame drops For more details about this feature refer to example3_audit_function for CV2x and 3.5 IDSP and Encode Frame Drop Audit for other SoCs Copyright c 2 0 2 4 Ambarella International LP This file and its contents are protected by intellectual property rights including without limitation U.S and/or foreign copyrights This Software is also the confidential and proprietary information of Ambarella International LP and its licensors You may not use reproduce disclose distribute modify or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates In the absence of such an agreement you agree to promptly notify and return this Software to Ambarella International LP THIS SOFTWARE IS PROVIDED AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS COMPUTER FAILURE OR MALFUNCTION OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">ov_code_build</field>
    <field name="url">d9/d98/ov_code_build.html</field>
    <field name="keywords"></field>
    <field name="text">SDK Code Building SDK Code Building Revision History SDK Version Updated Date Modification CV5x_SDK_0.2 2 0 2 1 1 0 2 1 Initial Version CV5x_SDK_0.5 2 0 2 2 0 1 1 4 Updated Section 3.3 Install the Arm® Toolchain CV5x_SDK_1.0 2 0 2 2 0 4 1 5 Updated Section 3.3 Install the Arm® Toolchain Updated Section 4.3 Build Firmware CV5x_SDK_2.0 2 0 2 2 0 9 1 5 Migrated this Code Building document from Word form into Doxygen form 2 0 2 2 1 0 2 5 Update Cortex Toolchain to 12.1 in Section 3.3 Install the Arm® Toolchain CV5x_SDK_2.5 2 0 2 3 0 2 2 7 Updated Section 6.5 Network Sharing: NFS Cooper_SDK_0.5 2 0 2 3 0 4 2 0 Initial Version of Cooper SDK Cooper_SDK_1.0 2 0 2 3 0 7 2 0 Update Section 3.1 Install Ubuntu OS Updated Section 3.4 Install the Computer Vision CV Toolchain Updated Section 3.5 Install the CV Toolchain on Docker Updated Section 3.6 Install the CV Toolchain on Podman 2 0 2 3 0 8 1 1 Added Section 8 Build OSS Libraries This document provides information to help users navigate through the Ambarella Cooper Linux software development kit SDK prepare a build machine build the SDK and share it during product development The Ambarella Cooper Linux SDK development environment requires a host that uses the Linux operating system OS This document guides the reader through the installation and configuration of the Linux environment to assist in the compilation of the Cooper Linux SDK A cross-compile tool suite is used to compile the Linux images The configurations described in this document are provided as recommendations only This chapter describes how to perform the following Section 1.1 Scope of Document Section 1.2 Cooper Linux SDK Section 1.3 Software Architecture Section 1.4 Source Code Included in this document are the hardware software and network requirements for building the SDK and instructions for setting up the Ubuntu machine and PC The following describes the contents of each chapter Chapter includes a table of key document updates and an introduction to the SDK package contents software architecture and source code Chapter lists the development environment requirements Chapter provides instructions on setting up the Ubuntu machine for building codes Chapter 4 Build Full SDK Code provides instructions for building new firmware with the full SDK code Chapter provides instructions for building new firmware with the evaluation SDK package Chapter provides instructions for setting up the PC Chapter provides methods for upgrading the firmware on the CV5x CV7x board Chapter provdies instructions for building open source software OSS libraries Ambarella Cooper Linux SDK can be downloaded from the Ambarella Customer Portal site Contact the Ambarella support team for details on downloading the SDK The SDK includes the following Evaluation Evaluation package SDKx.x SDK package which includes code and documentation Package Source code package Document Hardware and software documentation Tools Ambarella tools The following figure shows the system architecture for the CV5x CV7x chip The Ambarella CV5x CV7x platform uses the flexible open source Linux operating system Developers can customize the Linux OS for many purposes including using a novel graphical user interface GUI engine such as Qt enhancing networking simplifying WiFi use and reusing available source libraries such as WebServer and HostAP Additionally users can easily port a variety of Linux video frameworks such as FFmpeg GStreamer and IPV6 Figure 1-1 Cooper Software Architecture The top directory of the Cooper Linux SDK package is ambarella/ Subdirectories are listed below Chapter 4 Build Full SDK Code introduces build commands to extract the code from the package Table 1 1 Code Directory Directory Content amboot/ Bootloader BLD board support toolkit and file system information about the partitions app/ Demo applications boards/ The compile configuration files DDR configuration and bootstrap BST build/ Rules for makefile and AmbaConfig document/ Doxygen content and configuration rules include/ Header files kernel/ Linux kernel digital signal processor DSP firmware image audio video IAV DSP sensor and peripheral devices drivers external External WiFi modules codes linux-5.15 Linux kernel and patch codes private Ambarella propriety drivers modules codes and binaries license/ License files of each component out/ The build target and intermediate objects packages/ Libraries that assist in video processing streaming or transferring data_transfer Code for data storage over NFS and code for data transferring via USB TCP img_algo Image algorithm library the pre-built binary is in ambarella/prebuild/imgproc Source codes are not released utils Utility library codes nnctrl Initial Cavalry binary which is generated by cavalry_gen vproc Pre-defined directed acyclic graphs DAGs used to convert the data format prebuild/ Pre-built binaries including Ambarella libraries and third-party libraries ambarella/library Binary format of various Ambarella proprietary libraries imgproc Binary format of library file and image tuning parameter files third-party Binary format of third party-library files rootfs/ System Rootfs unit_test/ Unit test tools The following shows the relationship between the software architecture figure Figure 1-1 Cooper Software Architecture and the source code directories Additional software modules will be added in later SDK versions Table 1 2 Code Category Category Architecture Directory System Bootstrap and BootLoader ambarella/boot/amboot Linux kernel and device driver ambarella/kernel/linux DSP IAV video input VIN video output VOUT ambarella/drv_modules File system ambarella/rootfs System configuration ambarella/boards Middleware Neural network control NNCtrl ambarella/packages/nnctrl VProc ambarella/packages/vproc Application Unit test tools ambarella/unit_test Demo applications ambarella/app The source code for the software shown in the application middleware and system frames down in Figure 1-1 Cooper Software Architecture are included in the SDK package Third-party libraries such as the image processing library the dewarp library fisheye and lens distortion correction LDC and the BST are provided as pre-built binaries Users can obtain the source code for each library from the internet Ambarella warrants the source code for the software shown in the middleware and system frames shown in figure Figure 1-1 Cooper Software Architecture Ambarella does not warrant the source code shown in the application frame Users can modify the unit test and applications source codes in order to meet product requirements The software shown in the application frame is provided to enhance the user experience and streamline application development Due to the similarity between the code directories and software layers of the CV2x SDK and the Cooper SDK upgrading to the Cooper SDK from the CV2x SDK is straightforward For more details refer to page Migration Guide From CV2x SDK This chapter includes the following sections Section 2.1 Overview Section 2.2 Linux Build Machine Section 2.3 Windows PC Section 2.4 Network Topology Using the Ambarella SDK requires three machines Portal release order PRO release server Linux build machine to cross-compile the binary Windows PC to download the binary The PRO server 1 is organized and supported by Ambarella Developers are expected to arrange and organize the Linux build machine 2 and the Windows PC 3 Figure 2-1 SDK Download Build Firmware Upgrade Pipeline The developer downloads the SDK package from the Ambarella PRO server to the PC and transfers the files to a Linux build machine that runs the Ubuntu server Chapter 3 Set Up the Linux Build Machine The toolchain can be used to build the code Chapter 4 Build Full SDK Code when it is installed in the build machine After the SDK is built the firmware is available to the build machine The development PC is prepared Chapter 5 Build Evaluation SDK Code and the firmware binary is transmitted to the PC described below The binary is then burned to flash on the development board using the Ambarella AmbaUSB tool Chapter 7 Upgrade the Firmware to the Development Platform Contact an Ambarella support team member for development board setup and use Ambarella recommends using a Samba server that has been set up on the build machine to transmit the firmware binary to the PC Samba setup is outside the scope of this document For pertinent information refer to The following are the hardware requirements for the Linux build environment refer to Chapter 3 Set Up the Linux Build Machine for more information 6 4 bit capable Two Intel(R) ® Xeon(R) ® X 5 6 7 0 2.93 GHz 1 2 M cache 3 2 GB memory 8 x 4 GB 1 3 3 3 MHz dual-rank RDIMMs for two processors 6 0 0 GB 3.5 inch 1 5 K RPM 6 Gbps SAS hot plug hard drive Dual-port gigabit Ethernet A Windows PC connected to the Internet is used to download the SDK and or upgrade the firmware Chapter 5 Build Evaluation SDK Code For more details about upgrading the firmware refer to Chapter 7 Upgrade the Firmware to the Development Platform The PC must support the following Table 2 1 PC Requirements Category Requirement CPU Intel i5 or higher grade Memory 8 GB system memory or more Hard disk 1 2 0 GB or more Video card 3 D hardware accelerator card required – 1 0 0 DirectX 9.0c compatible AMD ATI HD2600 Pro or NVidia 9 8 0 0 GT or above to assure the full frame rate of high-definition HD playback is preferred Monitor 1 9 inches LCD or larger with digital video interface DVI input DELL UltraSharp 2 7 0 9 W VA panel is preferred LCD TV 2 4 inch LCD TV or larger with YPbPr input 1 0 8 0 p resolution Ethernet card 1 0 0 0 Mbps adaptive I/O interfaces RS232 Operating system 6 4 bit Windows 7 8 or 6 4 bit Ubuntu 16.04 LTS Virtual machine Oracle Virtualbox 4.4.30 or later If multiple developers are working on a network Ambarella recommends acquiring a powerful build machine and sharing it on each developer s PC Developers A B and C can connect to the building server using SSH protocols in a local area network LAN LAN 1 All developer PCs should have two network cards the first card connected to a public LAN LAN 1 and the second to a private LAN LAN 2 3 4 between the local PC and the development board Because the SDK includes tools for Windows OS and the development board is based on Linux OS Ambarella suggests using a Linux virtual machine VM on a Windows PC to install the Ambarella SDK See the figure below for a diagram of the network topology for the development team with server sharing Section 6.3 Linux Virtual Machine provides instructions on installing the Linux virtual machine on Windows PCs and Section 6.4 Network Sharing: CIFS provides details on sharing the build machine between the PCs and the development boards Figure 2-2 Network Topology for the Development Team with Server Sharing This chapter includes the following sections Section 3.1 Install Ubuntu OS Section 3.2 Install Development Packages Section 3.3 Install the Arm® Toolchain Section 3.4 Install the Computer Vision CV Toolchain Section 3.5 Install the CV Toolchain on Docker Section 3.6 Install the CV Toolchain on Podman Access the Ubuntu official website At Download Options select Ubuntu Server 20.04.6 LTS Only 6 4 bit Ubuntu is supported To download the ISO file click the Download button Figure 3-1 Linux Ubuntu Download Selection and Download Button A common method for installing Ubuntu consists of creating a compact disk CD to install it after downloading the ISO file Many applications enable burning data to a disk including Rufus Ventoy UltraISO Nero Burning and Infra Recorder For further application recommendations refer to the following Ubuntu website To install Ubuntu using another form of media refer to the following links A 6 4 bit server is recommended for installing Ubuntu Refer to the hardware recommendations described in Section 2.2 Linux Build Machine Additionally note the following Prior to installation the machine should have no OS or data as the installation process erases all existing data Using a virtual machine is not recommended as it lengthens the SDK build time To build the Ambarella SDK the machine requires at least 1.5 GB of RAM and at least 1 5 GB of disk space if Ubuntu is running on a virtual machine Load the CD with the Ubuntu ISO file in the drive and restart the machine Verify that the basic input output system BIOS configuration and the machine settings are consistent with a boot from CD ROM From the Ubuntu installation start screen choose the preferred Language see the following figure Next choose Install Ubuntu Server see the following figure Figure 3-2 Ubuntu Installation Start Screen Follow the instructions on the screen Typically the Default settings will suffice At the Guided storage configuration prompt select Set up this disk as an LVM group and choose Done Figure 3-3 Ubuntu Installation LVM Setup For the prompt Storage configuration choose Done Figure 3-4 Ubuntu Installation Storage Configuration For the Confirm prompt and choose Yes Figure 3-5 Ubuntu Installation Confirm Destructive Action At the Profile setup screen enter the username and password and choose Done Figure 3-6 Ubuntu Installation Profile Setup At the SSH Setup prompt select Install OpenSSH server and choose Done Figure 3-7 Ubuntu Installation SSH Setup The following interface indicates that the installation is complete Figure 3-8 Ubuntu Installation Complete Configure the network with DHCP or static IP Log in to the server and configure the network according to the machine environment IP Address $ sudo vim edit files … DNS server $ sudo vim conf edit files … Restart networking $ sudo d/networking restart Use the following command to verify that the network is connected Ensure that the root is correct Users can access another website such as www.ubuntu.com to confirm the network connection Users must install several packages before beginning the development process In the Ambarella release for the Toolchain package users can locate the installation script to automatically install the required packages Ensure that the building workstation has Internet access then run the scripts below which are mentioned in the following sections The toolchain binary is PRO server which is named Ambarella_CortexA76_Toolchain_GCC* Date tar.xz The toolchain source code can be downloaded from the GCC official website and Git The version and commit ID used in the latest SDK are as follows The toolchain is often upgraded during SDK development Refer to the Ambarella Cooper Linux SDK Release Notes document for the exact toolchain version The following lists the steps for installing Arm Toolchain Download the toolchain package Ambarella_CortexA76_Toolchain_GCC* Date tar.xz from the PRO server Install the toolchain For Ubuntu Linux the commands are as follows Optional Write a simple program and run it on the development platform Create a file hello.c with the following content Compile the file Put the executable program in the development platform and run the following command There are two CNNGen packages for CVflow_v2 and CVflow_v3 both of which use Ubuntu 2 0 0 4 system Ambarella_Toolchain_CNNGen_2 tar.xz used is for CVflow_v2 CV2x and CV5x conversion AmbaCaffe is included for retaining purpose Ambarella_Toolchain_CNNGen_cv7x.3 tar.xz used for CVflow_v3 CV7x conversion users can use the AmbaCaffe in the CVflow_v2 CNNGen toolchain package Before running the installation script for the toolchain run the following command Users should regularly upgrade the operating system as shown below as the toolchain is developed using the latest version OS Although the command above is included in the installation script Ambarella recommends noting it and assigning it to an independent machine to avoid a possible build conflict Install the toolchain as shown below For Ubuntu Linux the commands are as follows Users can use the official Caffe from compile or they can use AmbaCaffe included in the package Additionally users can use AmbaCaffe_ version 0 4 cpu to build both the public Caffe and AmbaCaffe Note that in the user s system the user may be required to modify the script For more details refer to readme.txt in the CNNGen toolchain package Docker is an open source application-container engine that enables developers to package their applications and dependencies into a portable container then publish or virtualize them to any Linux machine Containers are completely sandboxed and do not interface with each other Docker also provides another method for users to deploy and run CNNGen The following sections describe how to install the CV Toolchain on Docker For more information about Docker refer to Dockers supports a variety of Ubuntu OS versions Docker can be installed on both physical and virtual machines The following steps for installing Docker are for reference only as users might have systems that require different Docker installations Install Docker using the following commands Add the current user to the Docker group and log in again or reboot if using a virtual machine otherwise Docker requires root privilege If users must deploy Docker on a server Ambarella recommends using secure shell SSH service for various users and not adding all users to the Docker group Docker includes a permission enabling users in this group to add any folder in this server to the Docker container and use to operate it Use the following command to verify the installation If the subsequent messages appear Docker is functioning correctly Users can then install Ubuntu and CNNGen toolchain with Dockerfile file as follows If users used below Docker file to install the environment please skip the steps in 3.5.2 Install Ubuntu on Docker For more details refer to the readme.txt in CNNGen Toolchain pacakge Users can also refer to the following sections to install the package manually Docker supports a variety of operating systems and applications running in independent containers When a container begins Docker automatically downloads the Docker image from the Docker image repository if it does not exist locally The default repository of Docker image is DockerHub To create an Ubuntu 20.04 container Pull the Docker image of Ubuntu 20.04 using the following command Docker supports many versions of Ubuntu Users can find the corresponding commands for pulling images from If users want to use Cuda in Docker NVIDIA-Docker should be installed NVIDIA-Docker is similar in usage to Docker Ambarella recommends using Ubuntu 18.04 to run CNNGen List local images using the following command Create a new folder for sharing files between the build machine and the container Then start a container and run a terminal as root Install sudo and vim using the following commands The option specifies the shared folders in the build machine requires a full path is in the container The option specifies the name of container The parameter specifies the Docker image which is pulled by step 1 Add a user account and add it to the group using the following commands Exit the terminal and begin again with a new user account The option specifies the username The usage above is an example any name can be used For more details about Docker usage refer to Section 3.5.5 Common Docker Commands This section describes installing and setting up the environment for CNNGen in a Docker container Copy the toolchain package via the shared folders and locate it in the container Install the toolchain using the following commands Because the image is pulled from DockerHub which does not include third-party tools users should install the tools using the following command Set the environment for CNNGen as follows If any of the following installations are unsuccessful repeatedly run the installed script to ensure successful installation of all programs For step 2 in particular various systems may require different components if errors occur during installation follow the error information and install the required components For more information about CNNGen refer to the CNNGen Doxygen Document in the CVflow® CNNGen Samples package To close and save a container Exit and check a container ID using the following commands Save the container as a Docker image using the following commands To begin a container with the saved Docker image use the following commands Because the container does not automatically save changes changes must be saved manually For common commands used with Docker refer to the following section This section provides examples of commonly used Docker commands For more details about Docker usage refer to Docker pull pulls Docker images from DockerHub Command Example Docker run starts a new container with an existing Docker image Command Example Options description Docker exec executes an application in a container Command Example Options description Docker commit saves a container as a Docker image Command Example Options description Docker images lists local Docker images Docker ps lists local containers Docker stop stops a container Command Example Docker rm removes the Docker container Command Example Docker rmi removes the local Docker container Command Example Podman is an open source management tool for running Linux containers which is similar to and compatible with Docker The advantage of Podman is that Podman can run in rootless mode and daemonless mode Normal users can use Podman to deploy containers in Linux servers The following sections describe how to install the CV toolchain on Podman For more details about Podman refer to Podman supports a variety of systems for Ubuntu OS Podman can be installed on both physical and virtual machines Refer to the following steps which are for Podman installation on Focal 20.04 Note that it is only for reference as users might have different system requirements for different Podman installations For Podman installation commands refer to Use the following command to verify the installation If the subsequent messages appear Podman is functioning correctly Next users can install the Ubuntu and CNNGen toolchains with Dockerfile file as shown below If users used below Docker file to install the environment please skip the steps in 3.6.2 Install Ubuntu on Podman For more details refer to readme.txt in the CNNGen toolchain pacakge Users can refer to the following sections to install the program manually Podman supports various OSs and applications running in independent containers When a container begins Podman automatically downloads the Docker image from DockerHub if it does not exist locally To create an Ubuntu 20.04 container Pull Ubuntu 20.04 Docker image using the following command Podman supports many versions of Ubuntu Users can find the corresponding commands for pulling images from To run CNNGen Ambarella recommends using Ubuntu 20.04 List local images using the following command Create a new folder for sharing files between the build machine and the container Start a container then run a terminal as root Install sudo and vim using the following commands The option specifies the shared folders is in the build machine and requires a full path is in the container The option specifies the name of container The parameter specifies the Docker image which is pulled by step 1 Add a user account and add it to the group using the following commands Exit the terminal and restart with a new user account The option specifies the user name The usage above is an example customers can use any name For more details about Podman usage refer to Section 3.6.5 Common Podman Commands This section describes how to install and set up the environment for CNNGen in a Podman container Copy the toolchain package via the shared folders and locate it in the container Install the toolchain using the following commands Because the image is pulled from DockerHub which does not include third-party tools users should install the tools using the following command Set the environment for CNNGen as follows If any of the following installations are unsuccessful repeatedly run the installed script to ensure successful installation of all programs For steps 2 and 3 in particular various systems might require different components if errors occur during installation follow the error information and install the required components For more information about CNNGen refer to the CNNGen Doxygen Document in the CVflow CNNGen Samples package To close and save a container Exit and check the container ID using the following commands Save the container as a Docker image using the following commands To initialize a container with the saved Podman image use the following commands As Podman does not automatically save system modifications users must save them manually For common commands in Podman refer to Section 3.6.5 Common Podman Commands This section provides examples of commonly-used Podman commands For more further details about Podman usage refer to Podman Pull pulls Docker images from DockerHub Command Example Podman Run starts a new container with an existing Podman image Command Example Options description Podman exec executes an application in a container Command Example Options description Podman commit saves a container as a Docker image Command Example Options description Podman images lists local Docker images Podman ps lists local containers Podman stop stops a container Command Example Podman rm removes local Podman containers Command Example Podman rmi removes local images Command Example This chapter includes the following sections Section 4.1 Download the SDK Package Section 4.2 Important SDK Folders Section 4.3 Build Firmware Section 4.4 Customize the Build Configuration Section 4.5 Make Target Options To allow access to the Cooper SDK tarred files Ambarella provides users with a file transfer protocol FTP account and directions for logging in to the Ambarella FTP server using an account password Users should not modify the SDK within the download directory If users must modify the SDK Ambarella recommends making a copy of the SDK and using the copied version instead The Ambarella Cooper Linux SDK code package includes cooper_linux_sdk This SDK is the formal release and contains the reference application static dynamic library files private drivers Linux kernel and file system Patches Optional This part contains the patches to the formal package Users can access an example with no patches provided using the Cooper SDK release file cooper_linux_sdk_****** tar.xz The folders listed in this section include the locations of several important components of the SDK To learn more information about a component refer to the documents listed below ambarella/drv_modules/private/video/dsp_v6/iav includes all DSP-related application programming interface API codes used for the video process pipeline Related Ambarella documentation includes the following Page Multi-VIN Design AMBA Flexible Linux SDK Document Doxygen ambarella/unit_test/private/iav_test this folder contains the demo applications for testing the DSP Related Ambarella documentation includes the following Page Getting Started Guide AMBA Cooper Linux SDK Document Doxygen Feature Sets ambarella/drv_modules/private/cavalry this folder includes the Cavalry-related API codes used for convolutional neural network CNN network cases Related Ambarella documentation is in the SDK Doxygen document of the SDK package ambarella/packages/vproc this folder includes the VProc code used to prepare the network input frame Related Ambarella documentation is in the SDK Doxygen document of the SDK package ambarella/packages/nnctrl this folder includes the NNCtrl code used to load the Cavalry binary converted by the CNNGen tool Related Ambarella documentation is in the SDK Doxygen document of the SDK package ambarella/packages/cavalry_mem this folder includes the Cavalry memory code used to allocate memory for Cavalry cases Related Ambarella documentation is in the SDK Doxygen document of the SDK package This folder uses APIs found in the continuous memory allocator CMA function ambarella/unit_test/private/cv_test this folder includes the demo application for testing CVflow® applications Related Ambarella documentation includes Page Getting Started Guide Doxygen document of CNNGen Samples package ambarella/prebuild/library/idsp this folder contains relevant information about the image process library For more details refer to Page Image Library API ambarella/packages/security this folder includes all of the codes related to security functions Related Ambarella documentation includes Ambarella CV5x DG Flexible Linux SDK Security Features ambarella/prebuild/ambarella/library/dewarp this folder includes the prebuild library for dewarp Related Ambarella documentation includes Page Dewarp Library API AMBA Cooper Linux SDK Document Doxygen Feature Sets ambarella/prebuild/library/eis this folder holds the electronic image stabilization EIS prebuild library For more details refer to Page EIS Library API ambarella/drv_modules/private/video/dsp_v6/ambcma this folder contains all of the information about the CMA function For more details refer to Page CMA Driver API Follow the steps below to build the flexible Linux SDK Extract the SDK package cooper_linux_sdk_xxxxxx.tar.xz Configure the Arm® Toolchain under ambarella/ amba-build yocto-build Configure the image under boards/ board_type For example to build the CV5x IP camera firmware use the following commands Refer to Section 4.4 Customize the Build Configuration for details on how to customize the compile configuration Build the firmware If the build system has multi-core CPUs use the option to reduce the building time Users can use the command to get the number of CPU cores For example if using eight-core CPUs use the following command After the building process is complete the image is located at For example the built firmware for CV5x IP camera EVK board is located at And the built firmware for CV7x IP camera EVK board is located at Upgrade the image to the board Refer to Chapter 7 Upgrade the Firmware to the Development Platform To remove the Ambarella add-on libraries drivers or applications follow these steps Go to ambarella/boards/ folder Clean the previous target template Apply the default Ambarella configuration or chip-related configuration files The different configuration files for various chips and the build binary show different clock frequencies and performances Display and modify the kernel configuration according to the product requirement Rebuild the firmware See Section 4.5 Make Target Options for details on compiling specific targets To modify the Linux kernel configuration follow these steps Go to ambarella/boards/ board_type folder Clean up the old target template Apply the default kernel configuration Display and modify the kernel configuration according to the requirements Create the specific kernel configuration Below example is with amba-build method Rebuild the firmware The make commands are as follows Table 4 1 Building Commands Command Content make Lists the supported targets make Compiles a specific target make jN Builds with the multi-core CPUs The following target options are examples of the most commonly used targets Table 4 2 Building Targets Command Target make linux_defconfig Apply the default kernel configuration make linux_menuconfig Display the kernel menuconfig make menuconfig Display the menuconfig make boot Build AMBoot make linux Build the Linux kernel make kernel-module-ambvideo Build the private video drivers make clean kernel-module-ambvideo Clean the private video drivers make clean Delete the directory make distclean Delete all temporary objects in compilation make iav-test Compile the IAV unit test tools such as test_encode make idsp-test Compile the IDSP unit test toos such as test_aaa_service make lwmedia-test Compile the media test tools such as rtsp_server make libimgflow Compile the library libimgflow.so This chapter includes the following sections Section 5.1 Download SDK Package Section 5.2 Build Application Section 5.3 Run Application To enable access to the Cooper SDK tarred files Ambarella provides users with an FTP account and directions for logging in to the Ambarella FTP server using an account password Users should not modify the SDK within the download directory If users must modify the SDK Ambarella recommends making a copy of the SDK and using the copied version instead The Ambarella Cooper Linux SDK evaluation code package includes cooper_linux_evaluation_sdk This SDK is the formal release and contains all reference applications the static dynamic library files and the header files To build the application follow the steps below Extract the formal SDK package cooper_linux_evaluation_sdk__xxxxxx.tar.xz Configure the Arm® Toolchain amba-build Configure the image under boards/ board_type For Cooper Amba build Upload the application and files to board as this package has no Linux kernel or file system The application can be found in ambarella/amba_out/cv5x_ board_name app_name or ambarella/amba_out/cv7x_ board_name app_name For more information about running the application refer to the page Getting Started Guide The SSH and Telnet tools are used to access the build machine and the development platform AmbaUSB is used to upgrade the firmware to the development platform from the PC This chapter includes the following sections Section 6.1 Connect to a Console Window PuTTY Section 6.2 Upgrade Firmware AmbaUSB Section 6.3 Linux Virtual Machine Section 6.4 Network Sharing: CIFS Section sub_code_build_pc_nfs Ambarella recommends using the SSH and Telnet tool PuTTY from to connect to a console window The PuTTY executable and source code is distributed under the Massachusetts Institute of Technology MIT license To connect to a console window use the RS232 serial cable included with the SDK If the cable is not available use a female-to-female RS232 receiver transmitter RX TX crossover cable instead Run putty.exe For a serial connection configure PuTTY as follows and as shown in the following figures Speed baud rate in bits per second 1 1 5 2 0 0 Data Bits 8 Parity None Stop Bits 1 Flow Control None Figure 6-1 PuTTY Serial Configuration 1 From the PuTTY Configuration dialog choose Category Connection Serial and for Serial line to Connect To enter the correct port for example COM1 For Speed Data Bits Parity Stop Bits and Flow Control use the settings above From Category Session in the PuTTY Configuration dialog choose Serial for Connection Type Set Serial Line to COM1 and Speed to 1 1 5 2 0 0 Save the current session for example Amba Serial in Figure 6 2 so that it can be reused Figure 6-2 PuTTY Serial Configuration 2 AmbaUSB is the tool which enables users to upgrade the platform on the Ubuntu Windows PC through the USB The installation programs can be found in the folder Tools/AmbaUSB and include 3 2 bit and 6 4 bit PC versions OS Requirement 18.04 LTS 20.04 LTS Windows 7 3 2 bit 6 4 bit Select the appropriate OS and double-click the program to begin installation Ambarella recommends installing the Linux virtual machine on the Windows PC to enable direct access to the Linux development platform For more details on setting up network sharing between the build machine a Windows PC and the development platform see Section 6.4 Network Sharing: CIFS This section provides instructions to install Ubuntu on Windows using virtualization software such as VirtualBox VirtualBox is freely available and recommended by Ambarella The following instructions use VirtualBox to install Ubuntu on Windows Obtain the VirtualBox and Ubuntu 20.04 LTS disk images VirtualBox downloading page Ubuntu 20.04 LTS Create a virtual machine After launching VirtualBox click New to create a new virtual machine VM Figure 6-3 Create a New VM VM Name and OS Type Name whatever the developer likes Operating System Linux Version Ubuntu Figure 6-4 VM Name and OS Type Memory If the RAM on the machine used for development is less than 1 GB Ambarella recommends using VirtualBox Note that if the RAM exceeds 1 GB only a quarter of RAM will be accessed Figure 6-5 Memory Size Virtual hard disk VHD Select Create a new hard disk click Create choose VHD and then click Next Figure 6-6 Hard Disk File Type Hard disk storage type Both dynamically expanding storage and fixed-size storage can be used Figure 6-7 Storage on Physical Hard Disk Virtual disk location and size Using the default values is acceptable more than 4 0 GB is suggested Figure 6-8 File Location and Size Configure the virtual machine Click Settings Storage Empty under the Controller IDE Next to the Optical Drive click Browse and Choose a disk file Select the Ubuntu.iso downloaded by the user Click OK Figure 6-9 Choose a Disk File If a PC comes equipped with two network interface controllers NICs one connected to the Internet and other to the platform use the Oracle VM VirtualBox Manager select the virtual machine and click Settings Network Within Adapter 1 select Enable Network Adapter Attached to Bridged Adapter Name NIC that is connected to the Internet Figure 6-10 Configuaration of Adapter 1 Within Adapter 2 select Enable Network Adapter Attached to Bridged Adapter Name NIC that is connected to the development board Figure 6-11 Configuaration of Adapter 2 Install Ubuntu on the virtual machine Start the virtual machine After Ubuntu loads select Install Ubuntu Figure 6-12 Install Ubuntu When the installation finishes shut down the virtual machine Click Settings Storage iso Ubuntu disk image Then click the Browse button beside Optical Drive and Remove disk from virtual drive The entry field will clear its contents Figure 6-13 Remove Disk from Virtual Drive Install guest additions VirtualBox Guest Additions improves mouse integration screen resolution options and other features for the guest operation system Click Settings Storage Empty under the Controller IDE Click the browse button beside Optical Drive and Choose a virtual CD DVD file Browse the file for VBoxGuestAdditions.iso this can usually be found under C Files Click OK to continue Figure 6-14 Install VirtualBox Guest Additions Start the virtual machine and change to the directory where the CD-ROM is mounted For example If it is necessary to attach a USB device such as AmbaUSB to the virtual machine ensure that the USB port is USB 2.0 to avoid the following error message as shown below See Section 2.4 Network Topology for details on setting up the network topology for sharing the building machine The following figure illustrates how common internet file systems CIFS accesses Linux folders from the development platform Figure 6-15 CIFS Between Linux To enable access of Linux folders from the development platform perform the following steps On the host Linux PC Install Samba and CIFS on the host Linux PC Create the folder on the host machine that will be shared Modify the Samba configuration file Add to the configuration if the Linux kernel version of the development platform is equal to or later than 3.8 Restart the Samba service on the host PC On the development platform Attach the Linux folder to on the development platform To detach the Linux folder use the following command The following figure illustrates how CIFS accesses Windows folders from the development platform Figure 6-16 CIFS between Windows and Linux To enable access of Windows folders from the development platform perform the following steps On the Windows PC Set up the security options for the network connection Assume that the connection between the PC and the platform is on a public network Go to Control Panel Network and Internet Choose homegroup and sharing options Change advanced Sharing setting… Public Network Discovery Turn on network discovery File and printer sharing Turn on Public folder sharing Developer s choice acceptable to have it on or off Set up the folder you want share on Windows 1 0 Right click the folder chose menu click tab click check box enter a share name The following figure provides an example of the share folder setting Figure 6-17 Share Folder Settings of Windows Host PC On the development platform Here the username is the Windows user name and the password is for the Windows user account To detach the Linux folder use the following command Users can compile the application on the building machine and run it directly on the development platform without burning the binary this benefits the driver and the debug process for the applications The following figure shows an example of the CIFS process Figure 6-18 CIFS Example To enable access of the folders on the building machine from the development platform enter the following commands and perform the following steps On the building workstation On the Linux PC Add the following line all in one line in 4.8.155 cifs username mydomain mybuildusername password mybuildpasswd On the development board run the following command If the above configurations are successful build_share can be accessed from the development platform as shown in the following To remove the shares type the following command The network file system NFS is a protocol that enables users on a client computer to access files over a network If the PC that connects to the development platform includes an NFS server then the platform can access the PC s hard drive through the network This section includes procedures for setting up the system with NFS to enable users to access files over a network The following figure shows an example of the NFS process Figure 6-19 NFS Example For more information on setting up the NFS go to the official web site To set up an NFS server on a linux PC perform the following steps Install the NFS server on the Linux PC Set the NFS server s configuration and start the server To set up an NFS server on a development platform perform the following steps Select NFS utils and rpcbind in the rootfs and select the kernel NFS support For Cooper Amba build Set the directory for NFS sharing in When the platform boots up Because UBIFS cannot support NFS users cannot export UBIFS file-systems via NFS If UBIFS is used the NFS share folder can be set in tmpfs VFAT or other file-systems Set the NFS ports and the rpcbind ports in Check if NFS and NFSD are supported by the kernel nodev nfs is for the NFS client nodev nfsd is for the NFS server Start the NFS server If the system is started with systemd the following commands can be used If the system is started with linuxrc the following commands can be used If the NFS server share folder is already created and is set properly before compiling there is no need to start or restart the NFS server manully when CONFIG_AMBARELLA_NFS_SERVER_AUTO_START is selected in menuconfig Mount to the NFS server share folder from the NFS client platform Temporary Mount After each reboot of the development platform type the following commands is the IP address of the NFS server Permanent Mount When the platform boots up the NFS mounts automatically Note that NFS server on the other platform should be functioning before this platform boots up is the IP address of the Linux PC Share files between the NFS server and the NFS client If the configurations listed in the previous steps are successful the NFS server share folder can be accessed from the development platform The following commands show the sharing processes NFS server NFS client NFS server Remove the client shares using the following command Stop the NFS server If the system is started with systemd the following commands can be used If the system is started with linuxrc the following commands can be used For more details on installing the firmware through AmbaUSB on Linux or Windows refer to Chapter 7 Upgrading the Firmware Cross-compiled open source software OSS libraries prepared by Ambarella are included in the SDK The pre-built libraries can be used directly by Amba build Users can request the RPM and SRPM packages from Ambarella which are separate and not included the standard Linux SDK if cross-compiling the libraries themselves Below are the available source RPM packages Date Source Package Name 2 0 2 1 0 4 1 9 ambarella-oss-src-20210419.tar.bz2 2 0 2 2 0 2 1 5 ambarella-oss-src-srpms-20220215.tar 2 0 2 2 0 7 1 9 ambarella-oss-src-srpms-20220719.tar.xz 2 0 2 3 0 3 0 8 ambarella-oss-src-srpms-20230308.tar.xz Below are the reference steps Ambarella collects the source codes from the community Ambarella does not change any code for the OSS libraries The toolchain version used by Ambarella in the step 2.1 above is linaro-aarch64-2019.11 in order to avoid the potential glibc compatibility issue If users want to re-build the libraries they can choose a newer toolchain the toolchain must be released with the SDK The toolchain version used for buliding the application must be newer than or the same as but not older than the toolchain version used for building OSS Copyright c 2 0 2 4 Ambarella International LP This file and its contents are protected by intellectual property rights including without limitation U.S and/or foreign copyrights This Software is also the confidential and proprietary information of Ambarella International LP and its licensors You may not use reproduce disclose distribute modify or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates In the absence of such an agreement you agree to promptly notify and return this Software to Ambarella International LP THIS SOFTWARE IS PROVIDED AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS COMPUTER FAILURE OR MALFUNCTION OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">ov_deliverables</field>
    <field name="url">de/dc3/ov_deliverables.html</field>
    <field name="keywords"></field>
    <field name="text">SDK Deliverables SDK Deliverables Table 1 1 Private Drivers Module Package Note Image audio video IAV driver Calls coder decoder codec functions GPLv2 Linux modules Cavalry driver Calls vector processor VP functions GPLv2 Linux modules Digital signal processor DSP video input VIN and video output VOUT drivers GPLv2 Linux modules Sensor driver GPLv2 Linux modules Image processing driver GPLv2 Linux modules Table 1 2 Peripheral Drivers Module Package Note GPIO driver GPLv2 Linux modules I2C driver GPLv2 Linux modules GMDA driver GPLv2 Linux modules SPI driver GPLv2 Linux modules RNG driver GPLv2 Linux modules WDT driver GPLv2 Linux modules SPINAND driver GPLv2 Linux modules SPINOR driver GPLv2 Linux modules SDIO driver GPLv2 Linux modules EMMC driver GPLv2 Linux modules ETH driver GPLv2 Linux modules USB driver GPLv2 Linux modules PCIE driver GPLv2 Linux modules UART driver GPLv2 Linux modules Table 1 3 Private Libraries Module Package Library File Image processing AE AWB library libimg_algo_v6.a libimg_dsp_v6_hf.a Image processing flow library libimg_aaa_flow_v6.so Multi-channel Lua parser library libmcl.so Neural network NN flow control library libnnctrl.so NN data processing library libvproc.so NN memory management library libcavalry_mem.so CNNGen pre-processing library libcgpp.so Easy artificial intelligence AI library libeazyai.so Smart video output VOUT framebuffer library libsmartfb.so Lens distortion correction LDC library libdewarp.so Electronic image stabilization EIS library libeis.so Smart rate control SRC library libsmartrc_3_0.so Text insertion library libtextinsert.a Arbitrary blur library libblur.so Audio codec library ALSA libasound.a Table 2 1 Applications Application Description dsplog_cap Capture parse the DSP log test_encode test_stream Test encode and streaming test_dptz Exercise digital pan tilt zoom DPTZ test_privacymask Exercise the privacy mask PM functionality test_overlay test_textinsert Exercise the overlay insert functionality test_blur Exercise the blur insert functionality test_yuvcap Capture RAW YUV ME1 ME0 data test_frame_sync test_qproi Exercise the smart encoding functionality test_aaa_service Run 3 A AE AWB AF processes test_aacdec test_aacenc Encode decode the advanced audio coding AAC audio test_efm Exercise the encode from memory EFM functionality test_ldc Exercise the LDC functionality test_eis Exercise the EIS functionality test_multi_chan Run the multi-channel functionality test_vin_cap Exercise the VIN signal suspend recovery functionality test_manual_feed Exercise the canvas and pyramid manual feed functionality test_netlink Exercise the Netlink functionality test_img_scale Exercise the image scale functionality test_statistics Exercise the stream statistics functionality test_poll Exercise the IAV data poll functionality test_custom_vout Exercise the customized VOUT functionality test_stitch Run the multi-VIN stitching functionality test_smartrc_v3 Run the SmartRC functionality cavalry_load Load CVflow® firmware cavalry_log Capture parse the CVflow log test_nnctrl test_nnctrl_live Exercise the NN flow control functionality test_cavalry_mem Exercise the NN memory management functionality rtsp_server Run the real-time streaming protocol RTSP streaming load_ucode Load the DSP microcode The application can run a variety of networks including the following Object classification Detection for objects face hands and more Face recognition Segmentation Tracking Audio Long short-term memory LSTM Some documents training video clips and tools are released together with the software development kit SDK source code package The following are the deliverable lists for different chip families Users can find more detailed information from the Cooper Linux SDK General Deliverable List PDF documents Below is the Cooper Linux SDK CV5x general deliverables list CNNGen Toolchain Source Codes and User Guide No Type Name Version Date 1 Toolchain Ambarella Toolchain CNNGen version date tar.xz 2.5.5 2023.08 2 Source Codes cvflow cnngen samples version date tar.xz 1.6 2 0 2 3 0 4 0 6 3 Source Codes cvflow cnngen samples version date tar 1.6.2 2 0 2 3 0 7 3 1 4 Videos CNNGen Training Video 1 Introduction.mp4 0.3 5 Videos CNNGen Training Video 2 Porting Workflow.mp4 0.3 6 Videos CNNGen Training Video 3 Porting Workflow.mp4 0.3 7 Videos CNNGen Training Video 4 Deployment.mp4 0.3 8 Videos CNNGen Training Video 5 GSG.mp4 0.3 9 Videos CNNGen Training Video 6 GSG.mp4 0.3 1 0 Doc Ambarella CVflow CNNGen Simple Introduction Customer 0.1 2 0 2 1 0 3 2 4 1 1 Webpage Doc CNNGen User Guide in Doxygen Format 1.6 Software Cooper Linux SDK Source Codes User Guide GCC Toolchain and AmbaUSB No Type Name Version Date 1 Source Codes cooper linux sdk version date tar.xz 1.0 2 0 2 3 0 8 0 1 2 Doc Ambarella Cooper Linux SDK1.0 CV5x Release Notes 0.1 2 0 2 3 0 7 2 0 3 Doc Ambarella Cooper Linux SDK Getting Started Guide 0.1 2 0 2 3 0 7 2 6 4 Doc Ambarella Cooper Linux SDK Code Building 0.2 2 0 2 3 0 8 0 4 5 Doc Ambarella CV5x DG Flexible Linux SDK0.5 CVflow FAQ 0.1 2 0 2 2 0 1 1 4 6 Doc Ambarella DG Cooper Linux SDK CV5x CV7x Security 1.0 2 0 2 3 1 0 1 0 7 Doc Ambarella DG Flexible Linux SDK JTAG Setup 3.1 2 0 2 1 0 9 2 4 8 Doc Ambarella CV5x UG Flexible Linux DRAM Tuning 1.0 2 0 2 3 0 9 1 9 9 Doc Ambarella AN SDK Approved Vendor List 0.7 2 0 2 3 0 7 0 2 1 0 Webpage Doc Linux SDK User Guide in Doxygen Format NA 1 1 ARM Linaro Toolchain Ambarella CortexA76 Toolchain version date tar.xz 12.2.1 2023.04 1 2 Flash Tool Ambarella AmbaUSB zip v5.0.8 Hardware Hardware Programming Manual No Type Name Version 1 Doc AMBARELLA CV5 HW PRM 0.9 2 Doc AMBARELLA CV52 HW PRM 0.8 Below is the Cooper Linux SDK CV7x general deliverables list CNNGen Toolchain Source Codes and User Guide No Type Name Version Date 1 Toolchain Ambarella Toolchain CNNGen version date tar.xz 3.5.5 2023.08 2 Source Codes cvflow cnngen samples version date tar.xz 1.6 2 0 2 3 0 4 0 6 3 Source Codes cvflow cnngen samples version date tar 1.6.2 2 0 2 3 0 7 3 1 4 Videos CNNGen Training Video 1 Introduction.mp4 0.3 5 Videos CNNGen Training Video 2 Porting Workflow.mp4 0.3 6 Videos CNNGen Training Video 3 Porting Workflow.mp4 0.3 7 Videos CNNGen Training Video 4 Deployment.mp4 0.3 8 Videos CNNGen Training Video 5 GSG.mp4 0.3 9 Videos CNNGen Training Video 6 GSG.mp4 0.3 1 0 Doc Ambarella CVflow CNNGen Simple Introduction Customer 0.1 2 0 2 1 0 3 2 4 1 1 Webpage Doc CNNGen User Guide in Doxygen Format 1.6 Software Cooper Linux SDK Source Codes User Guide GCC Toolchain and AmbaUSB No Type Name Version Date 1 Source Codes cooper linux sdk version date tar.xz 1.0 2 0 2 3 0 8 0 1 2 Doc Ambarella Cooper Linux SDK1.0 CV72 Release Notes 0.1 2 0 2 3 0 7 2 0 3 Doc Ambarella Cooper Linux SDK Getting Started Guide 0.1 2 0 2 3 0 7 2 6 4 Doc Ambarella Cooper Linux SDK Code Building 0.2 2 0 2 3 0 8 0 4 5 Doc Ambarella DG Cooper Linux SDK CV5x CV7x Security 1.0 2 0 2 3 1 0 1 0 6 Doc Ambarella DG Flexible Linux SDK JTAG Setup 3.1 2 0 2 1 0 9 2 4 7 Doc Ambarella CV7x UG Flexible Linux DRAM Tuning 1.0 2 0 2 3 0 9 1 9 8 Doc Ambarella AN SDK Approved Vendor List 0.7 2 0 2 3 0 7 0 2 9 Webpage Doc Linux SDK User Guide in Doxygen Format NA 1 0 ARM Linaro Toolchain Ambarella CortexA76 Toolchain version date tar.xz 12.2.1 2023.04 1 1 Flash Tool Ambarella AmbaUSB zip v5.0.8 Hardware Hardware Programming Manual No Type Name Version 1 Doc AMBARELLA CV72 HW PRM 0.4 After the SDK is released hotfixes are used to fix bugs or support new features Ambarella maintains two threads of hotfixes for every SDK version generic hotfix and customer specific hotfix Ambarella will release generic hotfixes to all customers on standard SDK when there are bugs or features that affect all customers When a bug or feature affects certain use cases for some customers a specific hotfix is released to those customers The hotfix content is source code files that need to be updated rather than the diff of the changes A hotfix name at least contains SDK version hotfix number and create date Take cooper_linux_sdk_1.0.0.5_CV72_Update_codec _20231102.tar.bz2 for example is the SDK version The after SDK version is the hotfix number which means there were 4 hotfixes before this version is a brief description about this hotfix is the date when the hotfix is created Generic and customer specific hotfixes are maintained in individual thread so the hotfix numbers grow separately If a customer sepecific hotfix is dated later than the generic hotfix it means that the customer specific hotfix is based on the generic hotfix When Ambarella prepares a hotfix for a specific customer Ambarella assumes the customer has applied both generic and customer specific hotfixes so the code base is clean SDK code plus generic and customer specific hotfixes for that customer When creating a generic hotfix the code base is clean SDK code plus previous generic hotfixes User can refer to readme.txt in hotfix tarball file to apply the hotfix The apply.sh script simply does file replacement it cannot detect the conflict in code Usually executing the apply.sh script is enough Given the fact that Ambarella creates hotfixes based on previous generic and customer specific hotfixes customers should ensure that previous hotfixes are all applied before applying a new one Since generic and customer specific hotfixes are maintained in different threads they have different code bases There might be a conflict when merging them into the customer code Contact Ambarella support team if there is a conflict After applying a hotfix please always do make distclean It is important when files are removed or changed to another folder after applying a hotfix because the change is not synchronized to the compile output folder of ambarella/out/ If make distclean is not executed customers may see the unexpected compiling errors or changes that do not take effect</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">market_segments</field>
    <field name="url">df/d55/market_segments.html</field>
    <field name="keywords"></field>
    <field name="text">Market Segments Market Segments This page introduces some typical product features of different market segments like IP security cameras consumer security cameras video conferencing cameras robotics cameras automotive cameras and more Typical product features for IP camera market are as follows Table 1 1 IPCam Features Video Features Description Video Input Configures video input including resolution fps mode interface and more Video Output Configures video output including resolution fps mode device and more Canvas Configures canvas including resolution source type and fps Pyramid Generates multi-layer YUV frames for CV analysis Stream Configures stream including resolution source format fps and more HDR Configures HDR-related options H 264/H 265 Codec Configures Codec-related options DSP Monitor Service DSP monitor service Encode Mode Selects the proper encode mode and IDSP pipeline for different products Channel IDSP Rotation Flip Corridor scenarios Only supported by Encode from Memory Encodes bit stream from prepared YUV420 data in memory Encode from Raw Feeds RAW Bayer or YUV data from memory into IDSP pipeline then encode Lens Distortion Correction Lens geometry distortion correction Multi-Region Warp Fisheye multi-region dewarp product Arbitrary Image Scaler Allows the Arm® user app to perform up down-scaling with the hardware scaler Stitch Multi-channel stitching product Sensor Calibration Sensor calibration needed by multi-channel stitching SmartRC-v3 Smart Rate Control v3 with CV analysis enabled EIS Electronic image stabilization Multi-Channel Multi-VIN and multi-channel configuration Vsync Loss VIN signal loss detection and recovery DRAM Optimization DRAM capacity and bandwidth Power Management Power management and optimization methods The supported sensor list is as follows Sensors for CV5x IP Camera Sensors for CV7x IP Camera There are many different product types of IP Cameras Here are some examples for the most common ones Table 1 2 IPCam Products Products Description Single channel camera Regular single channel camera for different resolutions from 2 MP to 3 2 MP Fisheye dewarp camera Fisheye lens camera with multiple regions of dewarp views Dual channel stereo camera Two channels of stereo camera design Multi-directional camera Multi-channel design with the same type sensors for different directions Different channels can be configured with different 3 A parameters Multi-channel stitch camera Multi-channel stitching design with the same type sensors for larger stitched FoV All channels must be configured with similar 3 A parameters Typical product features for robotics camera market are as follows Table 2 1 Robotics Features Video Features Description Video Input Configures video input including resolution fps mode interface and more Video Output Configures video output including resolution fps mode device and more Canvas Configures canvas including resolution source type and fps Pyramid Generates multi-layer YUV frames for CV analysis Stream Configures stream including resolution source format fps and more H 264/H 265 Codec Configures Codec-related options DSP Monitor Service DSP monitor service Encode Mode 0 Recommended for Robotics products Lens Distortion Correction Lens rectify and geometry distortion correction The supported sensor list is as follows Sensors for CV72 stereo There are many types of camera for robotics usage Here are some examples for the most common ones Table 2 2 Robotics Products Products Description Stereo camera Two channels stereo camera design RGB-D camera fusion camera design The depth sensor can be either ToF or structure light sensors Typical product features for the video conferencing camera market are as follows Table 3 1 Video Conference Features Video Features Description Video Input Configures video input including resolution fps mode interface and more Video Output Configures video output including resolution fps mode device and more Canvas Configures canvas including resolution source type and fps Pyramid Generates multi-layer YUV frames for CV analysis Stream Configures stream including resolution source format fps and more H 264/H 265 Codec Configures Codec-related options DSP Monitor Service DSP monitor service Encode Mode 0 Recommended to meet the shortest latency from VIN to VOUT Channel IDSP Rotation Flip For corridor scenarios Only supported by Encode from Memory Encodes bit stream from prepared YUV420 data in memory Encode from Raw Feeds RAW Bayer or YUV data from memory into IDSP pipeline then encode Lens Distortion Correction Lens geometry distortion correction Multi-Region Warp Fisheye multi-region dewarp product Arbitrary Image Scaler Allows Arm® user app to perform up down-scaling with the hardware scaler Stitch Multi-channel stitching product Sensor Calibration Sensor calibration needed by multi-channel stitching VIN-VOUT low latency Keeps the shortest latency from VIN capture done to VOUT display done VIN-VOUT precise sync Synchronize VIN and VOUT from the beginning and adjust VIN frame rate on the fly to keep the precise sync VOUT underflow prevention Prevents VOUT from underflow cases which could potentially cause VOUT flickering UVAC Describes the guidelines for UVAC features The supported sensor list is as follows Sensors for video conference There are many types of video conferencing cameras Here are some examples for the most common ones Table 3 2 Video Conference Products Products Description Single channel camera Video conferencing camera design for 1 0 8 0 p60 4 Kp30 4 Kp60 and more Multi-channel camera Multiple channels video conferencing camera design It includes two channels stitching for 1 8 0 panorama view and four channels stitching for 3 6 0 panorama view Typical product features for the automotive market is as follows Table 4 1 Automotive Features Video Features Description Video Input Configures video input including resolution fps mode interface and more Video Output Configures video output including resolution fps mode device and more Canvas Configures canvas including resolution source type and fps Pyramid Generates multi-layer YUV frames for CV analysis Stream Configures stream including resolution source format fps and more DSP Monitor Service DSP monitor service Encode Mode 0 Recommended for all automotive products Lens Distortion Correction Lens rectify and distortion correction VIN-VOUT low latency e-mirror products and more Multi-Channel Multi-VIN and multi-channel configuration Vsync Loss VIN signal loss detection and recovery Sensors with SERDES bridge Installs multiple sensors connected through one or more SERDES The supported sensor list is as follows Sensors for ADAS There are many product types of automotive usage Here are some examples for the most common ones Table 4 2 Automotive Products Products Description ADAS camera Front advanced driver assistance systems ADAS camera design Typical product features for machine vision market is as follows Table 5 1 Machine Vision Features Video Features Description Video Input Configures video input including resolution fps mode interface and more Video Output Configures video output including resolution fps mode device and more Canvas Configures canvas including resolution source type and fps Pyramid Generates multi-layer YUV frames for CV analysis Stream Configures stream including resolution source format fps and more DSP Monitor Service DSP monitor service Lens Distortion Correction Lens rectify and distortion correction Encode Mode 0 Recommended to meet the shortest latency from VIN to VOUT VIN-VOUT low latency e-mirror products and more Encode from Memory Encodes bit stream from prepared YUV420 data in memory Encode from Raw Feeds RAW Bayer or YUV data from memory into IDSP pipeline then encode The supported sensor list is as follows Sensors for machine vision</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">ov_new_board_bringup_guide</field>
    <field name="url">df/d78/ov_new_board_bringup_guide.html</field>
    <field name="keywords"></field>
    <field name="text">New Board Bring-Up Guide New Board Bring-Up Guide This document guides users through bringing up a new board on the Ambarella platform This chapter contains the following section Section 1.1 Key Updates Table 1 1 Key Updates Version Date Modification 1.0 2 0 2 2 1 0 0 9 Initial Version 1.1 2 0 2 3 0 9 1 4 Move to common part and add CV5x support 1.2 2 0 2 4 0 1 1 2 Updated Section 3 3 3 GPIO configuration To aid customers in bringing up new boards for the start of their projects Ambarella provides the following guide to prepare configure and test new boards using the Ambarella platform This chapter describes the general steps used during system bring-up and consists of the following sections Section 3.1 Bring-Up Preparation Section 3.2 Download Firmware Through AmbaUSB Section 3.3 Configuration Instructions for AMBoot Section 3.4 Kernel Configuration Instructions Upon the arrival of a new board the following steps must be performed Verify that power-up timing meets the required specifications Check the power of all hardware modules Verify that the power-on configuration POC settings are as expected in the design This step is critical because the POC settings decide the boot options such as boot media NAND embedded multi-media controller eMMC SPI or SPI-NOR boot method normal or secure boot and more For more details refer to the POC table in the hardware schematic diagram Check the double data rate DDR voltage This step is important because the firmware must first be moved into memory If the new board is empty the firmware must first be downloaded into dynamic random access memory DRAM using the tool AmbaUSB otherwise the firmware will be read from boot media and translated to memory Verify that the USB is functioning as the firmware must be downloaded to the board via USB Contact the Ambarella hardware support team for assitance Before bring-up users must install the AmbaUSB tool and understand how it is used This tool is released through Ambarella’s portal release order PRO system Users can find the installation package in PRO The following steps help users download the firmware onto a new board Pull-high POC 1 0 of the board The system enters into force USB boot mode If the users’s operating system OS is Windows open the device manager and check if the Ambarella evaluation board devices have been detected If the Ambarella evaluation board devices were not previously installed they should be installed automatically when the board powers up with the USB connected Figure 3-1 Ambarella Evaluation Board Device Launch AmbaUSB and choose the correct chip marked as red box 1 in Figure 3-2 for CV22 and Figure 3-3 for CV5 Here the CV22 Walnut and CV5 Timn evaluation kit EVK boards are used as examples Then the CV22 CV5 USB device is detected by AmbaUSB marked in red box 2 in Figure 3-2 and Figure 3-3 Figure 3-2 AmbaUSB with Force USB Mode for CV22 Walnut Figure 3-3 AmbaUSB with Force USB Mode for CV5 Timn Use AmbaUSB to verify if the POC settings are correct If the POC settings are not correctly set they must be adjusted Figure 3-4 Read Registers Using AmbaUSB in CV22 Walnut When the CV22 Walnut board enters into force USB boot mode users can click the magic icon marked as a red 1 in Figure 3-4 Then AmbaUSB will go to the “AMBoot tool wizard” page After choosing the “Read Register” checkbox and specifying the address and length of the POC register marked as red boxes 2 3 and 4 respectively in Figure 3-4 AmbaUSB can read the value of the POC register shown in Figure 3-5 by clicking the Ok button Figure 3-5 POC Register Value Displayed in AmbaUSB on CV22 Walnut On the CV5x platform for the sake of security consideration AmbaUSB must load a usbstrap file end with ust to initialize the board first Then it can execute operations such as reading registers reading writing memory and more Figure 3-6 Loading UST Files in AmbaUSB Figure 3-6 Load UST File in AmbaUSB on CV5 Timn AmbaUSB has some ust files and users can select them from the installing directory cv5_lpddr5_540MHz.ust is used here When a correct ust file has been loaded successfully AmbaUSB will check and execute it Then it will enter into UST mode Refer to Figure 3-7 Figure 3-7 UST Mode in AmbaUSB on CV5 Timn Reading POC registers in UST mode is similar to the operations used on the CV22 Walnut board the only difference is the address of the POC register On the CV5 platform the value is 0 x20ed080034 4 0 bits not 3 2 bits Figure 3-8 shows the reading POC register operations on CV5 Timn and Figure 3-9 displays the result Figure 3-8 Read POC Registers on CV5 Timn Figure 3-9 Display POC Register Values in AmbaUSB on CV5 Timn AmbaUSB can test memory access operations and check if there are DRAM hardware issues Figure 3-10 Memory Tests in AmbaUSB on CV22 Walnut As shown in the figure above when the CV22 Walnut board enters into force USB boot mode users can click the magic icon marked as a red 1 in Figure 3-10 Then AmbaUSB will go to the “AMBoot tool wizard” page Users can test memory in this page Select the memory test in the top-left corner Input the accessing address correctly such as 0 x100000 Input the data to be written into the memory such as 0 x55aa55aa Input the data length When all parameters for memory testing are ready users can click the Ok button to enable AmbaUSB to perform memory tests by attempting to read the data that has been written into memory If data read from the memory is the same as what users input in the “AMBoot tool wizard” see Figure 3-11 there is no issue regarding memory read write Otherwise users can refer to FAQ 2 to find the root cause Figure 3-11 Memory Test Results in AmbaUSB on CV22 Walnut On the CV5x platform AmbaUSB disables the operation and the user must split the into two steps and The following figures demonstrate the process of writing and reading memory Figure 3-11 Write Memory Operation in AmbaUSB On CV5 Timn Figure 3-12 Result of the Writing Memory Operation in AmbaUSB On CV5 Timn Figure 3-13 Read Memory Operation in AmbaUSB On CV5 Timn Figure 3-14 Result of the Reading Memory Operation in AmbaUSB On CV5 Timn Users can manually load the Ambarella bootloader BLD to enter into the BLD’s command line mode The following figure and steps provide instructions for the CV22 Walnut board similar process on CV5 Timn Figure 3-15 Load Ambarella Bootloader Manually in AmbaUSB Choose the board configuration marked as red box 1 in Figure 3-15 for CV22 Walnut LINUX.CV22.LPDDR4.NAND is selected Click the magic icon marked as red box 2 in Figure 3-15 Then AmbaUSB will go to the “AMBoot tool wizard” page Choose the Ambarella bootloader marked as red box 3 in Figure 3-15 When the board firmware is compiled the Ambarella bootloader bld_release.elf will be generated in the directory ambarella/out/board_name/amboot In order for AmbaUSB to successfully load the BLD Ambarella recommends disabling the Arm® TrustZone® feature in the configuration file at the bring-up stage Click the Ok button then press the Enter key in the serial port When this bootloader is loaded completely by AmbaUSB it will be executed in memory and the command line mode appears in the serial port as shown below Figure 3-16 Ambarella Bootloader Command Line Mode Many commands in the BLD can be used for debugging purposes The “help” command shows all applications supported in the Ambarella bootloader Figure 3-17 Ambarella Bootloader Help Command After successfully completing the previous steps users can now burn the firmware onto the board Choose the board configuration marked as red box 1 in Figure 3-18 For CV22 Walnut LINUX.CV22.LPDDR4.NAND is selected Specify the firmware s location marked as red box 2 in Figure 3-18 Download the firmware onto the board marked as red box 3 in Figure 3-18 Figure 3-18 Download Firmware in AmbaUSB on CV22 Walnut To build and burn the firmware users can take reference from SDK Code Building and Getting Started Guide Per different hardware designs the bootloader and kernel must be configured accordingly when building a firmware for users’ boards This section introduces how to prepare AMBoot the bootloader of Ambarella systems on chip SoCs The two parts of the Ambarella SoC bootloader are the bootstrapper BST and the bootloader BLD BST initializes DDR and loads the BLD from storage media to DRAM BLD loads and runs the kernel Additionally the Ambarella BLD provides many applications when users enter into BLD command line mode Users can enter into this command line mode by pressing the “Enter” key in the serial port while the BLD is loading Before compiling the software development kit SDK an ini file must be provided for the BST All parameters configured in this ini file will be parsed and passed to the BST module The tool bstiniparser is located in ambarella/amboot/src/bst/tools SDK 3.0 and ambarella/boot/amboot/src/bst/tools Cooper SDK This tool analyzes the ini file and translates it into a C header file Here the cv22aq_walnut_76_lpddr4.ini of the CV22 Walnut EVK board is used as an example CV5 is similar Figure 3-19 DDR Parameters in cv22aq_walnut_76_lpdd4 ini As there are too many parameters select the last macro DRAM_MODE_REG_VAL to display where it is used in the BLD Before compiling Ambarella SDK users can choose ini file through “make menuconfig” in the SDK The DRAM size also must be adjusted by changing MACRO “DRAM_SIZE” which is defined in ambarella/boards/cv22_walnut/bsp/bsp.h The default value of this macro is 0 x80000000 2 GB Users must set it according to the real DDR capacity of the board The definition of each partition flash size is located in ambarella/boards/cv22_walnut/bsp/bsp.h Users can modify the sizes according to the actual capacity of storage media For more information about flash partitions users can refer to File System and NAND There are two ways to configure general purpose input output GPIO The first way is the legacy method where the configurations are maintained in the bsp.h file The second way is a new method where the configurations are maintained in the device trees DTS The user can use configuration When this configuration is enabled the new method will be used When disabled the legacy method is used For the legacy method the user operation process is as follows Based on the hardware design generate the complete GPIO configurations There is a dedicated Excel tool from Ambarella Capture the GPIO configurations into the bsp.h under the board folder Update the AMBoot or kernel modules to use these GPIOs when necessary Generate a firmware and apply the configurations The working flow for the legacy method is as follows AMBoot loads all the configurations in bsp.h and sets to the hardware AMBoot and Linux uses these initialized GPIOs for different purposes The potential issues for the legacy method Users are required to generate the entire GPIO configuration map It is easy to make mistakes for GPIO settings These incorrect GPIO settings can cause potential hardware failures or power increases Sometimes users directly copy GPIO configurations from the Ambarella evaluation kit EVK that do not match their board Locating and fixing these hardware or power-related issues will take a long time For the legacy method the CV22 GPIO settings are located in ambarella/boards/cv22_walnut/bsp/bsp.h Ambarella provides an Excel tool to aid hardware engineers in configuring the GPIOs column marked as red box 2 of the hardware page in Figure 3-20 Figure 3-20 GPIO Mux Table If users encounter any issues while obtaining this tool contact the Ambarella hardware support team for assitance After the application of each GPIO is configured properly contents of the remaining four pages control pull IOMUX and GPIO_DS will be generated automatically Then users can update these configurations into ambarella/boards/cv22_walnut/bsp/bsp.h Figure 3-21 GPIO Configuration For the new method the user operation process is as follows Configure the necessary GPIO configurations into the device tree Update the AMBoot or kernel modules to use these GPIOs when necessary For those unused GPIOs it would be reserved as GPIO input and the configurations from device tree will be ignored The working flow for the new method is as follows AMBoot reads the used GPIO settings from the device tree initializes the hardware and use it Normally AMBoot only reads For those GPIO that are not configured in the device tree they are initialized as and pulled to by default AMBoot and Linux uses these initialized GPIOs for different purposes Improvements for the new method are as follows Users are only required to specify the necessary GPIO settings in the device tree This avoids potential issues if the complete GPIO settings are incorrectly configured For these unused GPIOs initializing to avoids unnecessary power consumptions Normally AMBoot will only initialize NAND SPIOR eMMC related pins according to the boot media So these relevant GPIOs can be used in AMBoot For example if the boot media is eMMC then AMBoot loads and uses eMMC-related GPIO configurations Compared with the legacy method the new method only requires to ensure that the used GPIOs are properly configured in the device tree The following is an example of I2S configurations in the device tree So in AMBoot the I2S pins will be configured as I2S mode when the code below is called And related GPIOs will be parsed and configured For Linux the I2S pins will be configured as I2S mode when status But when status the I2S pins then will not be configured as I2S mode and related GPIOs will be parsed and configured The main function of configuring the kernel is to modify DTS This can be divided into two parts common configuration of the SoC and specific configuration for the user’s board This example uses the CV22 Walnut EVK board Common configuration the corresponding DTS file is located in ambarella/kernel/linux- dtsi For information regarding how to configure each node users can refer to the kernel document ambarella/kernel/linux- txt Board-specific configuration the corresponding DTS file is located in ambarella/boards/cv22_walnut/bsp/cv22_walnut.dts Further Peripheral provides instructions for usage of peripheral hardware based on the Ambarella platform AMBARELLA_CV2x_HW_PRM.pdf is the programming reference manual which provides a detailed description pf each module’s registers Contact the ambarella hardware support team to obtain this document Check if POC 1 0 is pulled high To enter force USB mode POC 1 0 must be pulled high Verify that the power sequence and power supply for each hardware are normal Check if POC 6 is pulled low When POC 6 is pulled low the secure boot feature will be enabled and the board cannot enter into force USB mode Check if POC 3 1 are configured The configuration of POC 3 1 decides the clocks of main components IDSP VDSP DRAM VISION and CORTEX and system cannot boot up when POC 3 1 is not configured correctly Check if there are issues in the USB circuit design The checks above should remedy the issue For more information on setting POCs users can refer to Ambarella_CV_POC_UG.pdf Contact the Ambarella hardware support team to obtain this document Verify that DDR power is normal Verify that the selection of the developing board marked in a red box in the figure below is correct Verify that the HDMI_REXT pin connects tightly This pin cannot dangle because the chip current internal phase-locked loop PLL is obtained from this pin Figure 4-1 Board Selection in AmbaUSB If the checks above do not resolve the issue the problem may be related to the default DDR parameters configured in the AmbaUSB tool The parameters may not be suitable contact the Ambarella support team for help Copyright c 2 0 2 4 Ambarella International LP This file and its contents are protected by intellectual property rights including without limitation U.S and/or foreign copyrights This Software is also the confidential and proprietary information of Ambarella International LP and its licensors You may not use reproduce disclose distribute modify or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates In the absence of such an agreement you agree to promptly notify and return this Software to Ambarella International LP THIS SOFTWARE IS PROVIDED AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS COMPUTER FAILURE OR MALFUNCTION OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">overview_proj</field>
    <field name="url">df/df3/overview_proj.html</field>
    <field name="keywords"></field>
    <field name="text">System Overview System Overview The Ambarella CV5x CV7x devices are implemented using system on chip SoC architecture The platform is driven by a 6 4 bit Linux OS that runs on the Arm® Dual-Cortex® A76 core of the CV5x CV7x processors The digital signal processor DSP core empowers imaging signal processing and the codecs The CVflow® engine on the CV5x CV7x SoCs supports hardware acceleration for neural network implementation Peripheral controllers such as I2C Ethernet and SDIO support the cooperation with external devices Figure 1-1 CV5x Hardware Block Diagram Figure 1-2 CV7x Hardware Block Diagram CV5x CV5 and CV52 includes up to 4 independent VINs which can be extended to 1 4 VINs through MIPI virtual channels CV7x CV72 includes up to 3 independent VINs which can be extended to 1 0 VINs through MIPI virtual channels The Cooper Linux SDK is a universal SDK for multiple markets including professional and consumer IP cameras robotics cameras video conferencing cameras machine vision cameras and more Additionally the Cooper Linux SDK software is implemented with DSP firmware drivers and middleware as well as the CVflow firmware drivers and library The CV5x CV7x series share the same software framework as shown in Figure 2 1 The following refers to Figure 2 1 and describes Ambarella s responsibilies related to the CV series software framework The files outside the GREEN outline are released in binary format only Ambarella is fully responsible for these binary files and will provide solutions and fixes to customers should issues arise Select files inside the PURPLE outline are released in binary format and others are released as source code Ambarella is fully responsible for both the binary and source code files and will provide support to customers should issues arise For the Linux kernel code the Cooper Linux SDK selects one of the kernel LTS versions to maintain and support Ambarella is responsible for the private drivers for IAV DSP IMGPROC and HWTIMER and the public driver for the chip-related parts Customers are responsible for maintaining the Linux kernel itself and other external device drivers for WiFi the audio codec etc For open source software OSS modules Ambarella provides the pre-build binary files inside the Cooper Linux SDK but does not provide support for issues related to the OSS modules Figure 2-1 CV Series Software Framework The Cooper Linux SDK includes three categories of content and support as shown below Figure 3-1 Cooper SDK Support Scope Below is the list of the license info and support scope for most of the deliverable software modules including drivers libraries demos and test applications Module License Support Category AMBoot Proprietary Category A AMRTOS Proprietary Category A Uboot GPLv2 Category C Linux Kernel GPLv2 Category C Platform drivers GPLv2 Category A IAV driver GPLv2 Category A Cavalry driver GPLv2 Category A DSP VIN and VOUT drivers GPLv2 Category A Sensor drivers GPLv2 Category A Image processing driver GPLv2 Category A Image processing AE AWB library libimg_algo.so Proprietary Category A Image processing flow library libimg_aaa_flow.so Proprietary Category A Multi-channel Lua parser library libmcl.so Proprietary Category A Neural network flow control library libnnctrl.so Apache-v2 Category A Neural network data processing library libvproc.so Apache-v2 Category A Neural network memory management library libcavalry_mem.so Apache-v2 Category A CNNGen pre-processing library libcgpp.so Proprietary Category A Base component of easy artificial intelligence AI library Proprietary Category A Lens distortion correction library libdewarp.so Proprietary Category A Electronic image stabilization library libeis.so Proprietary Category A Smart rate control SRC library libsmartrc.so Proprietary Category A Text insertion library libtextinsert.a Proprietary Category A Arbitrary blur library libblur.so Proprietary Category A Base components of Oryx Proprietary Category A Unit test app under unit_test/private Proprietary Category B Sample code of EazyAI library Proprietary Category B Sample code of Oryx Proprietary Category B Amba-GST-Plugin Proprietary Category B ALSA library LGPLv2+ Category C OSS libraries By module Category C OSS libraries CVE fixes By module Category B Gstreamer LGPLv2+ Category C NNstreamer LGPLv2 Category C OpenCV BSD Category C</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">index</field>
    <field name="url">index.html</field>
    <field name="keywords"></field>
    <field name="text">Cooper Linux SDK Overview The Cooper Amba Linux SDK Overview s outline is below System Overview Document Reading Guide Market Segments Getting Started Guide SDK Deliverables SDK Code Building Sensor Bring-Up Guide New Board Bring-Up Guide Glossary and Abbreviations The Cooper Hardware Documents will be organized as below HW Modules Board CV5 Titanium Board CV52 Co Cr Board CV72 Ga Ge Board CV72 Xiezhi Board CV3 Dk_mini The Cooper Amyoc Documents will be organized as below Introduction Target Build Guidance ROS2 Image by Yocto Build Environment Parameters Makefile Templates Generate Dependency Chain OSS Source Code Build by Amba Build Yocto Recipe Yocto FAQ The Cooper Driver Documents will be organized as below Cavalry V3 CV72 Driver API CMA Driver API IAV Driver API Sensor Parameters Tuning Table Sensor SERDES Driver Installation The Cooper Library Documents will be organized as below Amba GStreamer Solution Ambarella Simulation Framework Library API Cavalry_Mem Library API Cavalry Opt Layers Library API CGPP Library API Data Process Library API Depth Sensing Framework Dewarp Library API EazyAI Library API EIS Library API Image Flow Library API Image Library API NNCtrl Library API Sensor Calibration Library API SmartFB Library API SmartRC V3 Library API Stitch Library API VPROC Library API VFUNC Library API Video Sharing Service Library API PrivacyMask Library API Vsrc Guard Library API The Cooper Video Documents will be organized as below BASIC Video Input BASIC Video Ouput BASIC Raw BASIC Channel BASIC Source Buffer BASIC Pyramid BASIC Canvas BASIC Stream BASIC H.264 H.265 Codec BASIC GOP BASIC On-the-Fly Settings BASIC Privacy Mask BASIC Blur on Streams BASIC Overlay on Streams BASIC Playback BASIC Duplex BASIC Data Dumping BASIC Frame Rate BASIC HDR ADVANCED Encode Mode ADVANCED Configure with Lua Script ADVANCED Multi-VIN Multi-Channel ADVANCED Multi-Pass ADVANCED Lens Distortion Correction ADVANCED Multi-Region Dewarp ADVANCED Vsync Loss ADVANCED Arbitrary Image Scaler ADVANCED Encode from Memory ADVANCED Encode from RAW ADVANCED Pipeline Latency ADVANCED Poll Interface ADVANCED Customized Features ADVANCED Bypass IDSP for YUV Input IQ Lite NN OTHER Debug Option OTHER Miscellaneous OTHER FAQ OTHER DSP Monitor Service OTHER ucode for DSP The Cooper Security Documents will be organized as below Overview System Integrity Protection System Reinforcement Data Storage Protection Data Transfer Protection Intellectual Property Protection User Privacy Protection Secure Hardware Key Management Crypto Performance Design Guide Validation Guide Migration Guide The Cooper System Documents will be organized as below Migration Guide From CV2x Migration Guide from CV5x Legacy SDK BASE AMBoot BASE Kernel BASE Rootfs BASE CM3 BASE Multi-Clusters BASE Lychee OS DESIGN Boot Upgrade DESIGN Timer PTS DESIGN Fast Boot DESIGN Multiple Sensors Calibration DESIGN Docker Usage Guide DESIGN Porting Ubuntu System DESIGN Memory Layout Optimization OPTIMIZATION Power Management TOOL CooperHome DEBUG DRAM Bandwidth Statistics DEBUG Tools DEBUG FAQ The Cooper Peripherals Documents will be organized as below Audio File System NAND EMMC Debugfs USB SD Card WiFi Bluetooth SPI I2C PCI Express Ethernet PTP Miscellaneous JTAG Temperature The Cooper Applications Documents will be organized as below Access Control Camera Beetle Demo AIbox Demo Multi-View Video Conference Multi-VIN Binding Single Channel The Cooper Doxygen Style Guide Documents will be organized as below Doxygen Style Guide</field>
  </doc>
</add>
