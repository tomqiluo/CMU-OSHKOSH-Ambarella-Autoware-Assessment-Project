<?xml version="1.0" encoding="UTF-8"?>
<add>
  <doc>
    <field name="type">page</field>
    <field name="name">page_sys_cooperhome</field>
    <field name="url">d0/d78/page_sys_cooperhome.html</field>
    <field name="keywords"></field>
    <field name="text">TOOL CooperHome TOOL CooperHome Version Updated Date Modification 0.1.0 Alpha 2 0 2 3 0 8 2 4 Initial Version 0.1.0 Beta 2 0 2 3 0 9 2 8 1 Added Section 4.4 Image Quality 2 Added Section 4.7 About 0.1.0 2 0 2 3 1 0 2 3 Added Section 4.5 Geometric Distortion Correction 0.2.0 Alpha 2 0 2 3 1 2 2 0 1 Added Section 4.2 Startup 2 Added Section 4.6 Video Capture 0.2.1 Alpha 2 0 2 4 0 1 1 2 Updated Section 4.3.6 CVflow Profile 0.2.2 2 0 2 4 0 1 2 4 1 Added Section 2.4 Install CooperHome on Lychee 2 Added Section 3.2 Run CooperHome on Lychee CooperHome is a light-weight web application designed for the Ambarella Cooper software development kit SDK that runs on Ambarella s CV2x CV5x CV7x and CV3x systems on chip SoCs to bring webpage access to the SoCs Thus users can visually and graphically check and configure Ambarella SoCs on any client device such as PCs cellphones tablets and more through the web browser With the CooperHome features users are able to see a summary of system information monitor device status profile use case performance configure tasks on CPU digital signal processor DSP CVflowÂ® cores capture output data and more CooperHome is targeted to help new users to get started with the Ambarella SoC and become familiar with the Ambarella system CooperHome also aims to help experienced users accelerate their evaluation and development speeds with the Ambarella Cooper SDK CooperHome application source code is located CooperHome external plugins are placed under CooperHome is published and released as full source code in the Cooper SDK and is developed under the Ambarella Three-clause Proprietary License CooperHome only can be used as sample code for user reference Customers CANNOT directly copy and use this piece of source code for their final products Figure 1-1 CooperHome Main Page As CooperHome needs Python module which is not supported by Amba-build firmware there are two ways for users to build or install CooperHome application into the final image Use Yocto build to generate CooperHome into the firmware Use the prepared installation package and install it into the firmware Follow the below instructions to enable CooperHome in the Yocto-build firmware Follow the below instructions to create the CooperHome installation package The installation package is generated under the output folder For example 0-r0/build/cooper_home_installer.tar Follow the below instructions to install the CooperHome application on any existing Amba-build Yocto-build firmware If user installs the CooperHome into system default path ensure that root storage has more than 2 5 MB free space before installation Use df to check the size of free space It is recommended to install CooperHome on SD card or network driver because the application will not be erased by device reboot and or frimware re-program Also it does not rely on the storage size of rootfs It extracts and installs the CooperHome executable files and runtime environment to the target device Install CooperHome to root and Install CooperHome to external storage for example SD card or network drive Install CooperHome to tmp folder Follow the below instructions to install the CooperHome application on Lychee Follow the below instructions to update the CooperHome application to the latest version Follow the below instructions to run CooperHome server on the board and view CooperHome pages on web browser Run the CooperHome application on the board Open the CooperHome webpage in a PC browser with the EVK board IP address such as 10.0.0.2 and port-5000 Follow the below instructions to run CooperHome application on Lychee Open the Start Menu Search for Cooper Home application Click Cooper Home and Run Figure 3-1 Run CooperHome on Lychee Figure 4-1 CooperHome Main Logo The CooperHome dashboard page provides users with overview information and the status of both the Ambarella SoC and the EVK Figure 4-2 CooperHome Dashboard Page The device information section provides an overview of the Ambarella device It consists of five tabs device processor memory firmware and clocks Figure 4-3 CooperHome Dashboard Page Device Info Device Figure 4-4 CooperHome Dashboard Page Device Info Processor Figure 4-5 CooperHome Dashboard Page Device Info Memory Figure 4-6 CooperHome Dashboard Page Device Info Firmware Figure 4-7 CooperHome Dashboard Page Device Info Clocks The CPU loading section shows the CPU loading percentage value for the past second this value refreshes each second Figure 4-8 CooperHome Dashboard Page CPU Loading The CVflow loading section shows the CVflow loading percentage value for the past second this value refreshes each second Figure 4-9 CooperHome Dashboard Page CVflow Loading The video input VIN information section shows a list of initialized sensor modules on the Ambarella device Figure 4-10 CooperHome Dashboard Page VIN Info The stream information section shows a list of enabled streams on the Ambarella device Figure 4-11 CooperHome Dashboard Page Stream Info The CooperHome startup page provides users with one-click operations to start tasks on CPU DSP and CVflow Figure 4-12 CooperHome Startup Page The CPU section allows users to enable dummy loading on CPU cores load50 start DRAM memory test memtester-arm and start memory copy speed test test_memcpy These operations add load to CPU cores and/or DRAM read write Figure 4-13 CooperHome Startup Page CPU The CooperHome performance page provides users with performance profile features on the Ambarella SoC with the following six aspects Figure 4-14 CooperHome Peformance Page The dynamic random-access memory DRAM bandwidth section includes a DRAM bandwidth diagram of the Ambarella device over the past hundreds of milliseconds The samples are captured on the edge of each millisecond After clicking the button the application starts to capture the latest data and the diagram is refreshed Other functions in this section are as follows button start profiling the DRAM bandwidth diagram button save DRAM bandwidth raw data button save the PNG image of the current DRAM bandwidth graph dropdown menu select the graph type line graph or stacked area graph dropdown menu select the duration of the sample capture time Figure 4-15 CooperHome Peformance Page DRAM Bandwidth The interrupts section shows the increment values of interrupts in the Ambarella system during the selected period The average minimum and maximum columns are accumulated values starting from when the button is clicked and they are reset when the button is clicked button start profiling system interrupts dropdown menu select the time of the increment values duration Figure 4-16 CooperHome Peformance Page System Interrupts The video pipeline analysis section profiles the canvas stream and video output VOUT latencies for the running video pipeline This section also shows the frame drop status in the top-right corner of the image digital signal processing IDSP and encoder blocks button start profiling the video pipeline dropdown menu select the time of the latency values duration Figure 4-17 CooperHome Peformance Page Video Pipeline Analysis The CPU profile section evaluates the CPU core on the Ambarella SoC The tab shows the history diagram of CPU loading and memory use for each process The tab shows the overall CPU loading memory use and network throughput button start to profile the CPU core Figure 4-18 CooperHome Peformance Page CPU Profile Processes Figure 4-19 CooperHome Peformance Page CPU Profile Resources The DSP profile section evaluates the DSP core on the Ambarella SoC The tab shows memory useage of the DSP continuous memory allocator CMA partition(s) button start to profile the DSP core Figure 4-20 CooperHome Peformance Page DSP Profile Memory The CVflow profile section evaluates the CVflow core on the Ambarella SoC button start to profile the CVflow core The tab shows memory useage of the CVflow CMA partition Figure 4-21 CooperHome Peformance Page CVflow Profile Memory The tab shows the CVflow loading of CVflow processes Figure 4-22 CooperHome Peformance Page CVflow Profile Processes For CV3x the tab shows the loading of multiple CVflow cores NVP GVP Figure 4-23 CooperHome Peformance Page CVflow Profile Resources for CV3 only The tab shows the performance statistics of CVflow cores Figure 4-24 CooperHome Peformance Page CVflow Profile Perfstat The CooperHome image quality page provides users with image controls to Ambarella image process Figure 4-25 CooperHome Image Quality Page The image process information section provides the image process library version number parameter file version number and more Image process configuration section provides the image control to individual channels There are three type of controls auto exposure auto white balance and image adjustment for the user When entering the image quality page the image process running at background will be killed and the lua will be loaded if file exists Otherwise the default lua will be loaded When leaving the image quality page the original image process will be resumed button Save current settings to lua The CooperHome geometric distortion correction GDC page provides users with controls to Ambarella dewarp features through test_ldc ADVANCED Lens Distortion Correction Before tuning the geometric distortion the DSP must be in preview state and lens_warp of channel configuration must be enabled After GDC tuning is complete it will generate the configuration warp table parameters located in These files can be used by to load a well-tuned combination Figure 4-26 CooperHome Geometric Distortion Correction Page The general configuration section sets the channel ID to be tuned and the related lens parameters The correction mode configuration section provides users with controls to follow correction modes No Transform Rotation 2.2 No Transform Rotate Rectilinear 2.3 Wall Rectilinear Horizontal Panorama 2.4 Wall Panorama Cylinder 2.4.1 General Cylindrical and Panorama Mercator 2.4.2 Mercator Equirectangular 2.4.3 Equirectangular Squircular 2.4.4 Squircular Vertical Panorama 2.5 Wall Vertical Panorama Pannini 2.6 Wall Pannini Pincushion 2.7 Wall Pincushion The CooperHome video capture page provides the capabilities to capture video outputs Figure 4-27 CooperHome Video Capture Page The Livestream section streams the video in realtime given the selections of frame rate and source buffer Figure 4-28 CooperHome Video Capture Page Livestream The CooperHome about page provides the descriptions and history updates of the application Figure 4-29 CooperHome About Page CooperHome server checks the running environment at startup It requires the following environment to enable the full features of CooperHome Otherwise only subset of CooperHome features will be shown dmesg top df ifconfig lscpu mpstat AMBARELLA_ARCH SYS_BOARD_BSP SYS_BOARD_VERSION iav cavalry ambdram_statis test_encode test_aaa_service cavalry_top cavalry_log ddrc_v2 dsp CV2x test_dsp_pipeline_latency test_ldc jpg_http_stream load50 test_memcpy memtester-arm dsplog_cap cavalry_profile CV5x/CV7x Copyright c 2 0 2 4 Ambarella International LP This file and its contents are protected by intellectual property rights including without limitation U.S and/or foreign copyrights This Software is also the confidential and proprietary information of Ambarella International LP and its licensors You may not use reproduce disclose distribute modify or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates In the absence of such an agreement you agree to promptly notify and return this Software to Ambarella International LP This file includes sample code and is only for internal testing and evaluation If you distribute this sample code whether in source object or binary code form it will be without any warranty or indemnity protection from Ambarella International LP or its affiliates THIS SOFTWARE IS PROVIDED AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS COMPUTER FAILURE OR MALFUNCTION OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">page_sys_porting_ubuntu_doc</field>
    <field name="url">d0/de4/page_sys_porting_ubuntu_doc.html</field>
    <field name="keywords"></field>
    <field name="text">DESIGN Porting Ubuntu System DESIGN Porting Ubuntu System Updated Date Modification 2 0 2 3 0 2 2 7 Initial Version This document introduces transplanting Ubuntu system to Ambarella system on chip SoC platform without running the graphic user interface GUI At the same time unit tests the digital signal process DSP driver and the vector process VP driver located in the software develop kit SDK are also transplanted into the Ubuntu system to implement encoding in the DSP and running convolutional neural network CNN algorithms When users develop software on Ambarella SoC platform third-party tools and libraries are often required Users must cross-compile and transplant them on the device each time If the Ubuntu system can run directly on the device softwares can be installed via application thus improving the efficiency of developing software The Ubuntu core system can be downloaded from the official Ubuntu website In this document version 16.04 is used as an example Figure 3-1 Ubuntu Version Download the ubuntu-base-16.04.6 file and extract it to the working directory Figure 3-2 Ubuntu Base Code Extract the download package to working directory Install the QEMU simulator on the host PC QEMU is a powerful simulator that will be used to run the Ubuntu system that is to be ported to the PC Copy to the Ubuntu core directory usr/bin Copy the host resolv.conf to the Ubuntu core directory etc This step enables Ubuntu core system domain name service DNS to work normally Mount proc sys and dev/pts file systems then and use to enter into the Ubuntu core system Contents of ch-mount.sh are listed below After mounting the file system users can execute Ubuntu s operation in the simulator Set password for root Add a new user Modify the download repositories of the Ubuntu core system In China users can choose University of Science and Technology Tsinghua University Alibaba and Huawei After the repositories have been configured users can install the common softwares Serial configuration As ttyS0 is the console serial port on Ambarella platform the link must be added to connect getty service Network configuration The gigabit netword card on Ambarella platform is eth0 Users must create the file under d and configure network-related parameters If a static network is configured the following parameters must be provided If a dynamic network is configured the following contents must be provided As Ubuntu base rootfs doesn t contain kernel modules ko they are required to be copied to Ubuntu core system from standard SDK Copy the standard SDK s unit test binaries lua 3 a binary and DSP VP firmware binaries to Ubuntu core system Add Ambarella-related drivers that can be loaded automatically when the system boots up Input the driver list that must be loaded for example Exit from the Ubuntu core chroot system Uninstall the rootfs Package the rootfs There are two scenarios to burn the rootfs into the evaluation kit EVK board The EVK board possesses an embedded multi-media controller card eMMC The rootfs can be downloaded directly to the eMMC The EVK board just has a NAND and secure digital SD slot Select the boot media for the eMMC on the EVK Burn the normal firmware bst_bld_kernel_lnx_release.elf to the EVK board When the normal firmware has completed burning to the EVK board boot up the board and format The parameter indicates the number of inodes Users must configure this parameter according to the actual situation If the inode amount is too small the file cannot be written sequentially even if there is sufficient disk space Mount the Ubuntu file system partition Extract the Ubuntu file system tar.gz to the partition mounted in step 3 The command enables users to access the rootfs.tar.gz package Users can use other methods such as or file transfer protocol FTP Modify the Ubuntu file system permissions Unmount the Ubuntu file system partition Reboot the system and enter into AMBoot to modify the booting command cmdline Reboot the system to enter into the Ubuntu system Log in with the username and password when the rootfs is created As the rootfs must be burned onto SD card Ambarella SD driver must be compiled into the kernel CV2 is used as an example Modify the kernel configuration and generate the firmware the CV2_Chestnut EVK is used as an example For CV2x SDK 3 0 Amba Build For Cooper Amba and Yocto Build For Amba Build For Yocto Build Burn the firmware to the board using the AmbaUSB tool Insert and format the SD card The parameter indicates the number of inodes Users must configure this parameter according to the actual situation If the inode amount is too small the file cannot be written sequentially even if there is sufficient disk space Mount the SD card partition Extract the Ubuntu file system tar.gz to the partition mounted in step 3 The command enables users to access the rootfs.tar.gz package Users can use other methods such as or FTP Modify the Ubuntu file system permission Unmount the Ubuntu file system partition Reboot the system and enter into AMBoot to modify the booting command cmdline Reboot the system to enter into the Ubuntu system Log in with the username and password when the rootfs is created Figure 4 1 is captured from the board s serial when the CV2 EVK board enters into the Ubuntu shell Figure 4-1 Ubuntu login This section focuses on some issues during the migration process and the corresponding solutions Question 1 How can the error be fixed when the system boots up Answer Connect to the network and install the software using Question 2 How is added by a common user Answer Log in with the root account Add writing permission to For example add sudo permission to Remove the writing permission from Grant privileges to the sudo program Question 3 What is the solution for when the command user cannot restart the system Answer Install dbus-user-session software using then execute Question 4 What are the steps to update the Ubuntu 16.04 libc version from 2.23 to 2.29 Answer Use the following commands to compile and install glic 2.29 Replace all so files located in with the same file of xxx/lib64 Replace the soft link file so.1 aarch64-linux-gnu/ld-2.23.so with so.1 aarch64-linux-gnu/ld-2.29.so Question 5 Where can the corresponding so file for a new library be found Answer Execute the command to find the so file Question 6 The system cannot be entered when libc is updated How do users solve this issue Answer Reboot the system and enter into the AMBoot shell to modify the command line Use to mount Ubuntu file system Enter into the Ubuntu system and modify the libc soft link Uninstall the Ubuntu file system Reboot the system and enter into the AMBoot shell to modify the command line To prevent subsequent updates to glibc use the following commands to disable glibc updates Copyright c 2 0 2 4 Ambarella International LP This file and its contents are protected by intellectual property rights including without limitation U.S and/or foreign copyrights This Software is also the confidential and proprietary information of Ambarella International LP and its licensors You may not use reproduce disclose distribute modify or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates In the absence of such an agreement you agree to promptly notify and return this Software to Ambarella International LP THIS SOFTWARE IS PROVIDED AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS COMPUTER FAILURE OR MALFUNCTION OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">page_sysdoc_cm3_doc</field>
    <field name="url">d1/d5e/page_sysdoc_cm3_doc.html</field>
    <field name="keywords"></field>
    <field name="text">BASE CM3 BASE CM3 Updated Date Modification 2 0 2 3 1 1 1 5 Initial Version 2 0 2 3 1 2 2 6 Updated Section 4.1.1 Board Configuration The Cortex-M3 CM3 processor is specifically developed for high-performance and low-cost platforms This document provides an introduction on CM3 implementation CM3 runs on FreeRTOS 2 0 2 2 1 0 LTS Users can download it from CM3 codes are located in SDK/ambarella/boot/cm3 and SDK/ambarella/boards/ $ board_name c The toolchain gcc-arm-none-eabi-10.3 is used to build CM3 Users can download it from The CM3 firmware is included in AMBoot There are several remote processor messaging RPMsg frameworks available Currently only RPMsg-Lite is ported Users can download it from The remote processor RPROC framework manages the resources required by the RPMsg framework Boot option If Boot with TrustZone is selected secure boot should be enabled and power-on configuration POC pin 6 should be pulled up Shared memory The unit test code is located in SDK/ambarella/unit_test/linux/misc/test_cm3_rpmsg.c CM3 implements a slave serial peripheral interface SPI device to communicate with a master SPI device such as microcontroller unit MCU CM3 waits for data from the MCU The MCU sends 1 2 8 bit data to CM3 Copyright c 2 0 2 4 Ambarella International LP This file and its contents are protected by intellectual property rights including without limitation U.S and/or foreign copyrights This Software is also the confidential and proprietary information of Ambarella International LP and its licensors You may not use reproduce disclose distribute modify or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates In the absence of such an agreement you agree to promptly notify and return this Software to Ambarella International LP THIS SOFTWARE IS PROVIDED AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS COMPUTER FAILURE OR MALFUNCTION OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">page_sys_fastboot</field>
    <field name="url">d1/dd3/page_sys_fastboot.html</field>
    <field name="keywords"></field>
    <field name="text">DESIGN Fast Boot DESIGN Fast Boot SDK Version Updated Date Modification cooper 1.5 2 0 2 3 1 1 2 2 Added Page Design Fast Boot The SDK versions listed in the table reflect the current SDK version x.x or patch release x.x.x A patch number that is not sequential indicates that the previous patch release did not apply to this document This document describes the fastboot method used to quickly start the system The following list compares the advantages and disadvantages to these methods Cold boot Fast cold boot is a fastboot option that requires the least amount of modification to the existing system among all two fastboot methods It retains the normal boot-up mechanism and accelerates the boot-up process by optimizing boot scripts utilizing clean boot and speeding up peripheral loading Dynamic random-access memory DRAM self-refresh DRAM self-refresh is a fastboot option that relies on DRAM running in the background It saves the system context to DRAM on shutdown and restores the system from DRAM on bootup However the DRAM self-refresh method requires an external microcontroller unit MCU to manage system on chip SoC power and DRAM Further its standby power additionally includes the DRAM power consumption The following tables provide the key specifications of each fastboot option Table 1 1 Comparison of Fastboot Methods Cold Boot DRAM Self-refrsh Resume Timestamp Load kernel image 1 7 1 mSec Jump to kernel 3 0 5 mSec Enter Linux 6 6 3 mSec Probe digital signal processor DSP 6 9 7 mSec Cavalry done 7 3 6 mSec Load firmware 7 7 0 mSec Probe video input VIN done 8 2 1 mSec Resume from idle 6 4 mSec First frame capture 1 0 5 0 mSec 4 4 2 mSec Enter encode 1 3 2 2 mSec 6 2 4 mSec Note With eMMC boot SD read speed 7 3 3 3 3 KB/s An external MCU for power management is required Limited driver modules are probed for optimization as shown below This guide demonstrates how to cold start the system to record videos as soon as possible by 1 optimizing the system startup script and 2 clipping the system The system startup time refers to the time from cold startup to the acquisition of the first frame Section 2 2 describes how to prepare the system startup script to load drivers in parallel which is the most important step and can reduce time by about two seconds Section 2 3 describes how to slim the system in order to achieve a faster start-up speed which can reduce the time by hundreds of milliseconds Section 2 4 introduces other hardware-related optimization methods Section 2 5 describes how to measure the boot-up time Section 2 6 shows an example of running cold boot optimization After the system restarts rcS will be executed rcS executes the Sxx script to load the module drivers such as audio secure digital SD USB udev network and more The system waits until all drivers are loaded In order for the camera to function normally only image audio video IAV audio SD and udev among other drivers are required Therefore the system must load these drivers when starting In order to further accelerate the loading process the parallel loading method running in the background can be adopted First modify rootfs/system-init/busybox-sysvinit/sysroot/etc/init.d to execute only one optimization script as follows Then write S01optinit to load the necessary drivers in parallel Refer to the following For the optimizations described in Section 2 1 to take effect at the compilation stage add the above files to rootfs/system-init/busybox-sysvinit/sysroot/etc/init.d in the software development kit SDK Then check the CONFIG_BUSYBOX_SYSVINIT option in menuconfig as follows After the system boots up the optimized startup scripts will be under the directory d To reduce the size of the root file system rootfs image users can reduce the size of the rootfs partition by removing unwanted packages pre-builds third-party software libraries unit test applications and so on Note that the cutdown should be based on the customer s real use case After simplification check the compiled image size in the out directory ls h images/rootfs.ubifs then modify the rootfs partition size The AMBOOT_PARTITION_LAYOUT partition size is defined in the board support package BSP bsp.h The purpose of streamlining the kernel is to manage modules that are not required in the boot phase Users can choose not to directly build them into the kernel but into separated module drivers change from Y to M Then load them dynamically after system boots up This can reduce the time required to load the kernels Users can change other file system support to another type other than rootfs such as network file systems to dynamically load It is also possible to pursue a faster startup without compiling other drivers that are not required Users can refer to ipcam_cleanboot_kernel_emmc_lp4/5_config Using SquashFS as the rootfs will further reduce the system boot time as compared to the Unsorted Block Image File System UBIFS In some cases when using NAND SquashFS can reduce the time by around 5 0 0 ms Add the parameter to the command line for example console ttyS0 noinitrd root rw rootfstype ext4 rw rootfstype ext4 rootwait pci nomsi pcie_aspm off quiet This will greatly reduce the time required to print information through the serial port when the system starts Users can add it in CONFIG_AMBOOT_BD_CMDLINE in menuconfig as follows Or modify it in bsp/xxx.dts as follows Some peripheral drivers have software delays calling sleep() or delay() when loading For example the SD card driver can be delayed by hundreds of milliseconds upon power-up which can be appropriately reduced according to actual requirements and after assessing risks To increase the speed of I2C communication for some peripherals such as the sensor users can also modify the I2C clock frequency modify ambarella-xxx.dtsi Currently the CV72 platform can support up to a 1 MHz clock Adjust NAND timing by modifying bsp/xxx.ini Adjust the embedded multi-media controller eMMC power-on configuration POC as HS200 8 bit mode to boot up Select HS 8 bit mode for the bootloader BLD in menuconfig For Cooper SDK Amba Build For Cooper SDK Yocto Build Ambarella recommends measuring the time difference between the general purpose input output GPIO pin level flip through the oscilloscope When the first dsp_encode_irq arrives a high level is generated through a test pin and the time difference between it and the reset high level is measured that is it measures the accurate time from system start-up to plot On the CV72 evaluation kit EVK the boot-up time from system power-up to the first dsp_encode_irq has been measured to be about 1.3 seconds cortex_clock 1 6 0 8 MHz core_clock 6 2 4 MHz sensor OS08A10 When the DRAM self-refresh feature is enabled the system operates in low-power mode During suspension all hardware except DRAM is powered off This feature is supported in CV72 DRAM self-refresh functions with both the normal boot flow and the secure boot ArmÂ® TrustZoneÂ® flow Starting from the bootstrapper BST normal self-refresh and secure self-refresh share many of the same resume-flow components Figure 3-1 Normal Boot DRAM Self-Refresh Resume Workflow for the SoC For a detailed overview of the secure boot flow refer to the Ambarella DG Flexible Linux SDK Security Overview document Figure 3-2 Secure Boot DRAM Self-Refresh Resume Workflow for the SoC The following figure shows the MCU workflow on DRAM self-refresh resume Figure 3-3 DRAM Self-Refresh Resume Workflow for the MCU The following figure shows the SoC workflow on DRAM self-refresh suspend Figure 3-4 DRAM Self-Refresh Suspend Workflow for the SoC The following figure shows the MCU workflow on DRAM self-refresh suspend Figure 3-5 DRAM Self-Refresh Suspend Workflow for the MCU Self-refresh must function with power control PWC PWC can be used in two ways Internal PWC not all SoCs include an internal PWC External PWC an external MCU must be used when the SoC does not have an internal PWC If the board design uses an external MCU for the power sequence control the SoC must communicate with the MCU through a GPIO The protocol is as follows The SoC generates a rising signal to notify the MCU that the SoC will enter into self-refresh The MCU then notifies the SoC of the state after being powered on If from a cold boot MCU keeps the GPIO high If resumed from self-refresh MCU keeps the GPIO low Different board designs may use different GPIOs Both the BST and kernel must know which GPIO is used in order to communicate with the external MCU For BST the GPIO is defined in the ini file by PARAM_SOC_NOTIFY_MCU_GPIO For more details users can refer to Section 3 2 2 INI File below In the ini file there are two fields related to self-refresh the PARAM_SOC_NOTIFY_MCU_GPIO value and the PARAM_MCU_NOTIFY_SOC_GPIO value For different boards the GPIO setup will be different For the CV72 Gage board The DRAM self-refresh function is supported on the CV72 board To enable this function users must have the corresponding MCU code and the CV72 firmware binary Before compiling ensure that the peripheral component interconnect PCI and Cadence USB are disabled Use the following commands to compile the firmware that supports normal DRAM self-refresh Users should ensure that the external MCU is flashed with code that supports the DRAM self-refresh functionality Meanwhile the power selection jumper should be shorted in order to enable power management from the MCU For the CV72 Gage board connect the J80 pins Power on the system using the PS-ON button and then enter the following commands DRAM self-refresh does not support resume-from-preview mode use test_encode to enter preview after resuming from idle mode The sequence of commands listed above is used to perform the suspend operation in which all device modules will save the current scenario information with the exception of the information inside the DRAM This information includes hardware configurations states and other scenario- specific information The resume operation is executed by pressing the MCU PWRON button on the EVK board This operation restores the hardware registers and states in addition to recovering the state of the camera Copyright c 2 0 2 4 Ambarella International LP This file and its contents are protected by intellectual property rights including without limitation U.S and/or foreign copyrights This Software is also the confidential and proprietary information of Ambarella International LP and its licensors You may not use reproduce disclose distribute modify or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates In the absence of such an agreement you agree to promptly notify and return this Software to Ambarella International LP THIS SOFTWARE IS PROVIDED AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS COMPUTER FAILURE OR MALFUNCTION OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</field>
  </doc>
  <doc>
    <field name="type">group</field>
    <field name="name">lib-sensor-helper</field>
    <field name="url">d2/d55/group__lib-sensor-helper.html</field>
    <field name="keywords"></field>
    <field name="text">Sensor Calibration Library Helper in file lib_sensor_calib.h</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">page_sys_pm</field>
    <field name="url">d2/d90/page_sys_pm.html</field>
    <field name="keywords"></field>
    <field name="text">OPTIMIZATION Power Management OPTIMIZATION Power Management Updated Date Modification 2 0 2 2 0 8 0 9 Initial Version 2 0 2 2 0 8 1 2 Updated OPTIMIZATION Power Management for detailed information 2 0 2 2 0 9 2 1 Added Section 2.11 Analog-to-Digital Converter 2 0 2 3 0 2 0 9 Added Section 2.2 CPU Core and IDSP Clock Runtime Update 2 0 2 3 0 8 3 1 1 Added Section 2.12 Peripheral Component Interconnect Express 2 Added Section 2.13 High Efficiency Video Coding HEVC 3 Added Section 2.7.4 Video LCD 4 Updated Section 2.7 Video Output This document provides guidelines for power management with the Ambarella CV5x Flexible Linux Software Development Kit SDK If the system load is minimal the number of CPU cores can be set to two or less This modification alters the Linux boot arguments bootargs a reboot is required to take effect If ArmÂ® trusted firmware ATF is enabled then CONFIG_RELOAD_UNTRUSTED_DTB is also required in order for AMBoot modifications to take effect Enter into AMBoot and modify the bootargs Boot into Linux and check the log below CV5x chips do not support CPU core hotplug The CV72 chip does not support CPU core hotplug This feature enables users to update the CPU core and image digital signal processor IDSP clocks on the fly This benefits users as it enables them to select the appropriate CPU core and IDSP clocks to conserve system power In order to change the CPU and core clocks ATF must be involved For more details about ATF refer to Section If users request runtime updates of the CPU and core clocks Amabrella recommends reserving the ATF partition at the NAND partition layout design When changing the core and IDSP clocks for the digital signal processor DSP the DSP must first be placed in the idle state Suppose that users want to switch over among the following CPU core and IDSP clock combinations Table 2 1 CPU Core and IDSP Clock Combinations CPU MHz Core MHz IDSP MHz 1 6 0 8 1 1 4 0 9 6 0 1 3 9 2 9 6 0 7 2 0 6 0 0 3 3 6 3 6 0 Follow the steps below to build the firmware Change the CV5x device trees DTS to add the desired CPU and core clock combinations The following provides an example using the CV5 system on chip SoC Select the following kernel configuration to enable CPU frequency scaling Usage guidelines of the four options above are as follows Performance the guaranteed performance Userspace users can update on the fly Ondemand users can update on the fly according to the present requirements Conservative users can update on the fly in a conservative manner Note that Ambarella recommends updating the clock in the Telnet client console rather than in the serial port Open Telnet and perform the following operations Update frequency on the fly through the following commands Several options that can be set are in the folder and are listed as follows scaling_available_frequencies the supported frequencies to be updated scaling_governor the current governor performance userspace ondemand conservative scaling_cur_freq the current frequency in kHz 2 4 0 0 0 is 2 4 MHz scaling_setspeed the frequency to be updated CPU IDSP and core clocks are independent from one another Users can attempt any combination For CPU clocks and core clocks only frequencies listed in the DTSi are permitted to be set Ensure that those values are multiples of 2 4 MHz The maximum CPU IDSP and core clocks CANNOT be greater than the specification of the corresponding CV5x system on chip SoC If the clock is updated to a low value such as 2 4 0 0 0 the serial port may not function However the Telnet port may still function The CPU clock must be greater than 9 6 MHz due to the physical design limitation The core clock must be greater than 2 4 MHz If a high-definition multimedia interface HDMIÂ® is enabled with a resolution greater than 4 8 0 p a minimum value of 9 6 MHz for the core clock is suggested The clock runtime-switch time includes the clock switching time and the re-running DSP time The spent time varies according to different DSP use cases Users can measure the clock runtime-switch time using the following method Place the clock switching and unit test commands to re-run the DSP into a single script Then use the tool to measure the time spent executing this script The tool outputs the spent time with the results displayed as three parts Real total spent time User user space spent time Sys kernel space spent time For example the script clock_switch.sh includes changing the IDSP clock commands and re-entering preview commands as shown below The user can measure the time on the board as shown below The vector processor VP clock frequency can only be switched to a different frequency when the VP is not in use Use cavalry_load to change the VP clock Because the VP clock setting in the ini file is the runtime upper limit the runtime VP clock change cannot exceed the value in the ini file The VP clock must be an exact multiple of 2 4 MHz and cannot be set to 0 Users must calculate the fraction when updating the VP clock Additionally users must always check the clock frequency after setting it Contact the Ambarella SDK support team for connecting the video input VIN pins to the ground GND If no mobile industry processor interface MIPIÂ® sensor is used the MIPI CSI-2 power can be lowered via the following commands To conserve power all floating inputs outputs I/Os can be set to the general purpose input output GPIO and enabled with an internal pull-low Refer to the Peripherals Doxygen webpages for additional details regarding GPIO configuration Then use the following commands Or use poweroff_pdev.sh in the path ambaralla/app/utility/amba_scripts If video output VOUT is not required contact the Ambarella SDK support team to disable it VOUT B can be disabled using the following command Alternatively use poweroff_pdev.sh If CVBS is not required disable it using the following commands Alternatively use poweroff_pdev.sh If HDMI is not required disable it using the following commands Alternatively use poweroff_pdev.sh If MIPI DSIÂ® is not required disable it using the following commands If LCD is not required disable it using the following command If computer vision CV is not required disable it to save power Contact the Ambarella SDK support team for further assistance Alternatively use poweroff_pdev.sh If secure digital input output SDIO is not required disable it using the following commands Alternatively use poweroff_pdev.sh If audio is not required disable it using the following commands Alternatively use poweroff_pdev.sh If the analog-to-digital converter ADC is not required disable it using the following command Or use poweroff_pdev.sh If peripheral component interconnect express PCIe is not required set the disable flag into the related DTS node If the system only encodes in H.264 format then the H.265 state registers can be disabled using the following command Or use poweroff_pdev.sh Use the following steps to verify if ATF is properly configured Check the options from For Cooper Amba build For Cooper Yocto build Check if the ATF partition size is configured properly in bsp.h Copyright c 2 0 2 4 Ambarella International LP This file and its contents are protected by intellectual property rights including without limitation U.S and/or foreign copyrights This Software is also the confidential and proprietary information of Ambarella International LP and its licensors You may not use reproduce disclose distribute modify or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates In the absence of such an agreement you agree to promptly notify and return this Software to Ambarella International LP THIS SOFTWARE IS PROVIDED AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS COMPUTER FAILURE OR MALFUNCTION OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">page_sys_hw_pts_doc</field>
    <field name="url">d2/dcb/page_sys_hw_pts_doc.html</field>
    <field name="keywords"></field>
    <field name="text">DESIGN Timer PTS DESIGN Timer PTS Updated Date Modification 2 0 2 1 1 0 2 1 Initial draft 2 0 2 2 0 6 1 3 Update the document to explain in more details 2 0 2 3 0 7 2 6 Updated Section 2 added details for sync timer and source 2 0 2 3 0 8 2 8 Updated Section 2.3 for sync timer usage In order to synchronize video and audio data for the CV5x platform a global timer is required to generate video and audio timestamp The requirements for this global timer are listed as follows The global timer should be able to generate a 6 4 bit timestamp instead of a 3 2 bit timestamp A 3 2 bit timestamp can be wrapped around in a short time For instance if the timer jiffies are 1 0 0 0 0 0 0 the generated timestamp will be wrapped around after 4 2 9 5 seconds However if the width is 6 4 bits the generated timestamp will last long enough to avoid wrap around This global timer should be independent enough and cannot be affected by any other sources Only this can ensure that the generated timestamp is precise enough and then can be used for synchronization between audio and video Previously Ambarella adopted the system timer as a reference clock source Since the system timer ticks can be accessed directly by calling the related API video and audio applications can directly access it to get the timestamp for any timer However this method has the following drawbacks The system clock may be synchronized with the NTP time Thus the timestamp around the synchronization point can be drifted forward or back But this cannot ensure that the timestamp is monotonic increasing which is quite important for the PTS use case The system clock cannot be accessed by digital signal processor DSP So the video PTS generation has to be delayed inside the VIN ISR This will cause frame time-stamping delay depending on the time difference between DSP capturing a frame and ArmÂ® receiving VIN ISR The solution used in CV5x SDK is listed as follows For CV5x there is a 3 2 bit global timer 12.288 MHz which can be accessed both from DSP and Arm side Both audio and video can use this global timer to generate their timestamps as PTS One of the CV5x interval timers TIMER 4 is used here is used to check the global timer overflow cases periodically Arm generates 6 4 bit timer ticks based on the 3 2 bit global timer by incorporating overflow counters and outputs timestamps with configured output frequencies The global timer is independent and not influenced by outer resources So there are no timer tick drift cases The timestamp generated by the global timer is easy to be configured to be 6 4 bits to make sure no wraparound happens In CV5x the global timer is used to be implemented as a hardware timer This is a 3 2 bit timer not enough for 6 4 bit PTS usage The frequency for this global timer is 12.288 MHz So the 6 4 bits counter is maintained with this 3 2 bit tick in the hardware timer driver The driver is located in In this hardware timer driver proc file is created All the applications can read the value from this proc file to get the current timestamp in 6 4 bits Normally Audio PTS is generated in this way Video PTS is generated inside IAV Hardware timer driver also provides interface to kernel modules IAV so that IAV can get the current timestamp for video directly Hardware timer driver supports changing the output frequency dynamically by writing a new output frequency counter into the process file For example users can change the output frequency to 1 MHz with the commands It is recommended to keep the default 9 0 KHz output frequency However if a new output frequency is required the IAV driver should be re-initialized again so that the IAV driver is aware of the updated output frequency The hardware timer driver maintains a global 6 4 bit counter The TIMER4 used by the hardware timer driver is used to watch the overflow counters periodically So the 6 4 bit counter is listed as follows Timestamp_input Overflow_counter 3 2 Global_timer_tick The output 6 4 bits timestamp is then generated from the input timestamp The formula is as follows Timestamp_output Timestamp_input OUT_FREQ INP_FREQ 2 INP_FREQ OUT_FREQ and INP_FREQ are output frequency and input frequency respectively The input frequency is fixed with 1 2 2 8 8 0 0 0 For some use cases hardware timer needs to be in sync with the global system timer This is because some modules may need to use the system timer as the clock source So when the events from these modules need to be synchronized with the video or audio presentation time stamp PTS users can configure the hardware timer to be in sync with system timer Then the PTS from them would be in the same clock domain and can be considered from the same clock source Firstly the hardware timer must be in the same frequency as the system timer It would be configured with 1 MHz which means value 1 tick indicating 1 second Secondly the initial timer value should be initialized as the current system timer tick to make sure that hardware timer and system timer start at the same time Lastly it is also needed to adjust the hardware timer values in a fixed frequency according to the system timer ticks The synchronization frequency is currently set once per second to make sure the hardware timer is not drifted too much For the system timer source Linux supports various sorts for different purposes Currently hardware timer can choose from the system timer sources below 1 CLOCK_MONOTONIC The system timer increases monotonically but may be adjusted by adjtime and network time protocol NTP This matches user space API clock_gettime CLOCK_MONOTONIC xxx 2 CLOCK_MONOTONIC_RAW The system timer increases monotonically It won d be affected by adjtime or NTP This is used as the default system clock source when adjusting hardware timer This matches user space API clock_gettime CLOCK_MONOTONIC_RAW xxx 3 CLOCK_REALTIME The realtime system clock may be ajdusted by adjtime and NTP This matches user space API clock_gettime CLOCK_REALTIME xxx 4 CLOCK_BOOTTIME It is similar as CLOCK_MONOTONIC The difference is that CLOCK_BOOTTIME still counts time when system is suspended while CLOCK_MONOTONIC doesn t This matches user space API clock_gettime CLOCK_BOOTTIME xxx When the hardware timer is configured to synchronize with the system timer the 6 4 bit video PTS can be directly used to compare with other system event timestamps captured from user space clock APIs mentioned above For more details of the example about how to use hardware timer tick and user space clock API please refer to the unit test test_hwtimer which is located at ambarella Hardware timer module is located in ambarella To enable this module to compile enable in menuconfig as shown below When hardware timer module is compiled users can find two process files and Users can open and read the current 6 4 bit timestamp stores the current hardware timer output frequency Users can write values to it through Example to configure the hardware timer output frequency to be 9 0 KHz Example to write the initial 6 4 bit timestamps when the system is booted Example to read the current 6 4 bit timestamps There is a parameter for hardware timer module which is used as the flag to enable synchronization with system timer Users can add below line into d/ambarella.conf to enable the synchronization Example to check whether sync_timer is enabled after system boots up There is another parameter for hardware timer module which is used as the option to select the timer source for system timer synchronization This option must be used when is enabled The values for the sync sources are as follows 0 CLOCK_MONOTONIC_RAW 1 CLOCK_MONOTONIC 2 CLOCK_REALTIME 3 CLOCK_BOOTTIME Users can add the line below into d/ambarella.conf to configure sync source to be SYNC_CLOCK_MONOTONIC Example to check the current system timer sync source after system boot up The parameter is added for hardware timer module to configure the synchronization interval in milliseconds ms The default value is 1 0 0 0 meaning to synchronize hardware timer and system timer every second Users can add the line below into d/ambarella.conf to configure sync source to be SYNC_CLOCK_MONOTONIC with synchronization interval 1 0 0 ms There are possible three clock sources which are used as PTS sources The first one is the I2S clock audio clock source from the global timer with 12.288 MHz frequency It is normally for the PTS information reported from DSP because DSP can only access this timer The global timer is started once DSP is booted and the ticks and the frequency can t be configured The second one is the clock source from hardware timer This clock is commonly used by user applications to synchronize different events such as video frame PTS audio sample PTS and potentially others The frequency is by default 9 0 KHz and it is configurable for other values such as 1 MHz The third one is from DSP software and it is used to generate software PTS The software PTS is increased from 0 and with fixed PTS interval The frequency for this is 9 0 KHz So if the frame rate is 3 0 the software PTS will be in the sequence of 0 The PTS will be reset to 0 for each time DSP is switched into preview state Audio PTS is generated in user space applications It can be generated directly by reading the proc file Once an audio packet needs an audio PTS the only thing the application needs to do is to read the procs file It is requested to stamp the audio PTS when the audio sample is captured from the audio capture device If the audio PTS is stamped after some processing then there will be potential sychronization issues such as audio video synchronization issue Video PTS generation is more complicated when compared to Audio PTS The video time-stamping operation is implemented inside DSP This is the exact accurate timing generating timestamp that is generated when a full frame is captured The presentation time stamp PTS has the same meaning as the capture time stamp If the time-stamping operation is done on the Arm side the time-stamping moment is delayed and inaccurate The PTS sent by DSP is generated from the global timer with I2S clock 12.288 MHz The hardware time driver will translate this PTS to the hardware timer PTS When DSP finishes encoding a frame of a stream it will generate an encode interrupt to IAV There will be several frames delay when one frame is encoded after this frame is captured This is called encode pipeline delay here Before issuing the encode interrupt DSP will put the frame information to the frame information buffer shared between the DSP and IAV IAV will get the DSP PTS generated by the global timer from the frame information buffer and generate the hardware PTS based on the DSP PTS Since the DSP PTS is just a few frames before the current global timer tick the hardware PTS will be generated based on this information to avoid confusion for overflow cases PTS in Each IDSP/VDSP Domain The image above shows the PTS for each output data in IDSP/VDSP stage The timing to stamp the PTS value is when the video frame is captured by DSP In this way the PTS for the frame data at different stages can be sychronized Users can use the PTS value to know whether the frame information from different stages are from the same captured frame and they can also know the capture time difference for the 2 frame data in different stages As Overview and Hardware Timer described the clock source of hardware PTS is audio clock and the frequency of which is 12.288 MHz However the typical application domain frequency is 9 0 KHz so Ambarella introduces software PTS which is 9 0 KHz based The table below shows the basic information of hardware PTS software PTS and monotonic PTS these three types of PTS are all attached by IDSP/VDSP or Arm In theory the PTS value will be increased frame by frame and the difference of PTS per frame is Clock Souce of Different PTS PTS variable Bits Clock Source Calculation Method hw_pts 3 2 Global Timer Global Timer Ticks used by DSP in 12.288 MHz sw_pts 3 2 Software Start from 0 adding fixed delta in 9 0 KHz for each frame mono_pts/arm_pts 6 4 Hardware Timer Sychnorized with hardware timer default 9 0 KHz In this section Ambarella enumerates the PTS categories in each stages and lists tables below 1 RAW IDSP RAW IDSP Stage PTS Varibles PTS variable Bits Clock Source Description hw_pts 3 2 Global Timer Raw/3A global timer PTS stamped by DSP sw_pts 3 2 Software Raw/3A software PTS stamped by DSP mono_pts 6 4 Hardware Timer Raw/3A monotonic PTS stamped by hardware timer 2 Canvas/Pyramid YUV/me0/me1 For users can specify the clock source of it according the flag in user space YUV Stage PTS Varibles PTS variable Bits Clock Source Description hw_pts 3 2 Global Timer Clock Raw/3A global timer PTS stamped by DSP sw_pts 3 2 Software Raw/3A software PTS stamped by DSP mono_pts 6 4 Hardware Timer Raw/3A monotonic PTS stamped by hardware timer dsp_pts 3 2 Global Timer or Software DSP sw_pts or hw_pts decided by 3 VDSP VDSP Stage PTS Varibles PTS variable Bits Clock Source Description arm_pts 6 4 Hardware Timer Raw capture done monotonic PTS stamped by Arm enc_done_pts 6 4 Hardware Timer Frame bitstream output monotonic PTS stamped by Arm dsp_pts 6 4 Global Timer Software Low 3 2 bit with sw_pts high 3 2 bit with hw_pts Users can take different PTS for different stages and use them for different purposes such as 1 Frame Sync and Stream Sync For these user cases both hardware PTS and software PTS can be used for synchronization 2 Audio video sync Audio s PTS is obtained from hardware timer which is the same clock base as video monotonic PTS Hence users can do audio and video synchronization combine either hardware PTS or monotonic PTS If user application would like to do synchronizations between Arm and DSP then users may need to choose from hardware PTS hw_pts or software PTS sw_pts For example synchronize warp related operations to the specified frame or synchronize encoder related operations to the specified frames If user application needs to synchronize different sources at Arm side then users may need to use the 6 4 bit monotonic Arm PTS arm_pts or mono_pts For example synchronization between audio and video data or synchronization between video and other sources gyro data For audio user applicaion should get the hardware time ticks as soon as the audio samples is captured from audio capture device For video when user application calls IOCTL to query frame data users will get the actual PTS from arm_pts in the struct iav_framedesc This PTS is also stamped when the video RAW frame is captured by DSP As long as the timing for both audio PTS and video PTS happens when the data is captured done these audio samples and video frames can be automatically sychronized using the capture PTS The typical working flow for frame synchronization mechanism is described below User application queries the canvas frame data through IOCTL IAV_IOC_QUERY_DESC with IDSP IAV_DESC_CANVAS In the struct iav_yuv_cap there is dsp_pts used to synchronize with DSP User application does some analysis based on the canvas YUV data and calculates some encode parameters for this dedicated frame User issues these encode parameter to IAV/DSP through IOCTL IAV_IOC_APPLY_FRAME_SYNC_PROC In the struct iav_apply_frame_sync there is also dsp_pts field which needs to match the dsp_pts in the canvas YUV data When this is matched the encode parameters will be applied to this dedicated frame when it goes into encoder For this frame synchronization feature the dsp_pts is actually software PTS sw_pts described above so the parameter is_dsp_hw_pts in struct iav_canvasdesc must be disabled in this case when querying canvas YUV data This PTS is from DSP and also applied to DSP when performing frame synchronization The stream encode done time-stamping operation is implemented inside IAV driver This is the timing when IAV driver gets the VDSP interrupt and has collected the full frame data from VDSP IAV driver will call hardware timer driver to get current ticker immediately when the full frame data are collected The encode done PTS describes the timing when Arm receives the endoded frame data By comparing this PTS with the RAW capture done PTS mono_pts or arm_pts users can understand the pipeline latency between RAW capture done and encode done which includes the time of IDSP processing time as well as VDSP encoding time The encode done PTS is NOT suggested to be used as the actual PTS which may be used to sychronize with other events such as audio The reasons are listed as follows The time stamp timing must be deterministic The encode done timing is not deterministic because it may be affected by the IDSP procession latency as well as the encode latency The time stamp timing must be stable When stamping at Arm side it may be affected by the DSP interrupt timing as well as the system loading The timing may be fluctuated from time to time And it may also be affected by different number of encode streams because there is only one set of VDSP hardware to encode all the streams and the frames from these streams must be encoded sequentially The frame encoding order may be different from frame capture order When B frames are enabled the PTS will not be in ascending order So it is not applicable to use encode done timing as the PTS Copyright c 2 0 2 4 Ambarella International LP This file and its contents are protected by intellectual property rights including without limitation U.S and/or foreign copyrights This Software is also the confidential and proprietary information of Ambarella International LP and its licensors You may not use reproduce disclose distribute modify or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates In the absence of such an agreement you agree to promptly notify and return this Software to Ambarella International LP THIS SOFTWARE IS PROVIDED AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS COMPUTER FAILURE OR MALFUNCTION OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">page_sysdoc_kernel_doc</field>
    <field name="url">d3/d7b/page_sysdoc_kernel_doc.html</field>
    <field name="keywords"></field>
    <field name="text">BASE Kernel BASE Kernel Ambarella s kernel documentation has been integrated into the kernel s Sphinx documentation system Please check it out here Here is a brief summary An analog-to-digital converter abbreviated ADC is a device that uses sampling to convert a continuous quantity to a discrete time representation in digital form Ambarella Socs have on-chip ADCs Ambarella ADC supports mode and mode The sampling rate is determined by gclk_adc the number of used channels and clock cycles for one sampling The formula of ADC is D V 2 1 R here D is digital value V is input voltage R is the range i.e 1.8v or 3.3v Ambarella Soc has an internal Infrared RC Remote Control module which owns a dedicated PIN for it This IR module consists of a 1 6 bit counter driven at a rate of gclk_ir which is derived from OSC Once the IR module is enabled the counter will start to count NIST Statistical Test Suite is used to verify if a bit stream is random enough There are 1 5 tests in NIST SP-800-22 test suite RNG stands for Random Number Generator and the output is used for âencryption keyâ generation The linux driver provides character device through hw_random framework.To check if RNG output is random enough this page provides the information about how to verify the randomness It contains randomness verification number generation and test result on different platform PTP stands for precise time protocol IEEE 1 5 8 8 PTP is supported on CV2x and later chips linuxptp is a recommended tool to test and configure the ptp on linux Linux kernel support up to 4 system sleep states generically mode explain freeze Suspend-To-Idle ACPI S0 standby Standby Power-On Suspend ACPI S1 mem Suspend-To-RAM Self-Refresh STR ACPI S3 disk Suspend-To-Disk STD ACPI S4 Mem i.e Self-Refresh means system powers off all the hardwares except for DRAM and PWC which would save the power and also bring up the system quickly when waken up Internal or external power control is essential in self-refresh Arm_tf is also needed for this feature Device Tree is essentially a data structure in byte code format which contains information that is helpful to the kernel when booting up The boot loader copies that chunk of data into a known address in the RAM before jumping to the kernel s entry point Ambarella.txt introduces how to configure Ambarella Platforms Device-Tree When secure boot is enabled many registers including peripherals like GPIO will ONLY be accessible in secure world by default Refer to for how to configure the device node of secure monitor to make GPIO accessible in non-secure world Users need to take care of this especially when trying to operate on GPIOs at BLD stage Copyright c 2 0 2 4 Ambarella International LP This file and its contents are protected by intellectual property rights including without limitation U.S and/or foreign copyrights This Software is also the confidential and proprietary information of Ambarella International LP and its licensors You may not use reproduce disclose distribute modify or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates In the absence of such an agreement you agree to promptly notify and return this Software to Ambarella International LP THIS SOFTWARE IS PROVIDED AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS COMPUTER FAILURE OR MALFUNCTION OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</field>
  </doc>
  <doc>
    <field name="type">group</field>
    <field name="name">sensor-api</field>
    <field name="url">d3/d95/group__sensor-api.html</field>
    <field name="keywords"></field>
    <field name="text">Sensor Calibration Library API in file lib_sensor_calib.h</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">page_sys_faq_doc</field>
    <field name="url">d3/df5/page_sys_faq_doc.html</field>
    <field name="keywords"></field>
    <field name="text">DEBUG FAQ DEBUG FAQ Choosing an appropriate chip depends on the following encoding specifications encode mode double data rate DDR bandwidth and DDR size This section lists the specifications required for each to enable users to choose the appropriate chip(s) for their applications Encoding specifications Please check the specification from release note document Encode mode It is important to ensure that the feature wanted is supported in current encode mode For details refer to ADVANCED Encode Mode DDR bandwidth DDR bandwidth is an important resource that users care a lot about Dynamic random access memory DRAM bandwidth statistics tool could be useful when profiling bandwidth usage Please check fs_others_dram_statistics for the usage of the tool DDR size DDR memory is divided into three partitions Linux image audio video IAV and digital signal processor DSP The Linux partition is used to run the operating system and the user program the IAV partition is used for the interaction between the DSP and IAV and the DSP partition is reserved for the DSP s internal usage Currently users can perform their own optimization For details refer to the Ambarella CV5x DG Flexible Linux SDK DRAM Optimization document For the DSP partition users can decide the size according to the specification After they decide the size users should check the minimum DSP memory with the user case for example use test commands Additionally users can modify the IAV partition using the command with the requirement The following commands can be used to check the DSP RAM cost when the case is running Ambarella performs several tests to determine the chip clocks for various part numbers Therefore to ensure stable encoding Ambarella does not include APIs to change the clocks and recommends users not attempt to change them Instead Ambarella recommends users to choose a real part number with in to ensure that the system clock is configured correctly In the user space there are two interfaces for obtaining the PCM audio data ALSA or PulseAudio Although pulse audio provides a strong and rich interface it requires more DRAM bandwidth and CPU For ALSA refer to the ALSA sample code for audio applications ambarella unit_test linux audio test_audio.cpp or ambarella app cloud media_mw src audio_platform linux_alsa audio_alsa.cpp For pulse audio users can refer to the following ambarella app cloud media_mw src audio_platform pulse_audio pulse_audio.cpp or ambarella oryx_v2 base audio device am_audio_device_pulse.cpp The I2S interface supports two-way voice data transmission its core task is to achieve echo cancellation Hardware and software methods can be used for echo cancellation For hardware usersâ audio code should support echo cancellation such as AK7755 Alternatively users can add DSP for echo cancellation between audio CODEC and the master control chip such as AK4951 AK7719 For software users can try AEC of pulse audio in the SDK which must run Oryx Before selecting a flash first check if the flash is supported by the Ambarella SDK Once the support is confirmed choose the correct type and compile Because incorrect ECC bits may lead to serious problems users must first confirm and check the ECC so that ECC configuration errors do not occur in the mass production The CV5x chip includes a hardware ECC function and supports 1 bit ECC In the hardware design first confirm that the ECC bits exist in the flash specification and then configure the corresponding hardware POC for EVK as shown below If users want to support the 8 bit mode then the flash page NAND size should be 2 K+128 For more information refer to the section on the ECC level in NAND For different page sizes the number of ECC bytes generated by different ECC levels and its layout is in out of band OOB For the code refer to the structure nand_ecclayout in ambarella kernel linux-5.4 drivers mtd nand ambarella_nand.c If the unsorted block image file system UBIFS are used OOB stores only bad block markers and ECC data In this case as long as OOB has sufficient size to store ECC which is defined by flash specification then flash can use UBIFS If YAFFS2 are used OOB includes file systems with information relating to YAFFS2 which are required for various storage purposes Therefore the OOB size must be large enough to store both ECC and YAFFS tags The following lists the requirements If the OOB size is insufficient it cannot support YAFFS2 If JFFS2 is used then JFFS2 uses OOB to store specific information and must ensure that these locations the hardware ECC and the other data locations do not conflict with each other For flash with built-in ECC use UBIFS as the OOB cannot be read from or written to A flash programmer is typically required in mass production Because generating the ECC using the burner can be difficult users can generate it using the master instead The following steps describe this procedure Select a part of the flash that includes no bad blocks and solder it to the board Erase all and then use AmbaUSB to burn the firmware of mass production When finished do not reboot Also avoid writing operations in flash while running Weld off the flash wash place it in the flash programmer and then read the content several times saving to the bin file and ensure there are no inconsistencies Use the flash programmer to burn the bin file in Step 2 to flash Ensure the burn is to the partition and not the entire piece Mark the bad blocks using the burner Patch the flash and ensure that the system is fully activated for the first boot Activated in AMBoot the default value is written in the boards $BOARD bsp bsp.h For example for cv5_timn boards cv5_timn bsp bsp.h For further details refer to the following GPIO AMBARELLA CV5 HW PRM GPIO AMBARELLA CV52 HW PRM For GPIO the following two registers can be enabled If one GPIO includes multiple functions then the user must set its IOMUX register the corresponding feature selection list can be found in the Ambarella CV5x Hardware PRM document If the register is not correctly set the default value will not be used The following commands can be used for debug purposes For further details refer to Debugfs For customer use For information about ADC usage refer to ambarella kernel linux-5.15 Documentation arm ambarella adc.txt The following shows example steps for adding an LCD named with a resolution of 3 2 0 x240 Refer to the digital or td043 driver in Ambarella kernel private drivers vout amblcd Check the LCD datasheet to confirm the resolution pixel clock timing signals interface types rgb565 rgb888 and other information then create the driver following the datasheet Use to configure and test the LCD UUID is not provided for chips However users can check the CPU type chip ID as follows Call this check after the DSP enters the preview or encode mode If the USB host does not have an overcurrent users must disable the flow detection in the source code to avoid issues and ensure that the USB device can be identified Modify boards/cv5x_board/bsp/cv5x_board.dts The following command is an example that uses the CV5 Timn EVK board Check to verify that the open firmware is enabled For Cooper Amba build For Cooper Yocto build If users want to use the CV5x internal watchdog they should refer to the example of the watchdog in the kernel in ambarella kernel linux-5.15 Documentation watchdog First users must add new flash-related attributes in the array and include the ID flash sector size sector number page size clock and more Next in the function amb_spi_nor_shutdown() users must add the reset command for the new flash to avoid system problems after reboot The following example is for mx25l25645g For this flash the ID is 0 x1940c8 there are 5 1 2 sectors each sector is 6 4 K and the page size is 2 5 6 bytes See the following after adding mx25l25645g SPI flash includes a definition of Address space of 3 bytes can access the 1 6 M flash If users must access more than 1 6 M storage space then they should use the 4 byte addressing mode For mx25l25645g 3 2 M if the system wants to access any data within the flash the 4 byte addressing mode is required In functions amb_spi_nor_probe() the system sends 4 byte instructions to the flash so mx25l25645g is in a state of 4 byte If the system reboots at this time AMBoot will access the flash with 3 bytes causing data read anomalies and leading to startup issues The solution to this problem is to send reset to mx25l25645g in function The following lists information about the sensor driver initialization Users must add parameters when using or in order to load the driver directly Parameters such as the bayer_pattern bus_addr and lane are related to the hardware design bayer_pattern is related to the sample timing of the pixel clock bus_addr is related to the I2C address and interface of the sensor Lane specifies the data transmission number between the sensor and main control For example set number of lanes to 2 when using OV4689 in the CV5 platform The following lists the steps required to support Chinese SSID Create a corresponding file for the Chinese fonts Run the following command before generating the firmware in the fakeroot directory of the user s compiler environment For example on the CV5_Timn board it is ambarella/out/cv5_timn/fakeroot Compile and burn the new firmware Set Lang variables when the system is on using the following command For kernel upgrade and rootfs upgrade users can refer to si_online_upgrading If boards/ $BOARD $BOARD.dts file is changed then users must update the DTB file using the following command $BOARD.dts.dtb file is under the out/ $BOARD As a testing tool MPtool consists of two parts the server on the product side and the client on the PC end There are two methods for connecting WiFi and USB virtual network card Ambarella recommends using a USB to ensure a more stable connection Enable the server in There is no relationship between the server implementation and Oryx middleware it is implemented by calling the interface in unit test and IAV Patch is used to improve the SDK package Typically package patch is used The package patch1 patch2 is not supported After installing a new patch users must re-integrate changes in bsp customized applications and IQ related files when the board is brought-up Additionally users must accurately backup and manage IQ files to avoid negatively impacting the IQ performance after patch installation The following includes general information about device trees DTS files If users must modify the public portion of a chip modify the file arch arm64 boot dts ambarella ambarella- $SoC.dtsi For the CV5S66 chip for example modify the file arch arm64 boot dts ambarella ambarella-cv5.dtsi For external devices users must modify the device tree file ambarella boards $BOARD bsp $BOARD.dts For example for CV5_Timn modify ambarella boards cv5_timn bsp cv5_timn.dts and ambarella boards cv5_timn bsp cv5_timn_private.dtsi If users want to check how many device nodes exist when the system is running they must first enable the device tree in the public Linux menuconfig Then check them in proc device-tree DTS works after the Linux kernel runs The BST and AMBoot modes work before the kernel Therefore when there are changes in the hardware users must check ambarella/boards/ $BOARD h This file defines the initial state of each pin the initial function of each pin and each flash partitionâs size Incorrect bsp.h will cause the system to hang For detailed DTS information refer to kernel linux-5.15 documentation devicetree bindings arm ambarella.txt If users change the type of the DDR SDRAM or perform a shmoo test then they must check or change ambarella/boards/ $BOARD $BOARD_$CPU.ini For example for CV5S66 users must change ambarella/boards/cv5_timn/bsp/cv5_timn_66_micron_lpddr5.ini After running a shmoo test and receiving the correct DDR parameters users can then modify the file ambarella/boards/ $BOARD $BOARD_$CPU.ini For example for cv5_timn modify ambarella/boards/cv5_timn/bsp/cv5_timn_66_micron_lpddr5.ini The default configuration file for is ambarella/boards/ $BOARD $BOARD_config To change the configuration in CV5 Timn modify ambarella/boards/cv5_timn/bsp/cv5_ipcam_config While using make menuconfig_public_linux the default kernel configuration file is typically ambarella/boards/ $BOARD $BOARD_kernel_config Alternatively for example use 1 5 For issues concerning CVflow refer to the document Ambarella CV5x DG Flexible Linux SDK CVflow FAQ To use embedded multi-media controller eMMC on the EVK a hardware rework may be required Refer to si_sd_upgrading Additionally notitle provides information on software configuration and flash upgrading For instructions on how to use the contiguous memory allocator CMA for IAV CV memory partitions refer to the document Ambarella CV5x DG Flexible Linux SDK CMA Driver Users are recommended to specify the size of the IAV CV CMA partitions according to their requirements with less margin and leave more system memory for the Linux partition Although the unused memory resource left in the CMA partition can be reused by the Linux system it is easy to trigger the out of memory OOM killer when the Linux system starts to allocate from the CMA partition and this is a limitation of the CMA For details on this limitation refer to Ambarella CV5x DG Flexible Linux SDK CMA Driver</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">page_sys_dram_opt_doc</field>
    <field name="url">d4/d3e/page_sys_dram_opt_doc.html</field>
    <field name="keywords"></field>
    <field name="text">DESIGN Memory Layout Optimization DESIGN Memory Layout Optimization SDK Version Updated Date Modification CV5x SDK 0.5 2 0 2 1 1 0 2 1 Initial Version CV5x SDK 0.5 2 0 2 2 0 1 1 4 Added Section 1.1 Memory Layout Introduction Updated Section sec_dram_linux Updated Section 2.2 IAV Partition Updated Section 2.2.2 User Data Buffer Updated Section 2.3.1 Composition Added Section 4.2 CV52 Bandwidth Limitation CV5x SDK 1.5 2 0 2 2 0 7 2 1 Updated Section 2.2 IAV Partition Added Section 2.2.11 CANVAS_POOL Added Section 2.2.14 Blur Added Section 2.2.15 Arbitrary Blur Updated Section 4.1 CV5 Bandwidth Limitation Updated Section 4.2 CV52 Bandwidth Limitation CV5x SDK 2.0 2 0 2 2 0 8 0 1 Migrate this DRAM Optimization document from Word form into Doxygen form Cooper SDK 1.5 2 0 2 3 0 9 2 8 Update Section Examples of Memory Allocation Cooper SDK 1.6 2 0 2 4 0 1 1 0 Update Section Examples of Memory Allocation The DRAM system consists of four partitions Linux image audio video IAV image digital signal processing DSP and computer vision CV The Linux partition operates the Linux system the IAV partition is shared by the IAV driver and DSP the DSP partition is used by DSP and the CV partition is used by the vector processor VP The base addresses and total sizes of the IAV DSP and CV-related partitions can be configured using and the file If desired users can change the system to ensure that it fits customized designs provided that any changes meet the DSP and VP minimum requirements for DRAM size The continuous memory allocator CMA is supported by the Linux kernel and enables the allocation of large physically continuous memory blocks at runtime The CMA also allocates and maintains the IAV DSP and CV partitions on CV2x The IAV and DSP partitions share the same CMA memory pool while CV has its own When Linux boots up the free memory left in the memory pools is reused by the Linux system The base addresses and sizes of the CMA memory pools for the IAV DSP and CV partitionsare specified in the compile configuration using the default configuration build $ make cv2x_ipcam_config for the CV series of chips The Ambarella CV5x platform supports DRAM sizes of 4 GB 8 GB 1 6 GB and greater The chip series targets 8 KP30+ encoding therefore requiring a large DRAM size and bandwidth as well as high-resolution image signal processing ISP and encoding processing Ambarella divides system memory into the following three categories through the CMA DSP private memory partition access only CV cannot read or write the memory in this partition CV private memory partition access only DSP cannot read or write the memory in this partition DSP and CV shared memory partition The memory in this partition can be accessed by Which means DSP CV and Arm have accessed to the memory in this partition For the CV5x platform Arm has been upgraded to access DRAM with a 4 0 bit address bitwidth which exceeds the minimum required to access the entire DRAM However the DRAM access address bitwidth of DSP and CV remains 3 2 bits as a result both can access only 4 GB memory space To address this different memory layouts will be made for the 4 GB and 8 GB or 8 GB DRAM accordingly The total 4 GB DRAM size can be accessed by The figure below shows the system memory layout for 4 GB DRAM size which is applied to platform 4 GB DRAM System Memory Layout For 4 GB DRAM size on the platform DSP private memory pool size 2 8 1 6 MB DSP shared memory size 1 6 MB CV private memory pool size 5 1 2 MB CV shared memory size 0 MB Linux memory size 4 0 9 6 2 8 1 6 5 1 2 1 6 0 x2F400000 7 5 6 MB Because the DRAM access address bitwidth of both DSP and CV is 3 2 bits they are unable to directly access the memory beyond the 4 G boundary To provide them with their own 4 GB memory space the CV5x platform utilizes the address translation table ATT mapping for the both and while CV and continue using the default DRAM memory space as they are both within 4 GB The process of ATT mapping for is separated into the following two steps 1.When performing ATT mapping is mapped from 0 which means that its offset in the ATT memory space will be the same with the lower u32 of its DRAM physical address For example if the DRAM physical address is 0 x1 0 0 1 0 0 0 0 0 the offset in the ATT memory space will be 0 x0010 0 0 0 0 2.Map to the end of the 4 GB ATT memory space Its offset in the ATT memory space will be the same as its DRAM physical address For example if the DRAM physical address is 0 xFF10 0 0 0 0 then its offset in the ATT memory space will also be 0 xFF10 0 0 0 0 Consequently the memory layout of the 8 G DRAM size is designed as shown in the following diagram 8 GB DRAM System Memory Layout The following table shows the DRAM access limitation for Arm CV and DSP 8 GB DRAM Access Limitation for Arm CV and DSP Element DRAM Access Limitation Arm 0 GB CV 0 GB DSP DSP memory space For 8 GB DRAM size on the platform DSP private memory pool size 2 8 1 6 MB DSP shared memory size 1 6 MB CV private memory pool size 5 1 2 MB CV shared memory size 0 MB Linux memory size 8 1 9 2 2 8 1 6 â 5 1 2 1 6 0 x12F400000 4 8 5 2 MB This chapter describes each partition in detail while providing guidelines on how user applications can optimize DRAM usage for their corresponding system The DRAM utilization can be changed manually for user applications with different requirements This chapter includes the following sections sec_dram_linux 2.2 IAV Partition 2.3 Digital Signal Processor Partition 2.4 CV Partition 2.5 Resource Memory Layout Configuration When the system boots up customers can dump the start addresses and sizes of the IAV DSP CV sub-partitions using the following commands Dump the IAV DSP sub-partitions Dump the CV sub-partitions When the system is in preview or encoding state customers can check the DSP DRAM usage information using the following commands The following figure illustrates the IAV sub-partition Detailed IAV Sub-Partitions The following table shows the details of the IAV sub-partitions All DRAM sizes will be aligned to page sizes 4 KB in the actual DRAM map IAV Partition Usage Instructions Name Instruction and Usage Resiz-able Default Size Necessity BSB Bitstream buffer stores the encoding data such as H.265 H.264 and MJPEG The size depends on the total stream bitrate and bitstream data cache time Yes 3 2 MB Compulsory USR User data buffer is used to encode from the raw data both YUV and RGB Its size depends on raw data size and number Yes 0 MB Optional MV Motion vector buffer Yes 0 MB Optional OVERLAY Overlay buffer is used for on screen display OSD Its size depends on the overlay area size and number Yes 1 6 MB Optional QPMATRIX QPMATRIX_RAW QP ROI matrix buffer QP matrix raw buffer Yes 1 0 MB Optional WARP The warp buffer is used for multi-region dewarp and LDC Yes 1 MB x N(N: channel number) Optional QUANT JPEG quant matrix table is used to improve the MJPEG quality No 8 KB Compulsory IMG Image buffer used for 3 A Yes 5 x N 1 MB(N: channel number) Compulsory MASK Single-color multi-color privacy mask buffer The size depends on the maximum supported VIN resolution Single-color maximum VIN resolution 8 x N Multi-color maximum VIN resolution x N(N: channel number) Yes Single-color 4 0 MB x N Multi-color 0 MB(N: channel number) Optional PYRAMID_POOL Pyramid buffer pool for the pyramid manual-feed mode The size depends on the pyramid buffer size and number Yes 0 MB Optional CANVAS_POOL Canvas buffer pool for the canvas manual-feed mode The size depends on the canvas buffer size and number Yes 0 MB Optional BLEND_ALPHA Alpha blend buffer for the cross-channel stitching The size depends on the stitching area size and number Yes 0 MB Optional BLUR Blur buffer for the stream privacy protection The size depends on the maximum blur area size Yes 0 MB Optional ARB_BLUR Arbitrary blur buffer for the stream privacy protection The size depends on the maximum blur area size and maximum stream number Yes 0 MB Optional The following stages specify the size of the IAV sub-partitions for different use cases Compilation stage for reserved memory management or CMA The compilation stage configures the partition size through and then compiles it into the firmware Driver installation stage only for CMA The driver installation stage sets the driver module parameters to load different options for the partition size Run-time stage only for CMA The run-time stage configures and resizes the partition size through IAV IOCTL on-the-fly while the system runs The following guidelines provide details to optimize the DRAM size of IAV sub-partitions Details of IAV sub-partitions Sub partition Usage BSB Adjusts the size of the bitstream buffer according to the total stream bitrate and bitstream data cache time For more details refer to Section 2.2.1 Bitstream Buffer Overlay Adjusts the size of the overlay buffer according to the total overlay area size and number For more details refer to Section 2.2.4 Overlay QPM Adjusts the single QP matrix memory size according to the maximum stream resolution and number The default value is 1 2 8 KB for a 4 K resolution The QPM size can be reduced by more than half for resolutions smaller than 4 MP For more details refer to Section 2.2.5 QP Matrix WARP If LDC or dewarp functions are not required set the warp buffer size to zero For more details refer to Section 2.2.6 Warp PM Adjusts the single-color multi-color privacy mask matrix memoryaccording to the maximum VIN resolution The default value is 1 0 MB set for 4 K but it can be reduced when the VIN resolution is smaller in size For more details refer to Section 2.2.9 Mask IMG Adjusts the IMG buffer size according to the requirements of the 3 A application Different encode modes EIS delay settings and back pressure margin settings may need a different IMG buffer size For more details refer to Section 2.2.7 Image CV5x supports up to 1 6 streams The BSB is used to store the bitstream data generated by all streams encoded by the DSP which functions as a ring buffer If the BSB size is too small the time remaining for Arm to read out the bitstream data will be insufficient and the data may be overwritten By default the BSB size is 1 0 MB If there are four streams with a total 2 0 Mbps 8 M 4 M 4 M 4 M bit rate then the buffer can cache the bitstream data for 1 0 MB x 8 2 0 Mbps 4 s Typically 4 s of cache time is adequate for Arm to read out the bitstream data Users should adjust the BSB buffer size according to the number and bitrate of the streams in use BSB size SUM stream_bitrate x cache_time This example uses cache_time as 4 s The BSB size can be configured in three stages Compile stage Sets the BSB buffer size through then compiles it into the image For Cooper Amba build For Cooper Yocto build Driver installation stage Configures the BSB buffer size through the driver module parameter Run-time stage Dynamically resizes the BSB buffer through IAV IOCTL IAV_IOC_ALLOC_MEM_PART and IAV_IOC_FREE_MEM_PART when the system is running The user data buffer USR is used for cases of encoding from raw data and encoding from memory EFM For the case of encoding from raw data the memory partition size depends on the resolution and raw type RGB YUV422 For example in the case of a 1 0 8 0 p RGB raw encode the buffer size is 1 9 2 0 x 2 1 9 2 0 2 x 1 0 8 0 x 5 5 cycle buffers MB In the case of a 1 0 8 0 p YUV raw encode the buffer size is 1 9 2 0 x 2 1 9 2 0 x 1 0 8 0 x 5 5 cycle buffers MB In EFM cases the USR partition size depends on the resolution and number of EFM buffers For example if the EFM buffer resolution is 1 0 8 0 p and the buffer number is 6 then the USR partition size is 1 9 2 0 x 1.5 x 1 0 8 8 x 6 MB The USR size is configured in three stages Compile stage Sets the internal BSB buffer size through then compiles it into the image For Cooper Amba build For Cooper Yocto build The driver installation stage which configures the USR size through the driver module parameter Run-time stage Dynamically resizes the internal BSB buffer through IAV IOCTL IAV_IOC_ALLOC_MEM_PART and IAV_IOC_FREE_MEM_PART when the system is running If the system does not require encoding from raw data or encoding from memory the USR size must be set to zero through or via the driver module parameter to reduce the DRAM size CV5x supports dumping the motion vector MV for up to five streams The MV dump is available only for AVC streams The basic unit for the MV is a macroblock with 1 6 x16 pixels MB Each MV unit occupies 4 bytes including the motion information in the x and y directions If the maximum stream size is 3 8 4 0 x2160 the single MV buffer frame size will be 3 8 4 0 x 2 1 6 0 1 6 x16 x 4 1 2 8 KB Usually a ring buffer with several MV buffer frames is required to cache between the DSP and Arm This ensures that there is enough time for Arm to read out the MV data before being overwritten by the DSP If eight frames are used the total MV buffer size for each stream will be 1 2 8 KB x 8 1 MB The MV buffer size of a single stream is configured through For Cooper Amba build For Cooper Yocto build The maximum stream number that needs MV dump is configured through For Cooper Amba build For Cooper Yocto build The total DRAM size needed for the MV buffer should be the maximum stream number multiplied by the MV buffer size With the above settings it will be 1 MB x 2 2 MB The total MV buffer size can also be specified at the driver installation stage which configures the total MV buffer size through the driver module parameters If the system does not use the MV feature users can set the MV buffer size to zero through or the driver module parameter to reduce the DRAM size The CV2x supports 1 6 independent color look-up tables CLUT Each CLUT requires 1 KB of memory Only CLUT8 is supported With CLUT8 each look-up table is an array of 2 5 6 entries The entry is defined for four individual color channels Y U V and alpha transparency Alpha 0 is the transparent value 2 5 5 is non-transparent The default configuration for overlay is 8 MB for CV2x chips Users can change the overlay size to meet their application requirements The overlay buffer size can be specified in three stages The compile stage configures the overlay buffer size through and then compiles it to the image For Cooper Yocto build The driver installation stage configures the overlay buffer size through the driver module parameter The run-time stage configures resizes the overlay buffer through IAV IOCTL IAV_IOC_ALLOC_MEM_PART and IAV_IOC_FREE_MEM_PART simultaneously while the system is running If the system does not use the stream overlay feature users can set the overlay buffer size to zero through menuconfig or the driver module parameter in order to reduce the DRAM size The two configurations below are provided to ensure the effectiveness of the QP matrix buffer The first configuration is IAV_ROI_NUM_FOR_IPB_FRAMES which is used to configure the QP matrix number for each stream The valid matrix numbers for H26X streams range from one to three inclusive The default QP matrix value is one which means there only is one QP matrix It is shared by the I P frames B frame is not enabled When the QP matrix number is two there are three different application cases 1 I P frames share the same QP matrix The B frame uses the other QP matrix 2 I P frames use different QP matrixes The B frame is not enabled 3 I P frames share the same QP matrix The P2 frame uses the other QP matrix When the QP matrix number is three there are three different application cases 1 I P B frames use different QP matrixes separately 2 I P P2 frames use different QP matrixes separately The B frame is not enabled 3 I P frames share the same QP matrix The B P2 frames use the other two QP matrixes separately The QPMATRIX number is configured through For Cooper Amba build For Cooper Yocto build The second configuration is IAV_MEM_QPM_SIZE This is used to establish the single QP matrix size By default the size is 1 2 8 KB to support 4 K encoding This can be used either as an AVC or HEVC QP matrix To support 4 K AVC encoding the required QP matrix size is 4 0 9 6 x 2 0 4 8 1 6 x16 x 4 1 2 8 KB where 1 6 x 1 6 is the MB size and 4 indicates 4 bytes QP matrix item size per MB To support the 4 K HEVC encoding the required QP matrix size is 4 0 9 6 x 2 0 4 8 3 2 x 3 2 x 1 2 9 6 KB where 3 2 x 3 2 is the CTU size and 1 2 indicates 1 2 bytes QP matrix item size per CTU In this configuration 1 2 8 KB is enough to support both AVC and HEVC 4 K encoding Based on the above formula users can customize the QP matrix size according to the encoding type and the maximum stream size that is required The QPMATRIX size is configured through For Cooper Amba build For Cooper Yocto build In order to support the frame or the stream synchronization mechanism there is one active buffer for the user configuration and four internally-used buffers for each stream Suppose that there are 1 3 streams each streamâs QP matrix number is one and size is 1 2 8 KB Thus the total size is 1 2 8 KB x 1 x 1 4 x 1 3 8 3 2 0 KB If the QP matrix number is three the maximum value the total size will be 1 2 8 KB x 3 x 1 4 x 1 3 2 4 9 6 0 KB The total QP matrix buffer size can also be specified at the driver installation stage which configures the total QP matrix buffer size through the driver module parameters If the system does not use the QPMATRIX feature the QP matrix size can be set to zero through menuconfig or through the driver module parameter in order to reduce DRAM utilization The warp buffer is reserved to store all warp vectors for fisheye lens or lens distortion correction LDC The buffer size is approximately 1 2 6 KB per channel changing this size is unnecessary Warp can be configured through For Cooper Amba build For Cooper Yocto build If the system does not support or use the fisheye correction and LDC the user can disable it through to reduce DRAM utilization This buffer is reserved for 3 A to store all image signal processor ISP configuration parameters IMG consists of two sub-partitions 1 The image kernel IK buffer which stores IK configuration parameters 2 The static bad pixel SBP buffer for SBP correction By default the SBP buffer is not allocated Only the IK buffer is allocated and its buffer size depends on the channel number IMG size 5 x channel_number 1 MB For example if the channel number is two the IMG size required is 5 x 2 1 1 1 MB Therefore when one channel is added an extra 5 MB will be added accordingly The number of channels is configured by CONFIG_AMBARELLA_MAX_CHANNEL_NUM in as shown below For Cooper Amba build For Cooper Yocto build In a real use case users may be required to specify their own IK buffer and SBP buffer sizes These sizes can be specified in the following two stages Once specified they will be merged into the IMG buffer The compile stage configures the IK buffer and SBP buffer sizes through then compiles it into the image For Cooper Amba build For Cooper Yocto build The driver installation stage configures the IK buffer and SBP buffer sizes through the driver module parameters The QUANT buffer size is 4 KB Usually there is no need to change this buffer size The privacy mask PM can protect sensitive regions from being leaked by covering them with arbitrarily-shaped areas Once the PM areas are inserted they will appear in both the VOUT preview and the encoded streams Details for privacy mask include the following Privacy mask takes effect on the VIN domain Single-color privacy mask only supports one kind of color at a time Its granularity can be pixel level The corresponding memory partition name is IAV_PART_MASK For the single-color PM the default supported maximum resolution is 1 2 MP 4 0 9 6 x 3 0 7 2 Therfore the maximum size of a single PM buffer is 4 0 9 6 3 x 3 0 7 2 1.5 MB There are four internally-used cache buffers as well as an extra buffer for user application to fill PM data As a result the total PM size required for one channel is 1.5 MB x 1 4 7.5 MB For multi-channel the size will be 7.5 MB x N N can be found using the CONFIG_AMBARELLA_MAX_CHANNEL_NUM Users can refer to Section 2.2.7 Image for more details The size of the single-color PM buffer can be specified in the driver installation stage which configures the MASK buffer size through the driver module parameter If the system does not use the MASK feature then the MASK buffer size can be set to zero through the driver module parameter in order to reduce the DRAM size This buffer is allocated and maintained by the IAV driver only in the pyramid manual-feed mode Its size depends on the number and size of the pyramid buffer Because the buffer size can be calculated automatically in the IAV driver users do not need to change it in the user application If the system does not use the feature of the pyramid manual-feed users can disable the pyramid manual-feed mode when entering preview in order to save the DRAM size This buffer is allocated and maintained by the IAV driver only in the canvas manual-feed mode Its size depends on the number and size of the canvas buffer Because the buffer size can be calculated automatically in the IAV driver users do not need to change it in the user application If the system does not use the canvas manual-feed feature users can disable the canvas manual-feed mode when entering the preview state to reduce DRAM utilization This buffer is allocated and maintained by the IAV driver only in the raw manual-feed mode Its size depends on the number and size of the raw buffer Because the buffer size can be automatically calculated in the IAV driver there is no need for users to change it in the user application If the system does not use the raw manual-feed feature users can disable the raw manual-feed mode when entering the preview state to reduce DRAM utilization This buffer is allocated and maintained by the IAV driver for the alpha blending feature It is dedicated for multi-channel stitching application cases Its size depends on the number of the stitched channels and the size of overlapped areas Because the buffer size can be automatically calculated in the IAV driver there is no need for users to change it in the user application If the alpha blending feature is not enabled this buffer will not be allocated Blur is mainly used for video stream privacy protection Users can insert multiple blur areas into a video stream to protect the privacy areas Once blur areas are inserted the covered areas in the video stream will be severely blurred The default configuration for blur is 0 MB for CV2x chips blur is disabled by default Users can change the blur size to meet their application requirements The blur size consists of two parts BLUR_CONTENT_SIZE and BLUR_RSV_SIZE The BLUR_RSV_SIZE is used to store the blur color table and blur commands Its size is fixed at 5 0 k The BLUR_CONTENT_SIZE is based on the largest blur area size The largest blur area size can be described as width x height BLUR_CONTENT_SIZE ROUND_UP width 8 6 4 x height 8 The size of the blur buffer can be specified in three stages Compile stage Configures the multi-color buffer size through then compiles it into the image For Cooper Amba build For Cooper Yocto build Driver installation stage Configures the blur buffer size through the driver module parameter Run-time stage Configures resizes the blur buffer through IAV IOCTL IAV_IOC_ALLOC_MEM_PART and IAV_IOC_FREE_MEM_PART simultaneously while the system is running If the system does not use the stream blur feature users can disable it through or the driver module parameter in order to reduce the DRAM size Arbitrary blur is used mainly for video stream privacy protection Users can insert multiple blur areas into a video stream to protect the privacy areas Once blur areas are inserted the covered areas in the video stream will be blurred severely Compared with blur arbitrary blur offers users more flexibility Arbitrary blur also allows users to customize their blur area shapes through changing specified blur area memory The default configuration for arbitrary blur is 0 MB for CV2x chips which means arbitrary blur is disabled by default Users can change the arbitrary blur size to meet their application requirements The single largest arbitrary blur area size can be described as Single_arbitrary_blur_size_x ROUND_UP width 8 6 4 height 8 ring_buffer_num x 0 1 2 stream_y _arbitrary_blur_size â Single_arbitrary_blur_size_x x 0 1 2 total_arbitrary_blur_size â stream_y _arbitrary_blur_size y 0 1 2 is the serial number of arbitrary blue area and is the serial number of stream Single_arbitrary_blur_size_x The arbitrary blur size for the single area which the serial number is x stream_y _arbitrary_blur_size The arbitrary blur size for the single stream which the serial number is y total_arbitrary_blur_size The totally needed arbitrary blur size The size of the blur buffer can be specified in three stages Compile stage Configures the multi-color buffer size through then compiles it into the image For Cooper Amba build For Cooper Yocto build Driver installation stage Configures the blur buffer size through the driver module parameter Run-time stage Configures resizes the blur buffer through IAV IOCTL IAV_IOC_ALLOC_MEM_PART and IAV_IOC_FREE_MEM_PART simultaneously while the system is running If the system does not use the stream blur feature with arbitrary shape users can disable it through or the driver module parameter in order to reduce the DRAM size Digital signal processor DSP partition includes the DSP Buffer DEF_CMD UCODE DSP_LOG DSP_RSV and more as shown in the following figure Detailed DSP Partition Allocation The DSP partition is composed of the DSP buffer and other fixed-size sub-partitions including the DEF_CMD 1 6 KB ucode firmware 1 0 MB the DSP log buffer 5 1 2 KB the DSP reserved buffer KB and more The DSP buffer can be resized depending on the VIN resolution channel number encode mode stream number stream resolution and other required values On the CV5x EVK board the size of the DSP buffer has been set to 2 8 1 6 MB to accommodate most use cases After entering the preview encoding state users can input command to check the actual DSP buffer size used by DSP This is also the minimum DSP buffer size to run the current case See the following result handle_dsp_cfg_msg(131) DSP DRAM Used 3 9 3 MB Limited size is defined as the total DSP buffer size With the minimum required DSP buffer size 3 9 3 MB reported by DSP users can accommodate the current DSP buffer size 2 8 1 6 MB to meet the minimum requirements of their use cases The minimum required DSP buffer size depends on various DSP configurations such as encode mode VIN resolution and HDR linear mode EIS delay count VIN back pressure margin canvas size and number and maximum stream size and number For each canvas the buffer pool is maintained by the DSP The buffer number of the buffer pool depends on the canvas extra buffer and the encode dummy latency By default with no extra buffer or encode dummy latency each canvas buffer pool has a minimum of 4 canvas buffer items costing 4 x the canvas size memory As each canvas and stream costs considerable DRAM space disabling unnecessary canvases and streams is highly recommended to reduce DRAM utilization The following table shows the extra DRAM consumption for different options Details of the DSP Buffer Size-Related Options Option DRAM Size Canvas extra buffer Canvas size Encode dummy latency Canvas size EIS delay count VIN frame size The size of the DSP buffer can be specified in two stages Compile stage Sets the extra raw buffer size through then compiles it into the image For Cooper Amba build For Cooper Yocto build Driver installation stage Configures the DSP buffer size through the driver module parameter The following examples show the total DSP DRAM usage for typical use cases The sub-partitions of CV partition can be divided into two categories CMD MSG LOG and ucode which are reserved for internal use and the remaining USR sub-partitions which are allocated and maintained by user applications The sizes of the USR sub-partitions depend on the type of neural network NN deployed by the user applications Detailed CV Partition Allocation The following examples show the total CV DRAM usage for various neural networks is the self-used memory which is about 4 MB is used by which is about 6 4 MB For details please refer to LIBRARY Cavalry_Mem Library API in Doxygen For mask multi-color mask warp and QP matrix QPM partitions the memory layout can be configured according to actual use cases for different customers The memory size of these partitions can be customized gradually according to the memory-related parameters The memory must be configured at the boot stage before the DSP enters the preview state The example below shows how to configure the resource memory layout in the Lua file Usage Sub partition Usage max_chan_num specify the maximum channel number for the PM and WARP memory layout configuration max_stream_num specify the maximum stream number for the QPM memory layout configuration warp_possible specify whether the warp memory needs to be allocated in each channel mask_possible specify whether the privacy mask PM memory needs to be allocated in each channel mask_buf_max_num specify the maximum allocation of PM buffers in each channel 1 is used for user application configuration and the others are used to toggle between IAV and DSP warp_buf_max_num specify the maximum allocated warp buffer number in each channel 1 is used for user application configuration and the others are used to toggle between IAV and DSP warp_area_max_num specify the maximum allocated warp area number in each channel For LDC EIS use cases the maximum number should be one For the dewarp use cases the maximum number of configurations is up to twelve max_vin width height specify the maximum possible VIN input width and height for PM WARP memory allocation qpm_possible specify whether QPM QP matrix memory is needed to allocate in each encode stream qpm_buf_max_num specify the maximum allocated QPM buffer number in each encode stream One is used for user application configuration and the others are used to toggle between IAV and DSP qpm_max_matrix_num specify the maximum allocated QPM matrix number in each encode stream The maximum number can be up to three When the number is one it may mean I P shares the same QP matrix When the number is two it may mean different QP matrixes for I P frames or I P frames share one matrix and B frames use the other one When the number is three it may mean different QP matrixes for I P B frames max_stream width height specify the maximum possible stream width and height for QP matrix memory allocation This section provides common examples of configuring memory layout resource through Lua including warp single-color PM multi-color PM and QPM Unit test commands to configure memory layout resource Typical Lua examples to configure warp single-color PM multi-color PM or QPM memory layout resource The following example shows a warp memory layout resource including three warp buffers one for user app two for IAV DSP usage Each warp buffer supports up to two warp areas The following example shows single-color PM resource memory layout including three single-color PM buffers one for user app two for IAV DSP usage The maximum VIN size is 3 8 4 0 2 1 6 0 The following example shows QPM resource memory layout including three QP matrix buffers one for user app two for IAV DSP usage for each stream Each buffer has three QP matrixes for I P B frames respectively The following example shows the typical user case of disabling warp single-color PM multi-color PM and QPM memory layout through Lua This chapter includes the following sections 3.1 Single 5 MP VIN 3.2 Single 4 K VIN 3.3 Single 8 K VIN 3.4 Quad 5 MP VIN 3.5 Quad 4 K VIN This case has a single 5 MP30 linear VIN input and 5 MP30 AVC 1 0 8 0 p30 AVC+ 5 MP1 MJPEG streams on encode mode 5 The largest overlay area is full screen 2 5 9 2 x 1 9 4 4 and the single-color privacy mask covers the full VIN 2 5 9 2 x 1 9 4 4 Both CV5 and CV72 are used single core for IDSP and encoder If CV5 uses dual core for IDSP and encoder CV5 may take more DRAM size than CV72 The Lua script can be found here Single 5 MP VIN Case Memory Allocation for IAV and DSP Major Sub1 Sub2 CV5 CV72 IAV DSP Total Size 4 1 8 MB 4 1 8 MB DSP DSP_BUFFER 2 6 8 MB 2 8 7 MB DSP DSP_DEF_CMD 1 6 KB 3 2 KB DSP DSP_LOG 4 MB 4 MB IAV Quant 1 2 KB 1 2 KB DSP DSP Reserved 1 2 0 4 KB 2 1 4 8 KB DSP DSP_UCODE 1 1 MB 1 1 MB IAV IMG 6 5 MB 6 5 MB IAV BSH 1 6 KB 1 6 KB IAV IAV Reserved 3 1 6 0 KB 5 MB IAV BSB 3 2 MB 1 0 MB IAV Overlay 1 1 MB 1 1 MB IAV QP matrix 1 3 MB 1 3 MB IAV Privacy Mask 1 0 MB 8 MB This case uses a single 4 Kp30 linear VIN input and 4 Kp30 AVC 1 0 8 0 p30 AVC 4 Kp1 MJPEG streams on encode mode 5 The largest overlay area is full screen 3 8 4 0 x 2 1 6 0 and the single-color privacy mask covers the full VIN 3 8 4 0 x 2 1 6 0 Both CV5 and CV72 are used single core for IDSP and encoder If CV5 uses dual core for IDSP and encoder CV5 may take more DRAM size than CV72 The Lua script can be found here The following table lists the case for IAV DSP DRAM layout Single 4 K VIN Case Memory Allocation for IAV and DSP Major Sub1 Sub2 CV5 CV72 IAV DSP Total Size 5 2 1 MB 5 0 8 MB DSP DSP_BUFFER 3 5 3 MB 3 6 7 MB DSP DSP_DEF_CMD 1 6 KB 3 2 KB DSP DSP_LOG 4 MB 4 MB IAV Quant 1 2 KB 1 2 KB DSP DSP Reserved 1 2 0 4 KB 2 1 4 8 KB DSP DSP_UCODE 1 1 MB 1 1 MB IAV IMG 6 5 MB 6 5 MB IAV BSH 1 6 KB 1 6 KB IAV IAV Reserved 3 1 6 0 KB 5 MB DSP DSP_FIFO 6 0 KB 7 6 KB IAV BSB 3 2 MB 1 0 MB IAV Overlay 1 7 MB 1 7 MB IAV QP matrix 1 3 MB 1 3 MB IAV Privacy Mask 2 1 MB 1 2 MB This case uses a single 8 KP30 linear VIN and 8 KP30 AVC stream on encode mode 0 The largest overlay area is full screen 7 6 8 0 x 4 3 2 0 and the single-color privacy mask covers the full VIN 7 6 8 0 x 4 3 2 0 Due to the HW limitation CV72 can only support 8 KP AVC and 8 KP MJPEG encode at low frame rate it cannot support 8 KP HEVC encode Both CV5 and CV72 are used single core for IDSP and encoder If CV5 uses dual core for IDSP and encoder CV5 may take more DRAM size than CV72 The Lua script can be found here The following table lists the case for IAV DSP DRAM layout Single 8 K VIN Case Memory Allocation for the IAV and DSP Major Sub1 Sub2 CV5 CV72 IAV DSP Total Size 9 5 6 MB 9 2 4 MB DSP DSP_BUFFER 7 1 5 MB 7 3 2 MB DSP DSP_DEF_CMD 1 6 KB 3 2 KB DSP DSP_LOG 4 MB 4 MB IAV Quant 1 2 KB 1 2 KB DSP DSP Reserved 1 2 0 4 KB 2 1 4 8 KB DSP DSP_UCODE 1 1 MB 1 1 MB IAV IMG 6 5 MB 6 5 MB IAV BSH 1 6 KB 1 6 KB IAV IAV Reserved 3 1 6 0 KB 5 MB IAV BSB 3 2 MB 1 0 MB IAV Overlay 3 2 MB 3 2 MB IAV QP matrix 1 3 MB 1 3 MB IAV Privacy Mask 7 9 MB 4 8 MB This case has dual 5 MP30 linear VIN and dual 5 MP30 AVC streams on encode mode 5 If four streams need overlay and single-color PM the largest overlay area must be full screen 2 5 9 2 x 1 9 4 4 and the single-color privacy mask covers the full VIN 2 5 9 2 x 1 9 4 4 Both CV5 and CV72 are used single core for IDSP and encoder If CV5 uses dual core for IDSP and encoder CV5 may take more DRAM size than CV72 The Lua script can be found here The following details show the memory allocation of the IAV DSP sub-partitions Note that the memory sizes listed in the following table are 4 KB-aligned IMG calculation 8 x 4 1 2 1 MB QPMATRIX calculation 1 2 8 x 2 0 x 1 4 1 0 MB Overlay calculation ROUND_UP(2592, 64) x 1 9 4 4 x 2 ROUND_UP(1920, 64) x 1 0 8 0 1 9 MB Mask calculation ROUND_UP 2 5 9 2 8 6 4 x 1 9 4 4 x 1 4 x 4 1 0 MB The following table lists the IAV DSP DRAM layout Quad 5 MP VIN Case Memory Allocation for the IAV and DSP Major Sub1 Sub2 CV5 CV72 IAV DSP Total Size 7 3 4 MB 7 4 4 MB DSP DSP_BUFFER 5 7 6 MB 5 9 9 MB DSP DSP_DEF_CMD 1 6 KB 3 2 KB DSP DSP_LOG 4 MB 4 MB IAV Quant 1 2 KB 1 2 KB DSP DSP Reserved 1 2 0 4 KB 2 1 4 8 KB DSP DSP_UCODE 1 1 MB 1 1 MB IAV IMG 6 5 MB 6 5 MB IAV BSH 1 6 KB 1 6 KB IAV IAV Reserved 3 1 6 0 KB 5 MB IAV BSB 3 2 MB 1 0 MB IAV Overlay 1 9 MB 2 0 MB IAV QP matrix 1 3 MB 1 3 MB IAV Privacy Mask 1 0 MB 1 5 MB This case uses the quad 4 KP30 linear VIN and quad groups streams on encode mode 5 If 1 2 x streams must use the overlay and a single-color PM the largest overlay area must be full screen 3 8 4 0 x 2 1 6 0 and the single-color privacy mask must cover the full VIN 3 8 4 0 x 2 1 6 0 Due to the HW limitation CV72 can only support quad 4 K HEVC encode at lower frame rate but not 3 0 fps Both CV5 and CV72 are used single core for IDSP and encoder If CV5 uses dual core for IDSP and encoder CV5 may take more DRAM size than CV72 The Lua script can be found here The following table lists the IAV DSP DRAM layout Quad 4 K VIN Case Memory Allocation for the IAV and DSP Major Sub1 Sub2 CV5 CV72 IAV DSP Total Size 1 0 1 5 MB 1 0 3 5 MB DSP DSP_BUFFER 8 3 3 MB 8 4 5 MB DSP DSP_DEF_CMD 1 6 KB 3 2 KB DSP DSP_LOG 4 MB 4 MB IAV Quant 1 2 KB 1 2 KB DSP DSP Reserved 1 0 2 4 KB 2 1 4 8 KB DSP DSP_UCODE 1 1 MB 1 1 MB IAV IMG 6 5 MB 6 5 MB IAV BSH 1 6 KB 1 6 KB IAV IAV Reserved 3 1 6 0 KB 5 MB IAV BSB 3 2 MB 1 0 MB IAV Overlay 3 1 MB 3 2 MB IAV QP matrix 1 3 MB 1 3 MB IAV Privacy Mask 2 1 MB 4 8 MB As bandwidth is an important data parameter it is important to note bandwidth limitations The following sections list the bandwidth limitations for the CV chip line 4.1 CV5 Bandwidth Limitation 4.2 CV52 Bandwidth Limitation 4.3 Bandwidth Optimization List of the Ambarella CV5 Bandwidth Limitations with LPDDR5 Chip ID CV5S66 CV5S88 DDR frequency 2 6 4 0 MHz 2 8 0 8 MHz Bitwidth 6 4 bits 6 4 bits DDR efficiency 4 0 4 0 Bandwidth 1 6 1 1 3 MB/s 1 7 1 3 8 MB/s List of the Ambarella CV5 Bandwidth Limitations with LPDDR4x Chip ID CV5S66 CV5S88 DDR frequency 1 8 0 0 MHz 1 8 0 0 MHz Bitwidth 6 4 bits 6 4 bits DDR efficiency 4 0 4 0 Bandwidth 1 0 9 8 6 MB/s 1 0 9 8 6 MB/s Refer to the computational formula provided below Bandwidth DDR Frequency x Bitwidth 8 x 2 x DDR Efficiency 1 0 0 1.024 1.024 Using the CV2 Chestnut board as an example the following shows the total DSP DRAM bandwidth for some of the typical use cases List of the Ambarella CV52 Bandwidth Limitations with LPDDR5 Chip ID CV52S66 CV52S33 DDR frequency 2 6 4 0 MHz 2 6 4 0 MHz Bitwidth 3 2 bits 3 2 bits DDR efficiency 4 0 4 0 Bandwidth 8 0 5 6 MB/s 8 0 5 6 MB/s List of the Ambarella CV52 Bandwidth Limitations with LPDDR4x Chip ID CV52S66 CV52S33 DDR frequency 1 8 0 0 MHz 1 8 0 0 MHz Bitwidth 3 2 bits 3 2 bits DDR efficiency 4 0 4 0 Bandwidth 5 4 9 2 MB/s 5 4 9 2 MB/s Refer to the computational formula provided below Bandwidth DDR Frequency x Bitwidth 8 x 2 x DDR Efficiency 1 0 0 1.024 1.024 Using the CV52 Zr board as an example the following shows the total DSP DRAM bandwidth for typical use cases The following guidelines provide users with details to optimize the DRAM bandwidth Canvas Larger canvas size costs more DRAM bandwidth Users should choose the suitable canvas size and disable unused canvases to save the DRAM bandwidth Pyramid The pyramid buffer usually is used by the CV algorithm It supports up to 6 x layers with various resolutions and each layer can be independently enabled or disabled Users can disable the unnecessary layers to save the DRAM bandwidth In addition using the pyramid manual-feed mode is recommended whenever the user application can control the feeding frame rate of the pyramid If the processing frame rate of CV algorithm is lower than the VIN frame rate the user application can lower this rate to reduce the DRAM bandwidth MCTF compression This option can be enabled through setting to 1 in the section of the Lua script It is enabled by default to reduce the DRAM bandwidth Raw compression This option can be enabled through setting the to 0 in the section of the Lua script By default raw compression is enabled to reduce the DRAM bandwidth Users can disable it to dump the sensor raw data for debugging purposes Raw pack mode This option can be enabled through setting to 1 in the section of the Lua script Users can enable this option to generate the packed raw image which uses a lower DRAM bandwidth than the uncompressed raw image Note that the raw pack mode and raw compression cannot be enabled simultaneously Copyright C 2 0 2 4 Ambarella International LP This file and its contents are protected by intellectual property rights including without limitation U.S and/or foreign copyrights This Software is also the confidential and proprietary information of Ambarella International LP and its licensors You may not use reproduce disclose distribute modify or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates In the absence of such an agreement you agree to promptly notify and return this Software to Ambarella International LPã THIS SOFTWARE IS PROVIDED AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS COMPUTER FAILURE OR MALFUNCTION OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">page_sysdoc_amboot_doc</field>
    <field name="url">d6/d3a/page_sysdoc_amboot_doc.html</field>
    <field name="keywords"></field>
    <field name="text">BASE AMBoot BASE AMBoot Library Version Updated Date Modification 1.0.0 2 0 2 0 1 1 1 7 Initial draft There s a folder in SDK that contains AMBoot documents which can help users to better understand related topic They are located in SDK/ambarella/amboot/doc amrtos.txt boot_command.txt bstiniparser.txt dram_shmoo.txt env.txt flexible_firmware.txt lfat.txt mem_layout.txt multi_bstini.txt ptb_backup.txt recovery.txt sdmmc.txt secure_boot.txt stack_boot.txt Below are some documents regarding different aspects of BST and system memory Bstiniparser.txt introduces parameters needed in BST dram parameters are important part of this document If dram shmoo tool is needed it is highly recommended to read this document before Dram_shmoo.txt introduces the usage of the tools to tune dram parameters in order to get a better and more stable dram performance There are 2 tools acting for different roles dram_preliminary_shmoo would give a parameters combination when system loading is relative low dram_advanced_shmoo is trying to found a better parameters combination when system is in heavy loading status For some cases one BST needs to support several sets of boot parameters so that a single BST can run on several different boards Multi_bstini.txt introduces how to configure single BST with multiple ini files AMRTOS is a lite OS in Amboot It supports mutiple threads mutiple cores spin lock mutex semaphore and event mechanism Amrtos.txt describes some details about AMRTOS It is helpful for developer to program some software on it The Secure Boot is to authenticate the image of each booting stage include BST BL2 BL31 BL32(Optee) and BL33(Amboot) The system with security feature is ususally divided into secure world and non-secure world The Secure Device is protected from access by non-secure world That is once a device is configured as a secure device kernel and application which are in non-secure world cannot directly access the registers belong to this secure device Secure_boot.txt introduces secure boot and secure devices Mem_layout.txt introduces memory layout with different arm_tf componets combinations Amboot BL2 BL31 BL33(Amboot) BL2 BL31 BL33(Amboot) Image Signature BL2 BL31 BL33(Amboot) Image Signature DTB Signature BL2 BL31 BL32 BL33(Amboot) Image Signature DTB Signature For more details regarding security uses can refer to Ambarella Flexible Linux SDK Security Documents EVK boards usually set nand flash as default storage for binaries but our system support eMMC as boot media Spinor flash together with eMMC is also supported which is callled stack mode Sdmmc.txt introduces eMMC SD card and SDIO controller Stack_boot.txt introduces how to use this kind of storage solution Besides those partitions which save the system image like BST BLD LNX etc there are some partitions acting different roles which can be chosen according to usage BAK partition is used for system recovery PTB partition is used to save PTB and second/backup PTB ENV partition is used to store environment variables used by Amboot ENV partition need to work with flexible firmware layout Recovery.txt introduces the recovery flow of SDK and usage of BAK partition Ptb_backup.txt introdcues the ptb backup mechanism in PTB partition Env.txt introduces environment partition which is uesd to store environment variables used by Amboot Traditional firmware layout consists of fixed partition combinations It is not allowed to change or add partition Flexible firmware is introduced to bring more flexibility into firmware layouts Flexible_firmware.txt introduces this solution LFAT means lightweight FAT file system It is used as a read-only file system in Ambarella practice Lfat.txt introduces usage of Lightweight FAT file system Copyright c 2 0 2 4 Ambarella International LP This file and its contents are protected by intellectual property rights including without limitation U.S and/or foreign copyrights This Software is also the confidential and proprietary information of Ambarella International LP and its licensors You may not use reproduce disclose distribute modify or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates In the absence of such an agreement you agree to promptly notify and return this Software to Ambarella International LP THIS SOFTWARE IS PROVIDED AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS COMPUTER FAILURE OR MALFUNCTION OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">test_sensor_calib.c</field>
    <field name="url">d7/d83/test_sensor_calib_8c-example.html</field>
    <field name="keywords"></field>
    <field name="text">This is a source code file of test_sensor_calib</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">page_sensor_calib_user_guide_doc</field>
    <field name="url">d9/d68/page_sensor_calib_user_guide_doc.html</field>
    <field name="keywords"></field>
    <field name="text">DESIGN Multiple Sensors Calibration DESIGN Multiple Sensors Calibration Tool Name Tool Version Updated Date Tool Platform Modification Lens_calib 0.0.1 2 0 2 1 0 9 0 2 armv8-a x86 Initial Version Lens_calib 0.1.2 2 0 2 1 0 9 2 1 armv8-a Refine lens calibration flow Lens_calib 2.0.1 2 0 2 1 0 9 2 4 x86 Added Section Structured-light Parameters Pose Calibration Lens_calib 2.0.2 2 0 2 1 1 1 0 2 x86 Add support for Temperature Calibration Lens_calib 2.0.2 2 0 2 1 1 1 2 4 armv8-a x86 Updated Section Lens Calibration Lens_calib 2.0.2 2 0 2 1 1 2 0 7 armv8-a x86 Updated Section Lens Calibration Flow Lens_calib 2.0.3 2 0 2 1 1 2 1 0 armv8-a x86 Updated Section Lens Calibration Flow Lens_calib 2.0.3 2 0 2 1 1 2 1 0 armv8-a x86 Updated Section Multi-Sensor Stitching Pose Calibration Tool Lens_calib 2.0.3 2 0 2 1 1 2 1 6 armv8-a x86 Updated Section Introduction Lens_calib 2.0.4 2 0 2 1 1 2 1 6 armv8-a x86 Updated Section Lens Calibration Flow Lens_calib 2.0.4 2 0 2 1 1 2 1 6 armv8-a x86 Updated Section Calibration Preparation Work Lens_calib 2.0.4 2 0 2 2 0 1 1 9 armv8-a x86 Updated Section Lens Calibration Lens_calib 2.0.4 2 0 2 2 0 1 1 9 armv8-a x86 Updated Section Stitching Pose Calibration Lens_calib 2.0.4 2 0 2 2 0 1 2 4 armv8-a x86 Updated Section Sensor Calibration FAQ Lens_calib 2.0.4 2 0 2 2 0 1 2 6 armv8-a x86 Updated Section Sensor Calibration FAQ Lens_calib 2.0.5 2 0 2 2 0 1 2 7 armv8-a x86 Updated Section Lens Calibration Lens_calib 2.0.5 2 0 2 2 0 2 1 1 armv8-a x86 Updated Section Lens Calibration Lens_calib 2.0.5 2 0 2 2 0 2 1 7 armv8-a x86 Updated Section Lens Calibration Pose_calib 1.0.0 2 0 2 2 1 1 3 0 armv8-a x86 Updated Section Dual-fisheye back to back Pose Calibration Lens_calib 2.0.6 2 0 2 2 1 2 0 1 armv8-a x86 Updated Section Lens Calibration Lens_calib 2.0.7 2 0 2 3 0 2 0 6 armv8-a x86 Updated Section Lens Calibration Lens_calib 2.0.8 2 0 2 3 0 2 0 8 armv8-a x86 Updated Section Lens Calibration This chapter introduces the basic information on different sensor calibrations Section Section Section Section Section Section Section Section Section Section 2.1.1 Host Calibration Tool 2.1.2 Board Calibration Tool 2.1.3 Pattern Preparing Work Host calibration tool supports the following features The host calibration tool is used to manage time-consuming problems Ambarella supports performing both lens and pose calibration on the PC Linux side and on the Windows side Ambarella recommends performing lens pose calibration on the PC Windows side to save environment installation time 1 PC Windows side lens calibration tool Windows environment Win10 x64 Lens calibration tools cv2x_cv5x_lens_calibration_tool_for_windows_vx.x.x_x.tar.bz2 Pose calibration tools cv2x_cv5x_pose_calibration_tool_for_windows_vx.x.x_x.tar.bz2 If users want to perform calibration on the PC Windows side they must ask the Ambarella support team for the required tools 2 PC Linux side lens calibration tool The lens calibration tool is in the path below ambarella/prebuild/ambarella/library/multi_sensor_calib/host_calib_tool Some descriptions of the key libraries of the calibration are as follows Name Version Calibration type OpenCV 3.2.0 ALL Apriltag 2 0 1 8 1 1 2 9 Lens multi-sensor pose structured-light pose calibration Ceres solver 1.14.0 Binocular Python 2.7 ToF Matplotlib ToF Install the dependency libraries The calibration is based on the OpenCV 3.2.0 version Ensure that the correct version for OpenCV is installed on the host Ubuntu building machine Use the following reference to install the OpenCV package First download the opencv3.2.0.tar.gz source code package from the website Users should also install the apriltag library to use the circle target and the version should be apriltag-2018-11-29 Save the library in the path multi_sensor_calib/host_calib_tool/third_party Compress it and run as follows If users want to perform binocular calibration Ceres Solver is required for installation Ceres Solver is used for optimization download it from Ambarella uses version 1.14.0 Some dependencies can be refered to host_tool_install.sh Compress it and run If users want to perform time of flight ToF calibration users must install the library Libsensor_calib.so is the tool which supports the following features The calibration tool should be configured in menuconfig Follow the instructions as shown below For CV2x SDK 3 0 Amba build For Cooper Amba build The board calibration tool is in the path ambarella/prebuild/ambarella/library/multi_sensor_calib/lib/armv8-a/ The source code of application is in the path ambarella/unit_test/private/package_test/arch_v5/test_sensor_calib.cpp Users require different patterns for different calibrations Some descriptions of the key points detection method of the calibration are as follows Calibration Type Tool Pattern Lens Circle board chessboard ToF Laser board chessboard RGBD chessboard Stitch pose Circle board chessboard Thermal-RGB Choose the points manually Mono-RGB Akaze algorithm to detect the keypoints automatically Structured-light Circle board Figure 2-1 Circle Pattern Figure 2-2 Chess Pattern In order to maintain accuracy Ambarella recommends following the rules below Paste the pattern flat on the board Use sufficient amounts of light The circle pattern image shows each calibration board contains four April tags and many circles Key notes for the circle board The diameter of each circle in the picture is between 1 5 and 2 0 pixels 2 0 is ideal 1 0 2 0 is also sufficient A larger size can cause loss in accuracy Ambarella recommends using at least one April tag in each image When the pattern board is sufficiently rigid and flat users should use a ruler to measure the horizontal length width between the horizontal triangle strip-line symbols and the vertical length height between the vertical triangle strip-line symbols Based on this data users can obtain an average distance between the adjacent circles for the horizontal and vertical directions in order to increase accuracy The example below is in meters Horizontal spacing width 4 6 Vertical spacing height 3 2 Lens calibration Fill the spacing command information for the application in run_xx_circle_xx.bat Pose calibration Fill the spacing command information for the application in sensor_calib_ini_pose_calibration_save_target_xx.ini or command line directly This chapter describes the following concepts 3.1 Lens Calibration Principle 3.2 Lens Calibration Tool 3.3 Lens Calibration Flow 3.4 Lens Calibration Result Users should perform lens calibration to remove distortions because there are radial and tangential distortions for each lens Figure 3-1 Distortion for Lens The image above shows that the table will be twisted because of lens distortion This chapter provides information on how to perform lens calibration Ambarella supports performing lens calibration on both the PC Linux side and on the Windows side Users can obtain lens calibration applications for the Windows side in the path below Environment Win10 x64 Tool cv2x_cv5x_lens_calibration_tool_for_windows_vx.x.x_x.tar.bz2 Multi-channel stitching lens calibration strategy Ambarella recommends performing full calibration for the specific lens with 6 0 images and perform fast calibration for the other channel as in case 7 mentioned above the results of full calibration are used as initial parameters to estimate other lenses Figure 3-2 Calibration for Pinhole Lens 1 Capture image sets The image above shows some pattern s positions when users perform the calibration Ambarella suggests using the Zhang Zhengyou calibration method for pinhole and fisheye lens It is recommended to use omnidirectional calibration method when the FoV is greater than 1 8 0 degrees The calibration process requires users to capture more than 6 0 pictures as shown in the image Key points for lens calibration The diameter of each circle in the picture is between 1 5 and 2 0 pixels 2 0 is ideal 1 0 2 0 is also sufficient A larger diameter will cause loss in accuracy Ambarella recommends using at least one April tag for each image Cover images in different parts of the FoV If users must quickly perform calibration Ambarella recommends covering many targets in the image The tool supports both chessboard and circle patterns to perform calibration Ambarella recommends capturing images at three different distances such as 1.5 2 2.5 meters Move the board in different angles pitch roll yaw however the angles should not be too large Refer to the image above The tool supports performing lens calibration with multiple patterns in one image For CV2x the user should copy get_frame.sh and calib_3x_chan.lua lua to the directory of the board For CV5x the user should copy yuv_capture.sh and cv5x_4vin_capture_yuv.lua to the directory of the board yuv_capture.sh is used to capture YUV data for each channel The scripts creates in ambarella/prebuild/ambarella/library/multi_sensor_calib/host_calib_tool/script/stitch/cvxx/capture CV2x CV5x This script will create sub-folders under the folder with the name After the picture capture process is complete copy the calib_data folders to the building machine in the folder Commands are as follows 2 Perform the full lens calibration at the PC Windows side Some descriptions of the parameters can be found in Options Tool Pattern opt Specify the focal length of the lens mm x 1 0 cel_size Specify the cell size of the sensor debug Bit 0 show outlier information Bit 1 show undistorted image Bit 2 show tag information Bit 3 show grid image Bit 4 show circle object information chess_w chess_h Specify the chessboard width height start end Specify the start end index for lens calibration pic_format Specify the pictures format input_folder Specify the folder of the format images tag_info_list Set the April tag information dst Set the maximum distance in circle detection yuv_w yuv_h Set the YUV width height read_calib Specify performance of fast lens calibration fix_distort Specify use of full lens calibration s distortion parameters expand_fov 0 normal intrinsic parameters 1 horizontal optimization parameters 2 vertical optimization parameters 3 horizontal optimization k1 k2 k3 k4 k5 k6 k7 Set the distortion parameter to 0 Ambarella suggests setting k4 k5 k6 when the lens is a low-distortion pinhole lens save_undistort_map Specify saving the undistorted x/y map slope_ratio Set the maximum slope difference with the basis when removing the wrong connection start_ratio Set the vector maximum ratio when detecting the origin line_ratio Set the threshold of removing the wrong connection in the incline direction min_area Set the threshold for detecting small radius circle on the calibration pattern lens_mode Set the lens calibration mode 0 fisheye KB mode 1 fisheye MEI mode 2 fisheye OCAM mode 3 PINHOLE map_align Specify the alignment for the undistorted x/y map to be saved The intrinsic parameters for specified lens will be stored in the relative path lens_calib1/out/front_end/intrinsic_0 3 Perform the fast lens calibration at the PC Windows side using a four-channel stitching as an example Fast calibration uses the full calibration s intrinsic as initial parameters to estimate the other lens The tool supports performing fast calibration with only a few images 3 4 Ambarella recommends placing the calibration board in the left middle right of the image Figure 3-3 Fast Calibration with Multiple Calibration Boards The tool supports performing fast calibration with many patterns in one image Use different April tag IDs for each calibration board Keep the boards in different angles pitch yaw roll The angles should not be too large refer to the image above Note that if users want to apply lens calibration parameters after fast calibration they must generate pose calibration parameters again for all channels based on new lens calibration parameters Then place all channels results to the folder Copy the folder to the board and apply the parameters then Figure 3-4 Before and After Lens Distortion Calibration The image shows the contrast result after applying the calibration intrinsic and distortion paramters The curved line becomes a straight line This chapter describes the following conceptions 4.1 ToF Calibration Principle 4.2 ToF Calibration Tool 4.3 ToF Calibration Flow 4.4 ToF Calibration Result Users should perform the calibration as shown in the steps below 1 Lens calibration This calibration is used to remove the lens distortion each pixel will be converted into the ideal coordinate in the pin-hole model Refer to 2 Lens Calibration for more details of removing the distortion 2 Temperature calibration There is a phase drift introduced by the temperature It is a linear drift in distance Temperature calibration is used to remove such problem by doing curve-fitting 3 Global calibration There is a global offset between the measured distance and the real distance Users just need the chessboard or some other calibration targets to do extrinsic calibration and get ground truth distance 4 Wiggling calibration The phase delay can not be calculated correctly because the modulation wave shape is not as perfect as the sinusoidal shape The imperfect phase will introduce the wiggling errors for different distances Wiggling calibration is used to remove such problem Path ambarella/prebuild/ambarella/library/multi_sensor_calib/host_calib_tool/bin/x86_64 Path ambarella/prebuild/ambarella/library/multi_sensor_calib/host_calib_tool/script/tof Tool create_xml lens_cali tof_cali do_temp_calib.py It is assumed that the lens calibration has been completed perfectly before this stage the section introduces the flow of ToF calibration 4.3.1 Temperature Calibration 4.3.2 Global Calibration 4.3.3 Wiggling Calibration Temperature calibration performs curve-fitting to find good coefficients used in compensation It is assumed that the calibration data has been stored in accuracy.csv Modify x range(37, 48) in do_temp_calib.py for the specific temperature range from the accuracy.csv file The users can also ignore the bad statics by setting the range Figure 4-1 Temperature Calibration Fitting The first temperature value 3 7 of x range(37, 48) is used as the base and the image shows the fitting result by using the mean distance difference of the base The tool reports the result temp_mean0_base 3 7 temp_mean0_distance 0.12938596591621487 line_slopy 0.00034453650504337203 base is the temperature compensation base of the calibration and are the curve-fitting coefficients used for compensation Fill the parameters and to amba_itof_decoder or amba_itof_dec_for_calib stage in the lc file to perform the temperature compensation There is a global offset between the measured distance and the real distance 1 For the short range 0 1.5 meters Ambarella suggests using a chessboard or some other calibration tools to perform extrinsic calibration and get ground truth distance Users should perform lens calibration first then fill with intrinsic and distortion parameters to the commands below The tools are in the path ambarella/prebuild/ambarella/library/multi_sensor_calib/host_calib_tool Users can perform the calibration and choose one value as the global offset value from the report There are some scripts run_xxx_xxxMHZ.sh in the folder for reference the user can run it by changing some parameters Some descriptions of the options in the script chessboard center numbers in the horizontal direction chessboard center numbers in the vertical direction the side length of a square unit is meter ToF frequency in Hz global-offset value should be 0 for the global calibration The command in the script is as shown below There are many reference calibration command scripts in the path multi_sensor_calib/host_calib_tool/script/tof The tool supports choosing points manually when the image quality is not well detected The selection interface appears when the automatic points fail to extract Figure 4-2 Find Points The image shows how to choose the chessboard cross center manually follow the straight line s direction 2 For the long range greater than 1.5 meters Because it is difficult to find too-large calibration parameters Ambarella recommends that users use a laser to perform the calibration Figure 4-3 Global Offset The image shows how to choose the global offset manually Choose one value from the fitting image such as phase 0.2 offset where is the global compensation value Option in the compensation stage of lc file should be filled with 0.55 Modulation wave shape is not as perfect as the sinusoidal shape so the phase delay will not be calculated correctly and the imperfect phase will introduce the wiggling errors for different distances It will bring wiggling errors Taking multiple images can bring more points and improve the accuracy of fitting results Capture data in small steps from the start to the end position so that it can cover full 3 6 0 degree in phase then perform the wiggling calibration with PC tools with lens calibration results Enter the folder fill with the global offset value as shown in the command below and run the command again The tool will report the following start base 0.000000 end base 1.008698 end off 0.996727 number 6 4 step base 0.01601108 Option in the compensation stage of lc file should be filled with 6 4 Figure 4-4 Wiggling Offset After the calibration the data will vibrate around y 0 axis and a lookup table LUT for specific distance spacing to express distance compensation for different positions will be created After ToF calibration calibration data can be used for the ToF process on the chip The calibration result is listed in the above section This chapter describes the following conceptions 5.1 RGBD Registration Calibration Principle 5.2 RGBD Registration Calibration Tool 5.3 RGBD Registration Flow 5.4 RGBD Registration Result Depth-sensing cameras have made it possible to use 3 D point clouds in many fields of reasearch and industry The 2 D RGB cameras are used by many algorithms to perform detection and classification The proposed solution provides a mechanism to calibrate RGB and depth cameras s intrinsic paramters and create an aligned matrix With applying the aligned matrix the dpeth image could be converted to the RGB s view in real time Path ambarella/prebuild/ambarella/library/multi_sensor_calib/host_calib_tool/bin/x86_64 Tool binocular_cali Figure 5-1 RGBD Calibration Image The image shows the calibration RGB and ToF amplitude images The flow of calibration is performed in the steps below 1 Use the Amage tool to read configurations and adjust 3 A for amplitude image 2 Capture the RGB ToF amplitude calibration dataset Key points for RGBD calibration The calibration process requires users to capture more than 6 0 pictures as shown in the image Keep images covered different parts of FoV Ambarella recommends using a chessboard to perform calibration Ambarella recommends capturing images at three different distances such as 1.5 1.8 2 meters capture many images at a fixed distance 1.5 meters and capture three images at a far distance 1.8 2 meters Keep the board in different angles pitch yaw roll Ensure that the chessboard is complete in the two channels images 3 Perform the RGBD registration calibration Calibration algorithm is performed as described below 1 Perform lens calibration for each lens The intrinsic distortion parameters will be stored in the debug/front_end folder 2 Perform binocular calibration to get the alignment matrix between RGB and ToF sensors Lens calibration results will be used as the initial values for binocular calibration they could be fixed via the option The alignment matrix parameters will be stored in the debug/front_end folder Options descriptions is used to fix the distortion parameters from the lens calibration stage in binocular calibration is used to calculate the alignment matrix parameters is used to set numbers of distortion paramters is used to set the width of the chessboard is used to set the height of the chessboard Figure 5-2 RGBD Registration As shown in the image the depth image is aligned to the RGB sensor and pasted on the RGB s view with overlay This chapter describes the following concepts using a four-channel stitching case as an example 6.1 Multi-sensor Stitching Pose Calibration Principle 6.2 Multi-sensor Stitching Pose Calibration Tool 6.3 Stitching Pose Calibration Flow 6.4 Multi-Channel Stitching Example 6.4.1 Four-channel Stitching Example Homograpy matrix is used to express the transformation between two image planes The calibration is used to get the homograpy matrix and project each channel to the middle image channel It is assumed that users did lens calibration before this calibration stage After the pose calibration users can get the message of configuration offset width height for each channel For pose calibration Ambarella supports performing pose calibration both on PC Windows side and board side Users can get pose calibration application for Windows side in the path below Environment Win10 x64 Tool cv2x_cv5x_pose_calibration_tool_for_windows_vx.x.x_x.tar.bz2 Board side path ambarella/prebuild/ambarella/library/multi_sensor_calib/lib/armv8-a Tool libsensor_calib.so Application ambarella/packages/sensor_calib_ini_parser/arch_v5/unit_test/test_sensor_calib.c 1 Capture image sets Figure 6-1 Camera Set and Calibration Board Layout The figure above shows the relative position of camera set and calibration board when users perform the pose calibration Key points of capturing image sets for pose calibration are listed below 1 Fix three calibration boardsâ distance from the middle line of each group of two adjacent lens to the same 1.5 meters 2 Make sure each calibration board can be perpendicular to the middle line as far as possible 3 Totally capture four images the schematics images are shown below for four lenses respectively 4 As figures and shown the overlapping part view of two adjacent channels must have circles of the calibration board Figure 6-2 Four-lens Schematic Images 2 Perform the pose calibration As users refer to 3.3 Lens Calibration Flow to get x 0 1 2 3 in the stage of lens calibration Users can do pose calibration with the process below both at PC Windows side and board edge side Users can perform pose calibration with the process below both at PC Windows side and board edge side Compared with performing pose calibration at the board-edge side performing pose calibration on the PC Windows-side is faster and more convenient However users may be required to change the specific distance dynamically For such a situation it is preferred to select board-edge side pose calibration Here Ambarella lists the commands at both the Windows side and the board-edge side Users can choose either to perform pose calibration PC Windows side Figure 6-3 Source Buffer Configurations The board edge side The method for configuring the source buffer is the same as that for PC Windows side The commands below demonstrate how to set up a four-channel stitching case CV2x The image below shows the contrast result for 4 channels stitching case after applying the pose calibration paramters Figure 6-4 Before vs After Pose Calibration For more principles of stitching sensor calibration and stitching LDC alignment please refer to links below Sensor Calibration Library API Stitch Library API This chapter describes the following conceptions 7.1 Thermal-RGB Fusion FoV-Alignment Calibration Principle 7.2 Thermal-RGB Fusion FoV-Alignment Calibration Tool 7.3 Thermal-RGB Fusion FoV-Alignment Calibration Flow 7.4 Thermal-RGB Fusion FoV-Alignment Calibration Result Figure 7-1 Thermal RGB Align Calibration For the majority of use cases users will have to align the FoV of the thermal image with the RGB image before combining them For example suppose the thermal sensor resolution is 2 5 6 x192 and the RGB sensor resolution is 2 3 3 6 x1752 To align the FoVs between thermal and RGB users will need to get the coordinates of several specified key points for the same target in both sensor s FoVs Path ambarella/prebuild/ambarella/library/multi_sensor_calib/lib/armv8-a Tool libsensor_calib.so Application ambarella/packages/sensor_calib_ini_parser/arch_v5/unit_test/test_sensor_calib.c Refer to Thermal and RGB Sensors Calibration for more details Figure 7-2 Thermal and RGB Alignment The image shows the result between before and after applying the thermal and RGB calibration paramters This chapter describes the following conceptions 8.1 Mono-RGB Fusion FoV-Alignment Calibration Principle 8.2 Mono-RGB Fusion FoV-Alignment Calibration Tool 8.3 Mono-RGB Fusion FoV-Alignment Calibration Flow 8.4 Mono-RGB Fusion FoV-Alignment Calibration Result Figure 8-1 Mono RGB Alignment Calibration For the mono and RGB sensors fusion application users will have to align the FoV of the mono image with the FoV of the RGB image before combining them The proposed solution provides a mechanism for thermal and RGB images alignment automated and much more efficient With the advances in technology mono and RGB alignment can be built to leverage automatic extraction method to reach subpixel pixel level alignment effect Path ambarella/prebuild/ambarella/library/multi_sensor_calib/lib/armv8-a Tool libsensor_calib.so Application ambarella/unit_test/private/package_test/arch_v5/test_sensor_calib.cpp 1 If the user wants to use keypoints automatic detection algorithm to do calibration Just do mono and RGB sensors calibration with following commands 2 If the users have done the calibration by themselves and want to apply homography matrix to the specific channel Refer to Mono and RGB Sensor Calibration for more details Figure 8-2 Mono and RGB Alignment Matching The image shows the keypoints matching the result with mono and RGB sensors calibration This chapter describes the following conceptions 9.1 Structured-light Pose Parameters Calibration Principle 9.2 Structured-light Pose Parameters Calibration Tool 9.3 Structured-light Pose Parameters Calibration Flow 9.4 Structured-light Pose Parameters Calibration Result It is easy to cause an accuracy loss if users use the ruler to measure the baseline between the projector and the RGB sensor The proposed solution provides a mechanism to calculate the structured light s pose parameters with high accuracy With the advances in technology the pose calibration parameters accuracy can reach 0.01 mm Figure 9-1 Structured-light Pose Calibration With the proposed solution the formula to calculate the depth can be expressed as shown in the image above is the disparity is the depth to the specific pattern is the focal length from lens calibration and are the 3 D coordinates based on the camera optical center is the x coordinate in 2 D image Path ambarella/prebuild/ambarella/library/multi_sensor_calib/host_calib_tool/bin/x86_64 Tool sl_cali It is assumed that the lens calibration has been done perfectly before this stage and the images are captured without distortion Users can refer to Lens Calibration for more details of lens calibration Figure 9-2 Structured Light in the First Position Put the structured-light camera in the first position with a certain distance like 4 5 cm to the pattern and capture two YUVs as shown in the image One image has no speckle and the other one has Convert them to the format of BMP The name of one image is base_img.bmp and name of the other image is random_img.bmp Figure 9-3 Structured Light in the Second Position Put the structured-light camera in the second position with a certain distance like 5 5 cm to the pattern and capture two YUVs as shown in the image One image has no speckle and the other one has Convert them to the format of BMP The name of one image is base_img1.bmp and name of the other image is random_img1.bmp Run the command as shown below Tag-info is used to specify the pattern information refer to 2.1.3 Pattern Preparing Work for more details Share-id is used to specify the common April tag corner ID there are four April tags in one image and each tag has its own ID Ensure that at lease one same April tag is visible in the four images The result is shown below is the pose calibration result it contains Tx and Tz Users can apply it to the formula expressed in 9.1 Structured-light Pose Parameters Calibration Principle This chapter describes the following conceptions 10.1 Dual-fisheye Pose Calibration Principle 10.2 Dual-fisheye Pose Calibration Tool 10.3 Dual-fisheye Pose Calibration Flow 10.4 Dual-fisheye Pose Calibration Result Homograpy matrix is used to express the transformation between two image planes The calibration is used to get the homograpy matrix and project each channel to the first image channel After the pose calibration users could get the message of configuration offset width height for each channel Figure 10-1 Dual-fisheye Pose Calibration The ouput is a 3 6 0 x 1 8 0 degree panorama stitched view For pose calibration Ambarella supports to do pose calibration both on PC Windows side and board side Users can get pose calibration application for Windows side from the below path Environment Win10 x64 Tool cv2x_cv5x_pose_calibration_tool_for_windows_vx.x.x_x.tar.bz2 Board side path ambarella/prebuild/ambarella/library/multi_sensor_calib/lib/armv8-a Tool libsensor_calib.so Application ambarella/packages/sensor_calib_ini_parser/arch_v5/unit_test/test_sensor_calib.c 1 If the users want to do the pose calibration with chessboard calibration board The command to run the lens calibration is shown below 2 If the users want to to do the pose calibration without doing lens calibration The users need to find the fisheye circle radius and image center manually Figure 10-2 Fisheye Radius and Center 1 Find the circle center and radius like the picture show Left point coordinate 3 8 0 5 2 8 Right point coordinate 1 4 8 9 5 2 8 Radius 1 4 8 9 3 8 0 2 5 5 4 Center 3 8 0 1 4 8 9 3 8 0 2 5 2 8 9 3 4 5 2 8 2 Run below command to create the undistorted images The undistorted images will be stored in the same folder of the bat files named Figure 10-3 Fisheye Stitching Offset and Corresponding Points 3 Choose the x coordinate offset_0 offset_1 from the image 4 Choose more than 4 pairs of corresponding points from the two undistorted images 5 Fill them into the ini file as shown below 6 Run below command to get the canvas configuration information 3 If users want to to do the pose calibration with choosing the points manually 1 Run below command to create the undistorted images The undistorted images will be stored in the same folder of the bat files named 2 Choose more than 4 pairs of corresponding points in the two undistorted images like above image shown 3 Run below command to create the calibration information The result is shown below Users need to configure the lua script according to the report Answer To assure the lens calibration works well Users need to ensure the following 1 Tool supports circle and chessboard patterns It is more accurate to use circle pattern keep each circle s diameter about 2 0 pixels 2 At least one Apriltag in the image 3 It is better to take snapshots in different distances from close to far with different angles pitch yaw roll cover full FoV 4 Choose the rigid and flat board as a calibration board and make sure RMS is less than 0.4 It is hard to achieve 0.4 if the calibration target s quality is not good enough 5 Measure average distance between two circle centers measuring distance between two tags in the horizontal and vertical direction divided by circle numbers then getting an average value and fill in run_cali.sh 6 Set option as 3.3 Lens Calibration Flow to check the lens calibration quality Answer Users need to capture at least 3 images to perform the fast lens calibration It is suggested to put the pattern in left middle right part of the image refer to the dataset in the cv2x_cv5x_lens_calibration_tool_for_windows_vx.x.x_x.tar.bz2 Answer Yes The lens calibration supports multiple circle patterns in one image Users can set option s bit 2 as 1 to check the tag information Answer To make sure stitch pose calibration works well Users need to ensure the following 1 At least one pair of common April tag in the images 2 The lens calibration result is good Answer 1 If the customer wants to do the pose calibration with a fixed pattern without specifying specific distance It is better to do lens calibration once as distortion parameters are similar for the same type lens Pose calibration must be done for every equipment using the calibration tool on board is faster 2 If the customer wants to do the pose calibration with a fixed pattern specifying certain distance As the image center is different for each channel it is recommended to use more than 6 0 images to do the full lens calibration once to get initial parameters Additionally the lens calibration for each lens with two or three images is performed to estimate the image center Answer If the user is not satisfied with the alignment quality of choosing 4 pairs of key points manually the tools support more pairs of key points to do calibration the more the better It is suggested to choose the points that are uniform and do not cluster together to improve the accuracy Answer Figure 11-1 Image Size Mismatching between Different Channel The image shows the pattern size is mismatching between two channels the root cause is that the calibration intrinsic data s focal length is not similar lens calibration is not performed well For example if one channel s focal lenght is 1 7 5 0 and the other channel s focal length is 1 8 1 0 the difference will be 1 8 0 0 1 7 5 0 1 7 5 0 0.03 So it is necessary to keep the output of the lens calibration s intrinsic parameters are similar when doing the lens calibration Copyright c 2 0 2 4 Ambarella International LP This file and its contents are protected by intellectual property rights including without limitation U.S and/or foreign copyrights This Software is also the confidential and proprietary information of Ambarella International LP and its licensors You may not use reproduce disclose distribute modify or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates In the absence of such an agreement you agree to promptly notify and return this Software to Ambarella International LP THIS SOFTWARE IS PROVIDED AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS COMPUTER FAILURE OR MALFUNCTION OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</field>
  </doc>
  <doc>
    <field name="type">source</field>
    <field name="name">system_chapters_page.h</field>
    <field name="url">d9/da7/system__chapters__page_8h_source.html#l00001</field>
    <field name="keywords"></field>
    <field name="text"></field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">page_sys_mg_cv2x</field>
    <field name="url">d9/dc6/page_sys_mg_cv2x.html</field>
    <field name="keywords"></field>
    <field name="text">Migration Guide From CV2x Migration Guide From CV2x Updated Date Modification 2 0 2 2 0 8 1 2 Initial Version 2 0 2 2 1 0 1 0 Added Section 3.1.6 Arbitrary Image Scaler 2 0 2 2 1 0 2 7 1 Updated Section IOCTL Interface 2 Updated Section Tools 2 0 2 3 0 7 2 5 1 Updated Section 3.1 Application Programming Interface Differences 2 Updated Section 4.5 IAV_IOC_GET_SYSTEM_RESOURCE 2 0 2 3 1 0 2 5 1 Updated Section 6.2 Toolchain for Linux 2 Updated Section 4.5 IAV_IOC_GET_SYSTEM_RESOURCE 2 0 2 4 0 1 0 9 Added Section 3.1.7 Multi-Pass 2 0 2 4 0 1 2 2 1 Added Section 3.1.8 Custom SEI 2 Added Section 3.1.9 RAW fps 3 Updated Section IOCTL Interface This document provides users with instructions for migrating single- and multiple-video input VIN channel designs from the CV2x to the Cooper chip family The Cooper family of chips includes the CV5 CV52 CV72 and CV3 chips The following table lists the main differences between the CV2S88 CV5S66 and CV72S66 chips Table 2 1 Differences Between CV2S88 CV5S66 and CV72S66 Hardware Type CV2S88 CV5S66 CV72S66 Basic Process(nm) 1 0 5 5 CPU Quad-CortexÂ® A53 1.0 GHz 6 4 bits Dual-Cortex A76 1.6 GHz 6 4 bits Dual-Cortex A76 1.6 GHz 6 4 bits Cortex-M3 5 7 6 MHz VIN Native six can future extend by B5 B6 B8 Four independent VINs total of 1 4 VINs can extend via serializer deserializer SERDES Three independent VINs total of ten VINs can extend via SERDES CVflowÂ® processor One One One USB interface 2.0 up to 4 8 0 Mbps 3.2 Gen 2 up to 1 0 Gbps 3.2 Gen 2 up to 1 0 Gbps DRAM interface LPDDR4 LPDDR5 LPDDR4 LPDDR5 LPDDR4 Max DRAM size 4 GB 3 2 GB for LPDDR5 1 6 GB for LPDDR4 1 6 GB for LPDDR5(x) 8 GB for LPDDR4 PCIe N/A Four-lane PCIe One-lane PCIe Gen 3 Clock(MHz) Cortex Quad-Core 1 0 0 8 Dual-Core 1 6 0 8 1 6 0 8 DRAM 1 5 9 6 6 4 bit LPDDR4 2 6 4 0 6 4 bit LPDDR5 3 1 9 2 3 2 bit LPDDR5 IDSP 8 6 4 6 9 6 1 2 7 2 Core 9 6 0 7 2 0 6 2 4 Vision VP 9 1 2 1 1 0 4 6 2 4 Voltage V Core 0.80 0.75 0.75 Performance HEVC encode 4 x 5 MP30 HEVC linear VIN 4 x 5 MP30 7 2 0 P30 5 MP15 4 x 5 MP30 7 2 0 p30 5 MP2 CV Various convolutional neural network CNN algorithms Various CNN algorithms Various CNN algorithms The major digital signal processor DSP related differences between CV2x CV5x CV72 and CV3 are as follows CV2x and CV72 offer one core for both image digital signal processing IDSP and video digital signal processing VDSP Alternatively CV5x and CV3 have dual cores for both IDSP and VDSP CV2x provides six pyramid layers Alternatively CV5x CV72 and CV3 provide seven pyramid layers This sections provides details on the CV5 Timn board The figure below provides an overview of the major components and input output I/O connectors of the CV5 evaluation kit EVK board followed by a table of component descriptions Figure 2-1 CV5 Timn Board The major components and I/O connectors identified in the figure above are as follows Table 2 2 Input Output Connectors Identifier Identifier Description 1 Universal asynchronous receiver transmitter UART 1 DB9 with flow control 2 USB to serial debug UART firmware download port 3 Internal power on off 4 Reset 5 External power on off 6 Microcontroller unit MCU reset 7 Audio line-out 8 Analog microphone MIC 9 Digital MIC 1 0 Joint test action group JTAG 1 1 Dual in-line package DIP switches 1 2 Video input VIN port1 1 3 VIN port2 1 4 VIN port3 1 5 VIN port3 1 6 Mobile industry processor interface MIPIÂ® DSI video output VOUT 1 7 USB 3.0 host 1 8 USB Type-C 1 9 Micro USB 3.0 device 2 0 Composite video with blanking and sync CVBS VOUT 2 1 Infrared IR receiver 2 2 Periperal component interconnect express PICe x4 port 2 3 Ethernet 2 4 Ethernet 2 5 1 2 V DC power 2 6 High-definition multimedia interface HDMIÂ® VOUT This section provides details on the CV72 Ga board The figure below provides an overview of the major components and I/O connectors of the CV72 EVK board followed by a table of component descriptions Figure 2-2 CV72 Ga Board The major components and I/O connectors identified in the figure above are as follows Table 2 3 Input Output Connectors Identifier Identifier Description 1 USB to serial debug UART and firmware download port 2 Internal power on off 3 Reset 4 External power on off 5 MCU reset 6 Audio line-out 7 Audio headphone HP out 8 Audio speaker out 9 JTAG 1 0 DIP switches 1 1 VIN port1 1 2 VIN port2 1 3 MIPI DSI VOUT 1 4 USB 3.2 host 1 5 USB Type-C 1 6 Micro USB 3.2 device 1 7 CVBS VOUT 1 8 IR receiver 1 9 PCIe x1 port 2 0 Ethernet 2 1 1 2 V DC power 2 2 HDMI VOUT This chapter describes the software migration process from CV2x to the Cooper Linux software development kit SDK CV2x uses the iav_system_resource structure to describe system resources including the channel canvas and stream The Cooper Linux SDK splits the iav_system_resource structure to create smaller structures By removing the channel canvas and stream from the iav_system_resource structure and adding a new input output control IOCTL IAV_IOC_SET_CHAN_CONFIG IAV_IOC_SET_CANVAS_CONFIG and IAV_IOC_SET_STREAM_RESOURCE the Cooper Linux SDK optimizes this process and enables a streamlined configuration For detailed usage of these new IOCTLs refer to in the Doxygen image audio video IAV driver application programming interface API partition The Cooper chip family supports a maximum canvas number of 2 0 while CV2x supports a maximum of 1 2 On CV2x canvas ID 1 6 is reserved for the encode from memory EFM stream this has been changed to 2 4 in the Cooper Linux SDK Canvas ID 1 6 indicates the 1 6 th canvas in the Cooper Linux SDK rather than the ID for the EFM stream Because the canvas number has been upgraded from 1 2 to 2 0 there is potential for size changes to the canvas-related structures or to the canvas bitmaps More canvas numbers enable more dynamic random-access memory DRAM bandwidth so the overall DRAM bandwidth may be increased Users may expect the overall frame rate to be affected if the DRAM bandwidth is the bottleneck The Cooper chip family supports a maximum stream number of 2 0 while CV2x supports a maximum of 1 6 Note that the total encode performance remains unchanged for the Cooper chips so the individual stream performance may require adjustments to support additional stream numbers Due to the stream number increasing from 1 2 to 2 0 there is potential for size changes to the stream-related structures or the stream bitmaps For Cooper chips dedicated hardware performs blur insertion and the blur effect is improved to appear more natural The blur interface is slightly different from CV2x The information below provides further details on the blur-related interface changes for the Cooper Linux SDK and provides a comparison to CV2x Blur color is no longer required in the Cooper Linux SDK Blur operations are performed with the color from the original YUV data in order to provide a more natural appearance The blur color can also be enabled for CV5x and later chips to achieve backward compatible behavior Compared to the per-8x8 block for CV2x the per-pixel-level blur granuarity is finer for Cooper chips Because per-pixel-level blur granularity uses one bit per pixel in the blur memory Cooper chips require a larger DRAM size and greater bandwidth than CV2x A bit value of 0 indicates that blur is enabled while a bit value of 1 indicates that blur is disabled for Cooper chips these values are different for CV2x Cooper chips insert blur for each encode frame There is not an flag in the blur configuration The maximum-supported blur strength level is 4 on Cooper chips and 3 on CV2x Cooper chips supports two types of blur effect mosaic-like blur and ground-glass-like blur Implementation of the electronic image stabilization EIS feature in the Cooper chip family differs from that of CV2x EIS is implemented with two channels in the Cooper Linux SDK while the CV2x SDK uses a single channel Using two channels for the EIS feature ensures that there is no extra latency in frames for 3 A auto exposure AE auto white balance AWB auto focus AF statistics For more details refer to the EIS Library document in Doxygen as well as the unit test test_eis For Cooper chips users can specify the image offset in the scaler output buffer For CV2x the image is always at the top-left corner of the output buffer The multi-pass feature is redesigned for CV5x and later computer vision CV chips but not applicable to earlier CV2x chips It is a multi-channel design leveraging multi-region dewarp mode mode 1 to expand the number of source buffers Each channel still has only one pass This feature is supported since Cooper SDK 1.6 For more details refer to ADVANCED Multi-Pass The custom SEI feature is redesigned inside DSP IAV for CV5x and later computer vision CV chips Therefore the API flow and interfaces are also refined This feature is supported since Cooper SDK 1.6 The previous CV2x API flow is listed as follows Enable custom SEI and configure custom SEI related buffers when set up system resource before preview The related parameters are custom_sei custom_sei_buf_size custom_sei_buf_num for iav_system_resource Map the custom SEI memory with IAV_PART_DSP For the previous CV2x platform the custom SEI memory is inside the DSP partition IAV_PART_DSP memory Request custom SEI buffer to write the SEI content The API is IAV_IOC_CUSTOM_SEI_REQUEST_BUF Fill the custom SEI buffer and set request to IAV The API is IAV_IOC_SET_STREAM_CONFIG with IAV_STMCFG_CUSTOM_SEI The new API flow is listed as follows Enable custom SEI and configure custom SEI related buffers when set up stream resource before preview The related parameters are custom_sei_possible custom_sei_data_max_size custom_sei_buf_num for iav_stream_resource These parameters are stream based so each stream can enable and configure them separately The parameter stands for the maximum custom SEI data size for this stream Map the custom SEI memory with IAV_PART_CUSTOM_SEI For the new implementation the custom SEI has its dedicated memory partition Request custom SEI buffer to write the SEI content The API is IAV_IOC_GET_STREAM_CONFIG with IAV_STMCFG_CUSTOM_SEI Fill the custom SEI buffer and set request to IAV The API is IAV_IOC_SET_STREAM_CONFIG with IAV_STMCFG_CUSTOM_SEI For more details refer to 1.16 Insert User-Customized Data into Bitstream For CV5x and later chips RAW fps is introduced between VIN fps and IDSP fps which can potentially save significant DRAM bandwidth for RAW data output if user needs a lower IDSP processing rate For CV2x RAW fps must be the same as VIN fps which is also sensor fps The RAW fps is specified with parameter or in iav_chan_cfg For more details refer to BASIC Frame Rate The CV2x platform supports up to 4 GB of DRAM The DSP and vector processor VP hardware can access up to a 3 2 bit memory address Therefore all modules including CPU DSP and VP can access the entire 4 GB DRAM without issue The CV5x platform supports up to 1 6 GB of DRAM The DSP and VP hardware can access up to a 3 2 bit memory address However there is a limitation that the DSP and VP hardware can only access up to 4 GB of DRAM The solution is to separate the memory access ranges for both DSP and VP enabling VP to access a range from 0 GB to 4 GB and the DSP to access a range within 4 GB to 8 GB All memory including DSP and VP memory can be accessed by the Arm CPU The shared memory between DSP and VP is within a 4 GB range with the end address of 4 GB For more details refer to Section 2.1.2 in the DRAM Optimization document DSP memory space is divided into two partitions the first is DSP private memory which can be accessed by only DSP and Arm the other is the DSP shared memory which can be accessed by DSP Arm and VP If the DRAM size is 8 GB or greater the DSP private memory starts from the physical memory 4 GB and the shared memory ends with physical memory 4 GB Due to the new memory layout introduced on the CV5x platform there are some special notes The DSP memory address and physical memory address may require translation from one to another When the DRAM size is 8 GB or greater the DSP private memory is mapped from the physical address 4 GB to the DSP address 0 x0 If the DSP output buffer must be accessed by VP hardware this buffer must be from the DSP shared memory rather than DSP private memory which is within the 4 GB limit For example the canvas or pyramid buffer can enable the external memory or manual feed which will be assigned in the DSP shared memory Otherwise the buffer is located in the DSP private memory which cannot be directly accessed by the VP hardware The typical DSP shared memory partitions may include canvas pyramid VOUT onscreen display OSD and overlay These may be required to be directly accessed by the VP without a memory copy The graphics direct memory access GDMA hardware can only access 3 2 bit DRAM address the accessing memory range is configured to be the same as the DSP in order to accelerate the copy speed for DSP-related memory For CV-related use cases CV applications may require queried canvas data from the IAV driver and send it to the VP for further detection To avoid extra memory copies Ambarella suggests that users enable manual feed or external memory for this canvas This way the canvas will be from the DSP shared memory and can be directly accessed by the VP without extra copies from the DSP private memory to the VP-accessible memory If the canvas is enabled with manual feed or external memory the queried canvas is from the canvas pool IAV_PART_CANVAS_POOL in the DSP shared memory and the YUV data is reported with the base address of the canvas pool Otherwise the queried canvas is from the DSP partition IAV_PART_DSP and the YUV data is reported with the base address of the DSP partition To simplify the process for CV applications to query canvas data Ambarella suggests that customers use the API IAV_IOC_QUERY_INFO with IAV_INFO_CANVAS to obtain the base address for the buffer pool of the reported canvas data and the total memory size for this buffer pool The example usage for this API to obtain buffer pool information is as follows The example usage to access the YUV data is as follows This chapter describes software migration and provides IOCTL differences between the CV2x SDK and the Cooper Linux SDK The IOCTLs are as follows 4 1 IAV_IOC_QUERY_INFO 4 2 IAV_IOC_SET_DSP_LOG 4 3 IAV_IOC_DRV_DSP_INFO 4 4 IAV_IOC_SET_SYSTEM_RESOURCE 4 5 IAV_IOC_GET_SYSTEM_RESOURCE 4 6 IAV_IOC_SET_CHAN_CONFIG 4 7 IAV_IOC_GET_CHAN_CONFIG 4 8 IAV_IOC_SET_CANVAS_CONFIG 4 9 IAV_IOC_GET_CANVAS_CONFIG 4 10 IAV_IOC_SET_STREAM_RESOURCE 4 11 IAV_IOC_GET_STREAM_RESOURCE 4 12 IAV_IOC_QUERY_ENC_MODE_CAP 4 13 IAV_IOC_ENTER_IDLE 4 14 IAV_IOC_SET_MEM_LAYOUT_RESOURCE 4 15 IAV_IOC_GET_MEM_LAYOUT_RESOURCE 4 16 IAV_IOC_QUERY_MEM_LAYOUT_INFO 4 17 IAV_IOC_QUERY_DESC 4 18 IAV_IOC_CFG_VIDEO_PROC 4 19 IAV_IOC_GET_VIDEO_PROC 4 20 IAV_IOC_SET_RAW_ENC_CFG 4 21 IAV_IOC_SET_RAW_ENCODE 4 22 IAV_IOC_GET_RAW_ENCODE 4 23 IAV_IOC_SET_STREAM_CONFIG 4 24 IAV_IOC_GET_ STREAM_CONFIG 4 25 IAV_IOC_SET_BLUR_INSERT 4 26 IAV_IOC_GET_ BLUR_INSERT 4 27 IAV_IOC_APPLY_FRAME_SYNC_PROC 4 28 IAV_IOC_QUERY_MEMBLOCK 4 29 IAV_IOC_EFM_HANDSHAKE_FRAME 4 30 IAV_IOC_EFM_SET_EXT_POOL 4 31 Depreciated or Unsupported IOCTLs In the Cooper Linux SDK selected parameters are diminished in the IOCTL IAV_IOC_QUERY_INFO The removed information ID is as follows IAV_INFO_MULTI_COLOR_MASK The Cooper Linux SDK adds new parameters in the structure iav_dsplog_setup as shown below The Cooper Linux SDK removes selected parameters in the structure iav_driver_dsp_info In this structure dspout and dspin are removed The following lists the changes in the structure parameter iav_system_resource for the IOCTL IAV_IOC_SET_SYSTEM_RESOURCE The Cooper Linux SDK modifies parameters in the structure iav_img_scale_cfg as follows Table 4 1 iav_img_scale_cfg Structure Definition Parameter Change Notes Removed Removed Replaced with max_input Removed Replaced with max_output Added Specifies the maximum input Added Specifies the maximum output Added Specifies the image scale data format of the input and output image Updated Replaced with the iav_rect structure from the iav_window structure to support image scaling to a dedicated offset instead of always 0 x0 The Cooper Linux SDK modifies parameters in the structure iav_system_resource as follows Table 4 2 iav_system_resource Structure Definition Parameter Change Notes Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed The stream resource configuration is moved to the new IOCTL IAV_IOC_SET_STREAM_RESOURCE Removed The channel resource configuration is moved to the new IOCTL IAV_IOC_SET_CHAN_CONFIG Removed The canvas resource configuration is moved to the new IOCTL IAV_IOC_SET_CANVAS_CONFIG Added Specifies the channel map Added Specifies the canvas map Added Specifies the stream map Added Specifies the DRAM size of the advanced video coding AVC JPEG encoding buffer Added Specifies the maximum chroma radius Added Disables chroma enhancement CE Added Enables disables DSP performance optimal mode Added Enables disables low delay mode for mode 0 Added Enables preblend pass only for AISP mode 9 Added Specifies the IDSP VOUT back pressure margin Added Specify the DRAM size of the MJPEG PJPEG encoding buffer Added Enables disables last good frame repeat when a broken frame is detected Added Specify the group sync tolerance value to adapt the end-of-frame EOF drift between sensors within a group Refer to the structure parameter change from the IOCTL IAV_IOC_SET_SYSTEM_RESOURCE CV2x uses IOCTL IAV_IOC_SET_SYSTEM_RESOURCE to configure the channel resource The Cooper Linux SDK adds a new IOCTL IAV_IOC_SET_CHAN_CONFIG to configure the channel resource it uses the same structure iav_chan_cfg The structure parameter changes for the Cooper Linux SDK are listed below Table 4 3 iav_chan_cfg Structure Definition Parameter Change Notes Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Renamed New name Added Specifies channel ID Removed Enables disables c2y burst tile mode Added Enables disables c2y y12 output Added Queries with blocking call Added Enables disables slice-related configurations Added Specifies the channel s slice number automatically calculated by IAV Added Specifies the channel s slice width Added Specifies the channel s slice number Added Specifies the channel s padding width for RAW data when IDSP stitching is used Added Specifies the channel s padding width for YUV data at warp stage when IDSP stitching is used Added Enables IDSP high performance mode obsolete Added Enables disables external memory for raw Added Sets the input source for the channel Added Enables disables customized IDSP core mode Added Specifies IDSP core mode Added Specifies the EIS or dewarp channel s input source channel Added Updated from 3 bits to 7 bits to support greater EIS delay count values Added Enables duplicated 3 A configurations from master channel Added Enables decoding first to generate YUV before going through IDSP pipeline Added Specifies the decoder type when pre_dec_enable 1 Added Enables grouping for 3 A control Added Specifies the group index of 3 A statistic data Added Specifies the VIN region of interest ROI index when VIN ROI is enabled Added Enables disables the client application CA warp function Added Specifies the capture slice number for RAW data Added Specifies the RAW slice cached items to query RAW with blocking call Added Read-only option to report the RAW width for the current channel Added Read-only option to report the RAW height for the current channel Added Enables disables ISP NN such as True Motion Added Enables disables motion buffer output from IDSP channel Added Specifies the motion buffer cached items for user to query Added Enables disables channel input from the specified canvas for multi-pass feature Added Specifies the source canvas ID for multi-pass feature Added Specifies the RAW fps between VIN fps and IDSP fps Added Specifies the high precision RAW fps between VIN fps and IDSP fps Added Specifies the IDSP vertical slice number Added Specifies the RAW DATA padding height for multiple IDSP vertical slices feature Added Enables disables IDSP bypass to enable DSP to encode from YUV input directly Refer to the structure parameter change from the IOCTL IAV_IOC_SET_CHAN_CONFIG CV2x uses the IOCTL IAV_IOC_SET_SYSTEM_RESOURCE to configure canvas resources The Cooper Linux SDK adds a new IOCTL IAV_IOC_SET_CANVAS_CONFIG to configure the canvas resources it uses the same structure iav_canvas_cfg The structure parameter changes for the Cooper Linux SDK are listed below Table 4 4 iav_canvas_cfg Structure Definition Parameter Change Notes Removed Removed Removed Added Specifies the canvas ID Added Specifies the external memory for the canvas Added Specifies the blend type for multi-channel stitching Added Enables disables clearing the canvas data in the background color before preview Added Enables disables source buffer offset in a single-view canvas Added Enables disables blur operations from the specific canvas Added Specifies the maximum number of blur areas Added Specifies the copy sides minus 1 of the blending area Added Enables disables H-warp for blending overlap region Added Specifies the overlap margin of the last blend channel and first blend channel Added Disables enables extra padding for stream encoding Added Disables enables canvas width alignment to improve HEVC encoding efficiency Added Disables enables low delay output with multiple IDSP veritical slices Refer to the structure parameter change from the IOCTL IAV_IOC_SET_CANVAS_CONFIG CV2x uses the IOCTL IAV_IOC_SET_SYSTEM_RESOURCE to configure the stream resource The Cooper Linux SDK adds a new IOCTL IAV_IOC_SET_STREAM_RESOURCE to configure the stream resource it uses the same structure iav_stream_resource The structure parameter change for the Cooper Linux SDK is as follows Add the parameter stream_id This is used to specify the stream ID Add the parameter efm_ext_mem This is used to enable the user-managed external EFM frame buffer Add the parameter hevc_width_align_enable This is used to enable the HEVC width alignment for encoding efficiency Add the parameter custom_sei_possible This is used to enable the customized SEI insertion into the stream Add the parameter custom_sei_buf_num This is used to specify the customized SEI buffer number for the stream Add the parameter custom_sei_data_max_size This is used to specify the customized SEI buffer max size for the stream Refer to the structure parameter change from the IOCTL IAV_IOC_SET_STREAM_RESOURCE The following lists the changes in the structure parameter iav_enc_mode_cap for the IOCTL IAV_IOC_QUERY_ENC_MODE_CAP Table 4 5 iav_enc_mode_cap Structure Definition Parameter Change Notes Removed Removed The following lists the changes in the structure parameter iav_dsp_boot_params for the IOCTL IAV_IOC_ENTER_IDLE Table 4 6 iav_dsp_boot_params Structure Definition Parameter Change Notes Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Added Configures vout_osd_rescale_disable Added Disables VOUT OSD rescale Added Configures vout_possible_map Added Possible VOUT map when booting DSP The following lists the changes in the structure parameter iav_mem_cfg_chan for the IOCTL IAV_IOC_SET_MEM_LAYOUT_RESOURCE Table 4 7 iav_mem_cfg_chan Structure Definition Parameter Change Notes Removed Removed Removed Removed Removed Refer to the structure parameter change from the IOCTL IAV_IOC_SET_MEM_LAYOUT_RESOURCE The following lists the changes in the structure parameter iav_mem_layout_info for the IOCTL IAV_IOC_QUERY_MEM_LAYOUT_INFO Table 4 8 iav_mem_layout_info Structure Definition Parameter Change Notes Removed Removed Added Queries each VIN s memory layout in raw pool The definition of the structure iav_mem_layout_raw_pool is shown below The following lists the changes in the structure parameter iav_querydesc for the IOCTL IAV_IOC_QUERY_DESC Table 4 9 iav_querydesc Structure Definition Parameter Change Notes Removed Removed Added Queries a single Y12 image Updated Added parameter delay_frames for EIS delay frames to query raw data from this channel Updated Added parameter canvas_id to query canvas-based blending options Updated Added parameter data2_addr_offset_valid and data2_addr_offset to support the frame s second status for the second core when dual-core spatial encode mode is used Added Queries custom AISP buffer information Updated Queries RAW slice buffer information Added Queries a motion data from the IDSP channel The following lists the changes in the structure parameter iav_video_proc for the IOCTL IAV_IOC_CFG_VIDEO_PROC Table 4 1 0 iav_video_proc Structure Definition Parameter Change Notes Removed Removed Added Refer to the structure parameter change from the IOCTL IAV_IOC_CFG_VIDEO_PROC CV2x uses the IOCTL IAV_IOC_SET_RAW_ENCODE to configure and perform raw encode The IOCTL IAV_IOC_SET_RAW_ENC_CFG is added in the Cooper Linux SDK to configure the raw encode first Then it uses IAV_IOC_SET_RAW_ENCODE to perform raw encode and adds the structure iav_raw_enc_cfg New parameters in the structure iav_raw_enc_cfg are shown below The following lists the changes in the structure parameter iav_raw_enc_setup for the IOCTL IAV_IOC_SET_RAW_ENCODE The memory configuration parameters are moved to the IOCTL IAV_IOC_SET_RAW_ENC_CFG Table 4 1 1 iav_raw_enc_setup Structure Definition Parameter Change Notes Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Removed Added Specifies the RAW data buffer index Added Specifies the HDEC data buffer index Added Synchronizes with IDSP configurations for the EIS feature Refer to the structure parameter change from the IOCTL IAV_IOC_SET_RAW_ENCODE The following lists the changes in the structure parameter iav_stream_cfg for the IOCTL IAV_IOC_SET_STREAM_CONFIG Table 4 1 2 iav_stream_cfg Structure Definition Parameter Change Notes Updated The parameter enc_src_map in the structure iav_stream_format is extended from 1 6 bits to 3 2 bits due to the support of up to 2 0 streams Added The new structure to specify the customized SEI configuration Refer to the structure parameter change from the IOCTL IAV_IOC_SET_STREAM_CONFIG The following lists the changes in the structure parameter iav_blur_insert for the IOCTL IAV_IOC_SET_BLUR_INSERT Table 4 1 3 iav_blur_insert Structure Definition Parameter Change Notes Removed The blur will always insert into the stream input canvas there no option to turn it off Updated The iav_blur_area structure update information is listed in the following table The table below lists the structure parameter iav_blur_area inside structure iav_blur_insert Table 4 1 4 iav_blur_area Structure Definition Parameter Change Notes Added Specifies whether the blur color is enabled or not for this blur area Added Specifies the blur effect 0 Blur without blocky effect 1 Blur with blocky effect Added Specifies the blur coefficients range 0 3 when is_blocky is 0 and range 0 2 when is_blocky is 1 0 Weakest blur coefficients Refer to the structure parameter change from the IOCTL IAV_IOC_SET_BLUR_INSERT The following lists the changes in the structure parameter iav_apply_frame_sync for the IOCTL IAV_IOC_APPLY_FRAME_SYNC_PROC Table 4 1 5 iav_apply_frame_sync Structure Definition Parameter Change Notes Updated The parameter stream_updated_map is extended from 1 6 bits to 2 8 bits due to the support of up to 2 0 streams Query IAV_MEM_IMG_FIFO is removed from enum iav_mem_id Users can now only query partition or canvas memory block information The following lists the changes in the enumeration parameter iav_mem_part_id for the IOCTL IAV_IOC_QUERY_MEMBLOCK Table 4 1 6 iav_mem_part_id Enumeration Definition Parameter Change Notes Removed Removed Renamed HEVC and AVC scalelist partition Added Decoder BSB buffer partition Added Partition ID for DSP and CV internal share Added VOUT0 frame buffer partition Added VOUT1 frame buffer partition Added VOUT2 frame buffer partition The following lists the changes in the structure parameter iav_efm_handshake_frame for the IOCTL IAV_IOC_EFM_HANDSHAKE_FRAME Table 4 1 7 iav_efm_handshake_frame Structure Definition Parameter Change Notes Added EFM YUV offset inside of YUV partition should only be used when efm_ext_mem 1 Added EFM ME offset inside of ME partition should only be used when efm_ext_mem 1 The structure iav_efm_ext_pool and IOCTL IAV_IOC_EFM_SET_EXT_POOL are added to set EFM external memory infomation to IAV The iav_efm_ext_pool structure definition is shown below Table 4 1 8 Deprecated or Unsupported IOCTLs IOCTL Notes IAV_IOC_SET_DSP_VP_CFG Removed IAV_IOC_GET_DSP_VP_CFG Removed IAV_IOC_DSP_AUTH Removed IAV_IOC_GET_SYSTEM_CONFIG Removed because there is no single system configuration The system configuration is now separated into smaller configurations such as channel configuration canvas configuration and stream configuration IAV_IOC_SET_FASTOSD_INSERT Removed IAV_IOC_GET_FASTOSD_INSERT Removed IAV_IOC_CUSTOM_SEI_REQUEST_BUF Removed IAV_IOC_CTRL_DSP_DUMP_CMD Removed IAV_IOC_QUERY_DSP_DUMP_CMD Removed IAV_IOC_SET_TML_CONFIG Not implemented IAV_IOC_GET_TML_CONFIG Not implemented IAV_IOC_RELEASE_FRAMEDESC Not implemented IAV_IOC_FLUSH_FRAMEDESC Not implemented This chapter describes the unit test tool differences between CV2x and the Cooper chip family The CV2x and Cooper chip families both utilize the unit test test_encode to support single- and multi-VIN cases This test can support both Lua scripts and command lines for single-VIN cases For multi-VIN cases only Lua scripts are supported The Cooper family of chips adds another option vout-cfg which enables users to configure VOUT from the Lua script This chapter describes how to upgrade the firmware and use the tools for Linux and the CVflowÂ® processor The CV5x firmware download process differs from the CV2x firmware download process CV2x uses the AmbaUSB tool to upgrade the firmware while CV5x can use either the AmbaUSB tool or the Android fastboot tool Refer to Getting Started Guide for more details CV72 is similar to CV2x in terms of firmware upgrade as both use the AmbaUSB tool to download the firmware Use the toolchain below to compile the Linux source code Use the toolchain below to compile the CV source code Question Is it difficult to migrate CV2x products to the Cooper chip family Answer Migrating from the CV2x platform to the Cooper chip family is simple The Cooper SDK IOCTL is backwards-compatible with the CV2x IOCTL so users who have already designed a CV2x-based single-VIN channel platform should find it easy to migrate upper-level applications from CV2x to the Cooper Linux SDK Users who have designed CV2x multi-channel products must implement minor changes to the processing flow as well as to some data structures in the Lua script in order to access multi-channel features Copyright c 2 0 2 4 Ambarella International LP This file and its contents are protected by intellectual property rights including without limitation U.S and/or foreign copyrights This Software is also the confidential and proprietary information of Ambarella International LP and its licensors You may not use reproduce disclose distribute modify or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates In the absence of such an agreement you agree to promptly notify and return this Software to Ambarella International LP THIS SOFTWARE IS PROVIDED AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS COMPUTER FAILURE OR MALFUNCTION OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">sys_debug_tool</field>
    <field name="url">d9/dc9/sys_debug_tool.html</field>
    <field name="keywords"></field>
    <field name="text">DEBUG Tools DEBUG Tools Revision History SDK Version Updated Date Modification 1.5.0 2 0 2 2 0 9 2 0 Migrated the Debug Tools and Linux Programming Guide from Word into Doxygen 1.5.1 2 0 2 3 1 2 2 5 Updated Directory Structure This chapter describes how to perform the following Section 1.1 General Debug Method Section 1.2 Kernel Log Section 1.3 Capture the DSP Log and Parse Section 1.4 Debug with the Script Section 1.5 Kernel Message Module Section 1.6 Gnu DeBugger GDB Debug Section 1.7 Memory Debug Section 1.8 Capture the Cavalry Log Section 1.9 Stream Diff Section 1.10 Cavalry Top Section 1.11 Cavalry Core Dump Section 1.12 Performance Debugging To modify the Linux kernel driver source code insert the new kernel driver module directly without burning the entire binary to NAND flash Compile the Linux driver module under ambarella/boards/ board_type Boot the platform and insert the new module If the user is able to access the building directory from the platform the following commands will insert the new kernels do not use init.sh Refer to Section 6.4 Network Sharing: CIFS for more details on managing network sharing between the building machine the virtual machine and the platform The command above uses kernel version 4.9.0 If the user writes or modifies a program they should run the program on the platform via network sharing The commands below assume that the test_encode has been modified and recompiled In the code above and represent the user ID and password To change the microcode also referred to as the ucode binaries without upgrading the entire firmware substitute the new binaries for the old microcode binaries orccode.bin default_binary.bin and orcme.bin under on the platform If the new microcodes are on the SD card use the following commands If SDK bugs are found during the development try the following troubleshooting steps Reproduce the bug using the unit test programs on the evaluation kit EVK board Report it using the steps above If the bug cannot be reproduced by a unit test program capture the kernel and digital signal processor DSP log and report the bug with the log files For more details refer to Section 1.2 Kernel Log By default the kernel log is appended to and its size is 2 0 0 KB To change the log file path and size For example save the kernel log to txt The size is 1 0 0 0 KB as shown below Type the command to see the kernel logs The tool in the binary format enables users to analyze and debug the DSP For a more legible option can also be used to parse the log to text format For example to debug a DSP start encoding failure start the dsplog_cap before encoding Type to see help texts and the usage guide Perform the following to capture entire DSP logs limited logs or parse the DSP log binary file into text To capture DSP logs to a file on an SD card use the following command Alternatively press Ctrl c to end the DSP log capture process If there is no SD card in the camera but there is a network shared file system replace the file directory name above for the o option To capture limited logs to the SD card where each log file is about 1 0 0 MB use the following command To parse the DSP log binary into text use the following commands By default the tool uses as the ucode firmware directory The d option can also be used to specify another ucode directory Upon completion the user can see that the txt is the parsed text version of the DSP log Users can zip the log file and send it to the Ambarella support team for analysis If the DSP crashes the script enables users to capture additional logs such as image audio video IAV messages video input VIN registers and DSP logs The script can also auto-stop the capture log after detecting the interrupt or video digital signal processor hang To debug with script Run the test case Run dsp_debug.sh The DSP log bin file is saved in by default other files are saved in Additionally users can modify the path by referring to the following source code $SDK sh To avoid the private IAV driver debugging process and other kernel modules users can enable the kernel message module to redirect all Ambarella private drivers print messages from the default file to This provides a convenient method for customers who are required to develop kernel modules The message is disabled by default To enable the message follow the steps as shown below From menuconfig use the following commands Build the firmware To prepare the debug binary use the following commands For Cooper Amba build For Cooper Yocto build Compile the GNU program debugger GDB program To compile the customized code on the building machine use the following commands Confirm that the program is compiled for the correct target using the following commands The debug tool mentioned in step one and the the application with debug information mentioned in step two are both necessary steps Neither can be omitted The step two is a simple and fast way to add the debug infomation Another way to add the debug infomation is to build all the applications with the debug infomation This results in a large size of the compiled firmware So it is not recommended when the device has a small storage space Start the GDB on board First use TFTP USB or another method to copy the gdb-sample and gdb-sample.c to the board Then use the following commands to debug the application Some useful parameters for GDB Table 1 1 Useful Parameters for GDB Comamnds Function gdb args gdb-sample arg0 arg1 Call the application with arguments gdb directory SOURCE_CODE_DIR Search for source files in SOURCE_CODE_DIR Some useful parameters for GDB debugging Table 1 2 GDB Debugging Parameters Comamnds Function b reak main Places a breakpoint at the beginning of the program b reak N Places a breakpoint at line N b reak fn Places a breakpoint at the beginning of function info break Lists breakpoints d elete N Deletes breakpoint number N r un arglist Runs the program with the arglist if have until a breakpoint or error is encountered c ontinue Continues running the program until the next breakpoint or error s tep N Runs the next N line(s) of the program n ext Similar to s but it does not step into functions bt backtrace where Prints backtrace of all stack frames or innermost COUNT frames l ist N|function Lists specified functions or lines p rint var X Prints the current value of the variable or set var to X q uit exit Quits GDB Build the firmware To prepare the debug binary use the following commands Compile the GDB program To compile the customized code on the building machine use the following commands Confirm that the program is compiled for the correct target by using the following commands Start the GDB server on board First use TFTP USB or another method to copy the gdb-sample to the board and then use the following commands gdbserver localhost 2 3 4 5 gdb-sample arg0 arg1 can be used when the application requires arguments Start the GDB client on the host c ontinue must be used when the user starts to run the application insteading of r un Build the application using the following options in menuconfig For Cooper SDK Amba build For Cooper SDK Yocto build For more information about sanitizer options users can refer to the GCC manual book Copy the application the library libasan* and libubsan* in folder LINARO-TOOLCHAIN/arm-linux-gnueabihf/libc/lib to on the board Run the application on the board the debug messages will print The following uses test_yuvcap as an example cavalry_log enables users to debug system errors by providing the liveshow log when ucode is running Because the system generates many messages Ambarella recommends using Telnet for this command Figure 1-1 Capture Vector Processor Ucode Log Stream Diff can assist users in debugging dynamic random-access memory DRAM Stream Diff encodes two streams with identical encoding parameters the streams must be aligned in each bit The following provides an example of Stream Diff If the following messages appear the DRAM is unstable Users can run to check the efficiency of the vector processor VP chip This is the same as the command in Linux as shown below If the VP hangs users can utilize this tool to dump all necessary information into a single binary Then the binary can be on the Ambarella side to determine if the problem is due to either hardware instability or a directed acyclic graph DAG Send the dump.bin to Ambarella to enable Ambarella to reproduce the problem without using the actual network model files and applications Note that this method is only applicable for the VP hang issue Perf is a built-in performance analysis tool for Linux Perf can be used to analyze performance of the following issues specific applications per thread the kernel applications and the kernel simultaneously To support perf the user must follow the steps below Set up the building environment Enable kernel support for various performance events provided by the software and hardware Download and build the libraries that perf depends on copy Makefile to The Makefile includes all dependent libraries such as audit binutils bzip2 elfutils xz slang libunwind zlib dl and building steps Build the perf tool Install perf to the EVK Run perf to record the kernel events and copy the output to the PC Generate scalable vector graphics SVG Figure 1 2 Perf svg Flamegraph.pl and stackcollapse-perf.pl are located in FlameGraph-master.zip Unzip FlameGraph-master.zip and add the path to the environment Copyright c 2 0 2 4 Ambarella International LP This file and its contents are protected by intellectual property rights including without limitation U.S and/or foreign copyrights This Software is also the confidential and proprietary information of Ambarella International LP and its licensors You may not use reproduce disclose distribute modify or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates In the absence of such an agreement you agree to promptly notify and return this Software to Ambarella International LP THIS SOFTWARE IS PROVIDED AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS COMPUTER FAILURE OR MALFUNCTION OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">page_sys_dram_stat</field>
    <field name="url">d9/dea/page_sys_dram_stat.html</field>
    <field name="keywords"></field>
    <field name="text">DEBUG DRAM Bandwidth Statistics DEBUG DRAM Bandwidth Statistics When the system is running user usually pay a lot of attention to the CPUs status in fact the dynamic random access memory DRAM loading status is also important to users when the bandwidth resources are tight users need to adjust the loading of the running case according to the system running status in time However the real system is very complicated that there are many DRAM clients interacting with memory at the same time It is difficult to monitor the behavior of each client at the upper level For this request DRAM bandwidth statistics tool is very useful to help users monitor the real-time status of the system and allocate system resources The DRAM bandwidth statistics tool can obtain some inherent properties of DRAM such as type bit width clock and so on It can also perform statistics on the behavior of all memory clients at a certain time and calculate their bandwidth and the percentage of maximum throughput The bandwidth result can help users obtain the real interaction situation of each DRAM clients intuitively and the percentage result can tell users the proportion of each client s total system resources and the system margin To enable DRAM bandwidth tool environment needs below steps To use DRAM bandwidth tool ArmÂ® Trust ZoneÂ® must be enabled but secure boot and secure operating system OS must be disabled For Cooper Amba build Enable ATF module to start DRAM statistics these options below are only for CV5/CV52 not for CV72 config Load DRAM statistic module into kernel For Cooper Yocto build Enable ATF module to start DRAM statistics these options below are only for CV5/CV52 not for CV72 config Load DRAM statistic module into kernel The DRAM bandwidth statistics tools have three parameters duration time interval time and verbose switch Users need to specify a duration time so that the DRAM tool will last for such a long time to do statistics And the tool calculates the result of every interval if the interval time is set more than 0 Users can get statistical details if verbose switch is on Users can configure them using the command below The unit of is the default value is 1 0 0 0 ms The unit of is the default value is 0 ms Verbose can only be set to 0 or 1 it is used to configure whether to output statistical details If M is not divisible by N M will be set a multiple of N automatically If users run the DRAM bandwidth statistics tool a result can be got as below after the duration time delay The result contains 7 sections Usage DRAM Info Average BW Minimal BW among each interval Maximal Total BW among each interval Interval BW and Statistics Info Whether the result section is shown depending on the parameter value the dependencies are as followsï¼ verbose 0 verbose 1 interval 0 Usage DRAM Info Average BW Usage DRAM Info Average BW Statistics Info interval 0 Usage DRAM Info Average BW Minimal BW among each interval Maximal Total BW among each interval Usage DRAM Info Average BW Minimal BW among each interval Maximal Total BW among each interval Interval BW Statistics Info Figure 1-1 DRAM Statistics Usage Usage section is belong to basic part it is mainly to inform the configuration of the parameters and how to use this feature Dram Statistics Dram Info DRAM Info section belongs to the basic part it is mainly to inform the DRAM basic information such as ï¼ and so on in the format as below such as is the type property of dram including and is the bit width property of dram including and is the clock property of dram such as and so on is the burst size of dram it depends on is the maximum tranfer count in theory with these DRAM parameters It can be calculated as below Figure 1-2 DRAM Statistics Average Bandwidth Average BW section belongs to the basic part it informs the average bandwidth status for different modules during the measurement period module is for Arm loading status module is for image digital signal processing IDSP and video digital signal processor VDSP including ORCME ORCCODE SMEM module is for computer vision CV engine loading status including ORCVP ORCL2CACHE VMEM0 and so on module is for graphics direct memory access GDMA loading status module include all the other client such as SDXC USB CAN and so on is calculated according to the total statistical transfer data volume and the duration of statistics Figure 1-3 DRAM Statistics Minimal Bandwidth Minimal BW among each interval section is only shown when the interval parameter 0 it records the bandwidth of different modules in which time period is the minimal in the whole measurement cycle and shows the bandwidth results of all modules of corresponding time period Figure 1-4 DRAM Statistics Maximal Bandwidth Maximal Total BW among each interval section is only shown when the interval parameter 0 and it shows the maximal bandwidth value of total bandwidth The presentation modes of maximal BW is different from minimal BW Figure 1-5 DRAM Statistics Interval Bandwidth Interval bandwidth shows the bandwidth statistics result of every interval in all the duration period Figure 1-6 DRAM Statistics Info Statistics Info shows the total statistical transfer data volume and the duration of statistics It shows the request number burst number maskburst number of different client and the bank status First initialize the EVK board to load the essential drivers and microcode and start 3 A statistic if the following command was not executed previously Then put the image audio video IAV driver into state and wait it to enter the stable state for a while Next start DRAM bandwidth statistics tool Last a DRAM bandwidth statistics result is got</field>
  </doc>
  <doc>
    <field name="type">group</field>
    <field name="name">lib-sensor-api</field>
    <field name="url">da/d11/group__lib-sensor-api.html</field>
    <field name="keywords"></field>
    <field name="text">Sensor Calibration Library detail in file lib_sensor_calib.h</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">page_sys_docker</field>
    <field name="url">dc/d4a/page_sys_docker.html</field>
    <field name="keywords"></field>
    <field name="text">DESIGN Docker Usage Guide DESIGN Docker Usage Guide Updated Date Modification 2 0 2 2 1 1 0 4 Initial Version 2 0 2 2 1 1 2 9 Updated Section 1 Overview 2 0 2 2 1 2 0 1 Added Section 11 Support SSH server 2 0 2 3 0 3 0 8 Added Sections 3 Build the Firmware for CV72 EVK 4 Build the Firmware for CV3x EVK 2 0 2 3 0 4 0 7 Added Section 12 Docker Q A 2 0 2 4 0 1 1 0 Updated Section 1 Overview Ambarella provides Docker support for CV5x platforms This document provides a guide for building a Docker environment and demonstrates how to run software development kit SDK functions under Docker Docker is an open platform for developing shipping and running applications Docker enables users to separate applications from infrastructure so they can quickly deliver software With Docker users can manage the infrastructure in the same way that they manage applications By taking advantage of Docker methodologies for shipping testing and accelerated code deployment users can significantly reduce the delay between writing code and running it in production Docker provides the functions for packing and running applications in a friendly isolated environment which is called a container Containers are lightweight and can run directly on the host s kernel without other additional management programs At the same time the isolation and security features of the environment enable multiple containers to run on a given host Containers are independent of one other and multiple containers will not interfere with each other To download the latest Docker container and daemon applications running on ArmÂ® V8 platforms users can access the link The Docker binaries downloaded from the Docker link above all belong to Docker Engine scope which is licensed under the Apache version 2.0 License Here is the reference For the differences between Docker Engine and Docker Desktop refer to Build the firmware for the CV5 Timn EVK with the configuration file below Build the firmware for the CV52 Crco EVK with the configuration file below DDR type LPDDR4 DDR type LPDDR5 Build the firmware for the CV52n Zr EVK with the configuration file below Build the firmware for the CV72 Ga EVK with the configuration file below Build the firmware for the CV3bub EVK with the configuration file below Build the firmware for the CV3 Dk-mini EVK with the configuration file below To build a Docker environment users must ensure access to the internet Then they can set up the network according to the operation in WiFi and Ethernet Test the network with the command below The following information indicates that the connection to the internet is normal Before running Docker users must configure the following Prepare a secure digital SD card and format it to EXT4 Copy the Docker daemon and client applications CAs from the master branch to the SD card Users cannot build it into the firmware due to the size limit of the electronic logic gate NAND Refer to SD Card for SD card contents Add domestic mirror sources Create daemon.json and enter the following information The following configuration options are used data-root The root path used by Docker runtime default registry-mirrors Sets the mirror acceleration address These are for domestic use in China and users can choose acceleration mirror addresses that are suitable for the network environment Change the system time Confirm that the system time is accurate if not set it to the correct time Because Set Network implements the connection to the internet users can pull Ubuntu images from the Docker community The docker pull arm64v8/ubuntu command indicates that the pulled image version is the latest such as docker pull arm64v8/ubuntu 18.04 Users can add the corresponding version after the image name Create and start a new containter The following configuration options are used The privileged true sets the root privilege The p opens the port which maps the port of the Docker container to the host port The name sets the container name Enter into the container Users can implement the SDK functions in Docker through the following operations Copy SDK-related files to Docker mkdir p 15.76 The name of the folder to be created must be consistent with the folder name under outside Docker Start the basic image audio video IAV functions in the Docker container 1 Operation outside Docker 2 Operation in Docker Start the Cavalry functions in the Docker container For Cavalry content refer to Cavalry Driver API Users can package their own algorithms through Docker technology and run them on the CV5x board The benefits are as follows 1 Continuous deployment and testing The Docker container eliminates the difference between online and offline environments and ensures the consistency and standardization of the environment in the application life cycle Developers use an image to build a standard development environment and then migrate through an image that encapsulates the complete environment and application This truly realizes the concept This enables test and operations personnel to directly deploy software images for testing and publishing greatly simplifying the process of continuous integration testing and publishing 2 Cross-platform support Because Docker technology decouples the application from the underlying environment users can seamlessly run their applications on any chip platform 3 High resource utilization The container does not have the extra overhead of the manager but shares the operating system with the bottom layer The user s application can access and process the bottom layer data with low load and make full use of system resources The location of algorithms in Docker in the computer vision CV software framework is shown below Figure 10-1 Algorithms in Docker Ensure that the board s network is smooth Set the port to bind to the host when creating the container The option p opens a port which maps the port of the Docker container 2 2 to the host port 9 0 2 2 Software source update input in Docker Install vim input in Docker Set up the SSH serverï¼input in Docker 1 Install openssh-server 2 Open service 3 Verify that it starts normally 4 Edit sshd_config Remove the comment before PermitRootLogin prohibit-password and change it to PermitRootLogin yes 5 Restart service 6 Set the SSH password SSH access Docker Use secureCRT or other tools to connect to 10.0.0.2 9 0 2 2 to verify that SSH function is normal The user name is root and the password is set previously The robot operating system ROS is an open source project for building robot applications Get the ROS2 image for arm64v8 The docker pull arm64v8/ros command indicates that the pulled image version is the latest Users can add the specified version after the image name such as docker pull arm64v8/ros humble Check the ROS image Create a new containter for the arm64v8/ros image net host indicates that the host network mode is used for the container The containerâs network stack is not isolated from the Docker host the container shares the hostâs networking namespace and the container is not allocated its own IP address restart always indicates that the container will always start on daemon startup regardless of the current state of the container Check the ROS container If the container is in Exited status the user can use the following command to start it Enter into the container Run the demo test application to publish information The user can run the demo test application to subscribe the information on another device or on a PC with the ROS2 image installed Visit the following links for useful documentation on ROS How to use an arm64v8 ros image ROS official documentation In the Linux operating environment each released version of ROS2 corresponds to an Ubuntu version which is difficult to use on other versions For example ROS2 Humble must run on ubuntu22.04 while ROS2 Foxy must run on ubuntu20.04 Why did Docker fail to start Users may encounter different errors when running Docker which is caused by the different configurations supported by the board The following are the solutions for commonly-reported errors 1 How can the error below be resolved when running dockerd Method of resolution 2 How can the error below be resolved when running dockerd Method of resolution Execute manual_mount.sh in the directory Execute manual_mount.sh in directory 3 How can the error below be resolved when running dockerd Methods of resolution Modify options in json Add CONFIG_AMBARELLA_IPTABLES_SUPPORT to the board configuration 4 How can the error below be resolved when running docker pull arm64v8/ubuntu Methods of resolution Configure nameserver in conf 5 How can the error below be resolved when running docker run itd name xxx privileged true p 9 5 5 4 5 5 4 p 8 0 4 9 2 0 4 9 arm64v8/ubuntu This error is usually caused by the Docker daemon being unable to create a task for the container Methods of resolution Check if the system resources are sufficient RAM storage space CPU and more Users can stop the Docker service delete the Docker data root directory and re-enable it 6 How can the error below be resolved when running docker pull arm64v8/ubuntu The system defaults to not having a CA certificates root certificate which makes it unable to recognize digital certificates carried by external HTTPS Methods of resolution If the user is only in the testing phase the option to disable TLS verify can be configured in json Ambarella recommends the user downloads a digital certificate on the host side for security assurance How do users view the kernel options required for Docker This can be detected with the following linked script What are the suggested FS formats when using an SD card Docker supports different file systems for different storage drivers The following are the main types of storage drivers supported by Docker overlay2 This is the recommended storage driver for the current release it offers excellent performance without additional dependencies and configurations Replace the overlay storage driver after version 18.09 It supports XFS in case of ftype 1 and EXT4 file systems AUFS The storage driver used in the early days of Docker is recommended before Docker version 18.06 and Ubuntu version 14.04 It supports XFS and EXT4 file systems devicemapper This is the recommended storage driver for earlier versions of Community Enterprise Operating System CentOS and Red Hat Enterprise Linux RHEL systems as they do not support overlay2 and require direct-lvm support BTRFS Use only for BTRFS file systems ZFS Use only for ZFS file systems VFS This does not depend on the file system but the performance is sub-optimal Thus it is mainly used for testing Users can select the corresponding file system format according to the driver system used The Docker official recommendation is to choose the overlay2 storage driver Copyright c 2 0 2 4 Ambarella International LP This file and its contents are protected by intellectual property rights including without limitation U.S and/or foreign copyrights This Software is also the confidential and proprietary information of Ambarella International LP and its licensors You may not use reproduce disclose distribute modify or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates In the absence of such an agreement you agree to promptly notify and return this Software to Ambarella International LP THIS SOFTWARE IS PROVIDED AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS COMPUTER FAILURE OR MALFUNCTION OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">si_boot_upgrade</field>
    <field name="url">dc/d8f/si_boot_upgrade.html</field>
    <field name="keywords"></field>
    <field name="text">DESIGN Boot Upgrade DESIGN Boot Upgrade Version Updated Date Modification 1.0.0 2 0 2 4 0 1 1 5 Initial Version The Ambarella boot loader AMBoot uses a prior knowledge of the storge medium to allocate the different partitions for different usages in the compilation These partitions are logical groups on the storge devices and they have the continuous physical blocks This chapter explains two styles of firmware layouts supported by AMBoot Section 1.1 Flexible Firmware Layout Section 1.2 Legacy Firmware Layout For CV72 CV3 and the new evaluation kit EVK boards in future the flexible firmware layout is used The flexible firmware layout has much merits Supports up to 1 2 8 partitions and easy to support more Supports to determine each partition s name by user Supports the partition size larger than 4 GB Supports multi images per partition Supports multi kernel images and multi dtb binaries Supports to generate images that burners can use directly that is no need binsplit To use the flexible firmware layout the user must pay attention to the following three parts to do the configurations Partition Layout The pre-located partition definition file is ambarella/boards/ board_name h The rules for the firmware layout format is as follows The dev in must be or The part-name in can be arbitrary but must be unique Below is a firmware layout example for a NAND flash The bootstrap BST bootloader BLD device tree blob DTB environment ENV kernel and root file system rootfs are the default partition names using in AMBoot to generate the firmware image If the user wants to modify the partition names the firmware profile for generating the firmware and the ENV file for choosing booting partition must be modified together For more information the user can refer to ambarella/boot/amboot/doc/flexible_firmware.txt Firmware Profile The firmware profile is used for generating the firmware The default profile is located under directory ambarella/boot/ambfw/profile The user can create a new one under ambarella/boards/ board_name and select it in menuconfig ENV File The ENV file is used to describe the environment variables recognized by AMBoot The environment variables include the variables specifying which partition image is used for booting The default ENV file is located at the ambarella/boot/amboot/src/bld/default.env The user can create a new one with the customized settings named as board_name env or BSP_BOARD_VER env under ambarella/boards/ board_name to replace it The BSP_BOARD_VER env has a higher priority than board_name env For more information the user can refer to env.txt When programmed to the EVK board the ENV image allocates two copies in ENV partition on the storage medium If any one of the ENV image is corrupted the other one will be used to automatically recover the corrupted one For CV2x and CV5x the legacy firmware layout is used The legacy firmware layout is easy to use and has been used and verified by many customers over the years Only the following partitions are supported BST BLD PTB ATF PBA PRI SEC BAK RMD ROM DSP LNX SWP ADD ADC CFG and RAW It has some limitations For example it is not allowed to add other more partitions each partition s name is also unchangeable and so on The file path for partition definition is ambarella/boards/ board_name h The BST BLD partition table PTB ArmÂ® trusted firmware ATF primary PRI and Linux LNX are used by default Those partitions whose size is set to 0 are recognized as unused All optional and reserved partitions can be utilized for user storage For example Android data ADD pre-boot authentication PBA SEC backup BAK RAMDisk RMD or read-only memory ROM can be used as user partitions The legacy firmware layout only supports a fixed number of partitions Each partition s name is unchangeable One partition only supports one image The following conventions are used in the partition names Table 1 1 List of Fixed Partition Names Partition Choice Description BST Mandatory AMBoot bootstrap code for hardware initialization BLD Mandatory AMBoot bootloader PTB Mandatory Device tree binary DTB and partition table save the command line and boot flags ATF Mandatory ArmÂ® trusted firmware ATF which can be used as bl2 to verify bl3x.bin in secure boot PBA Optional Persistent basic input output system BIOS application for safe recovery For AB upgrade the system stores kernel B image for PBA upgrade it stores kernel+ramfs If PRI or RMD ROM is corrupted AMBoot can boot from the PBA partition and execute the recovery processes PRI Mandatory Primary code image which refers to the Linux kernel image For AB and PBA upgrades the system stores the kernel A image SEC Optional Secondary code image which can be used to store the private customer data BAK Optional Backup code image which can be uesed to backup images of all other specifized partitons RMD Optional RAMDisk rootfs If RAMDisk is selected AMBoot loads the RAMDisk image at the boot stage ROM Optional For AB upgrades ROM stores kernel B rootfs It is not used for PBA upgrades DSP Reserved Backup digital signal processor DSP microcode LNX Mandatory Stores kernel A rootfs for AB and PBA upgrades SWP Reserved Reserved ADD Reserved Android data partition or used for Oryx configuration ADC Reserved Android cache partition or used for Oryx upgrade firmware RAW Optional Remaining space in current storage media If there is remaining space in the storage media especially in the case of electronic multi-media cards eMMCs Ambarella suggests that users enable this partition in order to make use of all available space This chapter explains the boot flow based on the CV2x SDK 3.0 The boot flow for the Cooper software development kit SDK is similar This chapter contains the following sections Section 2.1 Normal Boot Section 2.2 Secure Boot Figure 2-1 Normal Boot Flow BST 4 K bootstrap binary for CVxx written by assembly BST starts from ambarella amboot src bst chip_name start.S BLD The boot loader is the main part of AMBoot It initializes hardware devices and maps memory space then jumps to the kernel partition BLD starts from ambarella amboot src bld main.c PTB In the normal boot process the boot flag and command line are from the PTB Figure 2-2 Secure Boot Flow BST bstemmc.S bstemmc.S bstspinor.S Load bl2.bin into dynamic random access memory DRAM and verify bl2.bin If the authentication is successful jump to bl2 address x22 bl2_main If the authentication fails halt the CPU to die loop at the current instruction address BL2 external tee arm-trusted-firmware bl2 Load bl3x.bin BL31 BL32 BL33 into DRAM and verify bl3x.bin If the authentication is successful or if the verification step is skipped jump to bl31 DRAM first address next_load_info If the authentication fails the bl31.bin will be erased from the memory and enter into the CPU loop BL31 tee arm-trusted-firmware bl31 Initialize and start the open portable trusted execution environment OP-TEE operating system OS BL32 Obtain the address of the kernel image in read-only memory ROM Jump to BL33 BLD BL32 optee_os Data encryption can be performed in the un-secure world Linux or in the secure world OP-TEE The trusted application TA functions can be run in the secure world OP-TEE BL33 bld.bin Load kernel image and verify kernel_release.bin If the authentication is successful jump to the kernel the jump partition depends on bootflags in bl33 If the authentication fails halt the CPU to die loop at the current instruction address Local approach Figure 2-3 Local Key Approach The private keys are stored in the local area Root of trust RoT public key ambarella amboot build keys rot_public.bin RoT private key ambarella amboot build keys rot_private.pem Kernel private key ambarella amboot build keys auth_kernel_private.txt TA private key external tee optee_os keys default_ta.pem Remote procedure call RPC ToolKit approach Figure 2-4 RPC Key Approach The private keys are stored in the remote server Remote RoT public key ambarella packages security build tz_dev_server rot_public.bin RoT private key ambarella packages security build tz_dev_server rot_private.pem Kernel private key ambarella packages security build tz_dev_server kernel_private.pem TA private key ambarella packages security build tz_dev_server default_ta.pem RPC usage Select in menuconfig and specify the different local port for the different account Set up the development server and daemon before compilation For more details refer to ambarella packages security build trustzone_secure_boot_toolkit_help.txt Enable one-time programmable OTP with a power-on configuration POC pin If POC 6 pulls up secure boot can be enabled temporarily If POC 6 pulls low secure boot will be disabled Enable OTP permanently If the eFUSE bit is used the secure boot will be permanently enabled If the secure boot is permanently enabled POC 6 cannot enable disable the secure boot Because this process is irrevocable The user uses it with cautions while performing this operation Typically this step is performed in manufacturing Since Cooper SDK supports two styles of firmware layouts the upgrade will be described based on these styles This chapter contains the following sections Section 3.1 Firmware and Image Section 3.2 TFTP Upgrade Section 3.3 SD Upgrade Section 3.4 Image Upgrade After SDK compilation various binaries are generated according to the different configurations Ambarella uses the following conventions for different binaries according its usages Binary It is generated directly by compilation and it is executable code data filesystem or others Image It may have a header and contains one or several binaries It can be burned into storage media Firmware It consists of self-burning header and several images and binaries It can be used by AmbaUSB programming trivial file transfer protocol TFTP upgrade and secure card SD upgrade According to the Ambarella SDK version and its build methods the user gets the firmwares images and binaries from different paths For Flexible Firmware Layout Table 3 1 List of Firmwares Images and Binariesâ Path for Flexible Type Cooper SDK Amba Build Yocto Build Firmware Path out/amba_out/ board_name out/yocto_out/ board_name Image Path out/amba_out/ board_name out/yocto_out/ board_name 0-r0/ambfw-1.0 Binary Path out/amba_out/ board_name out/yocto_out/ board_name Table 3 2 List of Firmwares Images and Binaries Image Type Cooper SDK Description Amba Build Yocto Build Firmware Image Binary Firmware Image Binary BST bst.elf bst.img bst.bin bst.elf bst.img bst.bin BST partition binary BLD bld.elf bld.img bld.bin bld.elf bld.img bld.bin BLD partition binary for normal boot BL2 bl2.elf bl2.img bl2.bin bl2.elf bl2.img bl2.bin BL2 partition binary for secure boot FIP fip.elf fip.img fip.bin fip.elf fip.img fip.bin FIP partition binary for secure boot ENV env.elf env.img env.bin env.elf env.img env.bin ENV partition binary DTB dtb.elf dtb.img dtb.bin dtb.elf dtb.img dtb.bin ENV partition binary KERNEL kernel.elf kernel.img kernel.bin kernel.elf kernel.img kernel.bin Kernel partition binary PBA pba.elf pba.img pba.bin PBA partition binary ROOTFS rootfs.elf rootfs.img rootfs.bin rootfs.elf rootfs.img rootfs.bin Rootfs partition binary ALL bst_bld_env_dtb_kernel_rootfs.elf or bst_bl2_fip_env_dtb_kernel_rootfs.elf Secure Boot bst_bld_env_dtb_kernel_rootfs.elf or bst_bl2_fip_env_dtb_kernel_rootfs.elf Secure Boot Firmware for all partitions Normal Boot ALL bst_bl2_fip_env_dtb_kernel_rootfs.elf bst_bl2_fip_env_dtb_kernel_rootfs.elf Firmware for all partitions Secure Boot The final generated firmware contains images and binaries used by the following partitions respectively Images ENV DTB KERNEL PBA Binaries BST BLD ROOTFS BL2 FIP These images and binaries are also used by the Image Upgrade For Legacy Firmware Layout Table 3 3 List of Firmwares Images and Binariesâ Path Type Cooper SDK CV2x SDK 3.0 Amba Build Yocto Build Amba Build Firmware Path out/amba_out/ board_name out/yocto_out/ board_name out/ board_name Image/Binary Path out/amba_out/ board_name out/yocto_out/ board_name BST BLD ATF DTB out/ board_name KERNEL PBA out/ board_name ROOTFS out/ board_name Table 3 4 List of Firmwares Images and Binaries Image Type Cooper SDK CV2x SDK 3.0 Description Amba Build Yocto Build Amba Build Firmware Image Binary Firmware Image Binary Firmware Image Binary BST bst_release.elf bst.bin bst_release.elf bst.bin bst_release.elf bst_release.bin BST partition image BLD bld_release.elf bld.bin bld_release.elf bld.bin bld_release.elf bld_release.bin BLD partition binary for normal boot ATF atf_release.elf atf.bin atf_release.elf atf.bin atf_release.elf atf_release.bin ATF partition binary for secure boot FIP fip_release.elf fip.bin fip_release.elf fip.bin fip_release.elf fip_release.bin BLD partition binary for secure boot DTB dtb.bin dtb.bin board_name dtb DTS binary stored in PTB partition KERNEL kernel_release.elf kernel.bin or Image.SIGNED secure boot kernel_release.elf kernel.bin or Image.SIGNED secure boot kernel_release.elf Image or Image.SIGNED secure boot PRI partition binary PBA pba_release.elf pba.bin or Image.SIGNED secure boot pba_release.elf pba_zImage or pba_zImage.SIGNED secure boot PBA partition binary ROOTFS lnx_release.elf rootfs.bin lnx_release.elf rootfs.bin lnx_release.elf ubifs Take UBIFS as an example LNX partition binary ALL bst_bld_kernel_lnx_release.elf or bst_bld_atf_kernel_lnx_release.elf Secure Boot bst_bld_kernel_lnx_release.elf or bst_bld_atf_kernel_lnx_release.elf Secure Boot bst_bld_kernel_lnx_release.elf or bst_bld_atf_kernel_lnx_release.elf Secure Boot Firmware for all partitions For legacy firmware layout there is no difference between images and binaries They are all raw binaries These images binaries are also used by Image Upgrade The default configuration for the platform is to boot from flash with the file system on the EVK board s NAND flash In some cases only Ethernet access is available This section describes upgrading the NAND flash file system by using the trivial file transfer protocol TFTP server There are two different methods to perform the upgrade upgrade_partition and AMBoot shell The upgrade_partition tool helps users manage the Ambarella boot configuration in rootfs and enables them to set up the Ambarella bootloader options easily without inputting much command lines to the AMBoot shell Table 3 5 List of TFTP Upgrade Commands TFTP Upgrade for Flexible Firmware Layout in the Linux System TFTP Upgrade for Legacy Firmware Layout in the Linux System TFTP Upgrade in the AMBoot Shell Description upgrade_partition e auto_boot 0 upgrade_partition auto_boot 0 setenv auto_boot 0 1 Load Linux kernel from NAND flash or 0 upgrade_partition e E i 0 mac 2 0 1 1 0 9 1 9 1 0 3 9 upgrade_partition ethmac 2 0 1 1 0 9 1 9 1 0 3 9 setenv eth 0 mac 2 0 1 1 0 9 1 9 1 0 3 9 Eth0 MAC address upgrade_partition e E i 0 ip 10.0.0.2 upgrade_partition lan_ip 10.0.0.2 setenv eth 0 ip 10.0.0.2 Eth0 IP address upgrade_partition e E i 0 mask 255.255.255.0 upgrade_partition lan_mask 255.255.255.0 setenv eth 0 mask 255.255.255.0 Eth0 netmask upgrade_partition e E i 0 gw 10.0.0.1 upgrade_partition lan_gw 10.0.0.1 setenv eth 0 gw 10.0.0.1 Eth0 default gateway upgrade_partition e tftpd_ip 10.0.0.1 upgrade_partition tftpd 10.0.0.1 setenv tftpd 10.0.0.1 TFTP server IP address reboot reboot Reboot to enter into Amboot tftp program firmware.bin 0 x4000000 1 tftp program firmware.bin 0 x4000000 1 tftp program firmware.bin 0 x4000000 1 Use tftp to download the firmware and program it Assume that the in the first column is the ENV partition Prepare the TFTP upgrade The user must confirm that the Ethernet cable is connected and the TFTP server is running on the host PC If the user uses the upgrade_partition tool the following option must be selected For CV2x SDK 3 0 Amba build For Cooper Amba Build For Cooper Yocto Build The AMBoot must enable the Ethernet to download the firmware The following option must be selected For CV2x SDK 3 0 Amba build For Cooper Amba Build For Cooper Yocto Build The generated firmware path can be found in the following path For CV2x SDK 3.0 ambarella/out/ board_name bin For Cooper SDK Amba Build ambarella/out/amba_out/ board_name bin For Cooper SDK Yocto Build ambarella/out/yocto_out/ board_name bin The user must place the firmware in the TFTP server s directory The user might need to rename the default firmware name The firmware name size must not exceed the TFTP server s limitation 3 2 characters Configure the TFTP parameters For upgrade_partition For flexible firmware layout For legacy firmware layout For AMBoot shell Display the current settings For AMBoot shell Enter AMBoot download and program the firmware Type the following command to start the upgrade The downloading progress is shown below Figure 3-1 Enter Netboot Mode When the firmware download is complete the message is displayed on the serial console The EVK board boots if the firmware is configured to automatically boot after the download is complete If the firmware is not configured to automatically boot press the RESET button on the EVK board to load the firmware This section describes the usage of the SD upgrade If the default build configuration make cvx_ipcam_config is used only one BLD BST kernel and rootfs will be generated After the compilation is complete there will be six files in ambarella out cvx_board images Table 3 6 Firmwares for SD Upgrade Image Name Description bst_release.bin BST partition binary bld_release.bin BLD partition binary bst_bld_release.bin BST and BLD partition binary kernel_release.bin PRI partition binary kernel image lnx_release.bin LNX partition binary root file system bst_bld_kernel_lnx_release.bin All the binary files including PTB partition binary In the serial console window press and hold the ENTER key on the keyboard and then press the RESET button on the EVK board The EVK board will switch to the AMBoot shell Then users can type the following commands to upgrade different partitions The binary name is shown in the 3 2 1 Images for SD Upgrade In some cases the user might want to change some partition images stored in the development board rather than replacing the entire firmware This section will introduce the upgrade methods and procedures to fullfill this goal In Ambarella SDK design two image upgrade modes are recommended AB Upgrade and PBA Upgrade AB Upgrade Advantages During AB upgrade the system functions can still run normally If the AB upgrade fails the system which performing the upgrade operation can still run normally Rolling back to the previous system version at any time is possible If the current file system has been damaged rolling back to another file system to restore it is possible Disadvantages Compared to PBA upgrade an additional rootfs partition must be allocated to enable the AB upgrade function The system version control must be performed to prevent a system version rollback AB upgrade flow for flexbile firmware layout Figure 3-2 AB Upgrade Flow for Flexbile Firmware Layout AB upgrade flow for legacy firmware layout Figure 3-3 AB Upgrade Flow for Legacy Firmware Layout PBA Upgrade Advantages ROM only requires one additional partition for PBA PBA is a small system used to perform online upgrades only additional rootfs are not required The ROM size for PBA partition is just a little bigger than size of the kernel image Users are not required to pay extra attention to the system version If the PBA upgrade is interrupted unexpectedly the user can still enter the PBA system to do the upgrade again Disadvantages If the PBA upgrade failed the only way to restore the system is to upgrade again in PBA system The system cannot roll back to the previous system version PBA upgrade flow for flexbile firmware layout Figure 3-4 PBA Upgrade Flow for Flexbile Firmware Layout PBA upgrade flow for legacy firmware layout Figure 3-5 PBA Upgrade Flow for Legacy Firmware Layout No matter what upgrade method is used there is only one copy for BST BLD and ATF BL2 secure boot partition They are shared by the kernel and the rootfs that have two copies If any of them except BST fails to boot after upgrade the user can restore them through the BAK partition which can save backups for these partitions In rare cases new upgrade kernel may be not compatible with the old BLD image in the board the user must upgrade the BLD BST and ATF BL2 may be also needed together with the kernel in such cases For BST if it fails to boot the only way to rescue it is to let the system enter force USB boot mode and download the firmware through the AmbaUSB tool So users are suggested not to upgrade this partition unless necessary The upgrade_partition tool used for upgrading the images are not compatible for flexible and legacy firmware layout PBA upgrade is not supported by the Yocto Build For flexible firmware layout No matter what upgrade method is used there is only one copy for BST BLD BL2 secure boot and ENV partition They are shared by the kernel and the rootfs that have two copies There are two DTB partitions that store different boot arguments for switching to the rootfs to be used ENV partition has two copies in one partition by default in case of the data corruption the user must take care of this when modifying it in the apps ENV partition is used to switch the DTB kernel and rootfs partitions to be used For legacy firmware layout No matter what upgrade method is used there is only one copy for BST BLD ATF secure boot and PTB partition They are shared by the kernel and the rootfs that have two copies The DTB is also stored in the PTB partition and PTB partition has two copies in one partition by default in case of the data corruption The user must take care of this when modifying it in the apps From the following tables the user can get a quick overview on where to get the images used by the upgrade For Flexible Firmware Layout Table 3 7 Images for Image Upgrade Image Type Cooper SDK Description Amba Build Yocto Build BST out/amba_out/ board_name bin out/yocto_out/ board_name bin BST partition binary BLD out/amba_out/ board_name bin out/yocto_out/ board_name bin BLD partition binary for normal boot BL2 out/amba_out/ board_name bin out/yocto_out/ board_name bin BL2 partition binary for secure boot FIP out/amba_out/ board_name bin out/yocto_out/ board_name bin FIP partition binary for secure boot ENV out/amba_out/ board_name img out/yocto_out/ board_name 0-r0/ambfw-1.0 img ENV partition binary DTB out/amba_out/ board_name img out/yocto_out/ board_name 0-r0/ambfw-1.0 img ENV partition binary KERNEL out/amba_out/ board_name img out/yocto_out/ board_name 0-r0/ambfw-1.0 img Kernel partition binary PBA out/amba_out/ board_name img PBA partition binary ROOTFS out/amba_out/ board_name bin out/yocto_out/ board_name bin Rootfs partition binary For Legacy Firmware Layout Table 3 8 Images for Image Upgrade Image Type Cooper SDK CV2x SDK 3.0 Description Amba Build Yocto Build Amba Build BST out/amba_out/ board_name bin out/yocto_out/ board_name bin out/ board_name bin BST partition image BLD out/amba_out/ board_name bin out/yocto_out/ board_name bin out/ board_name bin BLD partition binary for normal boot ATF out/amba_out/ board_name bin out/yocto_out/ board_name bin out/ board_name bin ATF partition binary for secure boot FIP out/amba_out/ board_name bin out/yocto_out/ board_name bin out/ board_name bin BLD partition binary for secure boot DTB out/amba_out/ board_name bin out/yocto_out/ board_name bin out/ board_name board_name dtb DTS binary stored in PTB partition KERNEL out/amba_out/ board_name bin or Image.SIGNED secure boot out/yocto_out/ board_name bin or Image.SIGNED secure boot out/ board_name or Image.SIGNED secure boot PRI partition binary PBA out/amba_out/ board_name bin or Image.SIGNED secure boot out/ board_name or pba_zImage.SIGNED secure boot PBA partition binary ROOTFS out/amba_out/ board_name bin out/yocto_out/ board_name bin out/ board_name Take UBIFS as an example LNX partition binary For secure boot the DTB binary together with bld.bin is packed into the fip.bin the DTB binary stored in DTB or PTB partition takes no effect unless CONFIG_RELOAD_UNTRUSTED_DTB is selected in menuconfig To perform the upgrade operation the Ambarella SDK provides a tool named upgrade_partition for the user The user can use this tool in both upgrade modes The user can select this tool in menuconfig For CV2x SDK 3.0 Amba build For Cooper Amba build For Cooper Yocto build The user can type the upgrade_partition in console to get the usages or refer to the upgrade examples 3.4.5 AB Upgrade Example for Flexible Firmware Layout and 3.4.7 AB Upgrade Example for Legacy Firmware Layout Here are some examples for upgrade_partition For flexible firmware layout Upgrade boot arguments For flexible firmware layout the user must update the bootargs with cautions The upgrade_partition tool can change the stored in ENV partition it can t change the stored in DTB partition If the in ENV partition is not NULL this will replace the one in memory loaded from DTB during the amboot stage If the in ENV partition is NULL AMboot will use the stored in DTB partition If the user really wants to change the stored in DTB partition the only way is to change it in amboot The user can also change the stored in ENV partition through the AMBoot shell If the stored in DTB partition is back to use the user must clear the stored in ENV partition Upgrade dtb2 partition and switch to it Upgrade kernel2 partition and switch to it For legacy firmware layout Upgrade DTB and update boot arguments in DTB Upgrade pba partition kernel and switch to it It is better to switch to a second rootfs system to update the first rootfs system or it may cause a system crash For the sake of safety the digital signature check can be added into the image updating flow to ensure that only the correct and untampered firmware can be flashed to the board The Ambrella SDK provides a digital signature tool and related APIs to do this The security package is located at For CV2x SDK 3.0 ambarella/packages/security For Cooper SDK ambarella/security Digital Signature Tool This tool can generate key pairs sign the firmwares and verify signatures in the host Linux PC The user can build this using the following command The tool key_tool_ed25519 will be generated under key_tools/pkey_tool_native/ The user can write the public key into the security OTP for succeeding signature verifications during firmware upgrading stage The user must keep the generated private key in safe in order to sign the firmwares to be used in the subsequent upgrade operation The used private and public keys must be a pair which are generated together Key Verification The key verification APIs reside at security/lw_cryptography/include/curve25519.h The user can read the public key from the OTP and call these APIs to verify the firmware signature in the upgrade application The user can refer to the examples under security/lw_cryptography/unit_test on how to use these APIs The Digital Signature Check Flow Figure 3-4 Digital Signature Check for Image Updating For flexible firmware layout two DTB partitions are used to do the switch between the system A and the system B Take CV72_gage as an example perform the following steps to setup AB upgrade for flexible firmware layout Allocate the and partition size The generated root file system rootfs size may be larger than the partition size the user can remove some unwanted configurations in menuconfig Ensure that the total size 6 M(kernel offset) 1 6 M 2 1 0 8 M 2 2 5 4 M is smaller than the NAND flash total size The space 6 M before the kernel is big enough for the bst bld dtb dtb2 env and cfg in this example The partition allocation above is not suitable for embedded multi-media controller eMMC When eMMC is used the user must allocate the partition according to the actual need especially for the rootfs size Create a dts file and change the bootargs for the system B When eMMC is used the bootargs for system A and system B appear as follows if the partition layout in step 1 is used For the X is the sequence number of the partitions counting from 1 bst Create a Makefile to build the dtb2.bin using the DTS file in step 2 Create a profile for the firmware to be generated It is better to keep the flags the same for doubled partitions in the profile above Create a new env file for partition if needed or use the default one located at boot/amboot/src/bld/default.env This file can determine which dtb kernel and rootfs partions are used for booting up the EVK board Configure the AB system in menuconfig For Cooper Amba Build For Cooper Yocto Build Build the firmware and program it to the EVK board The generated firmware ambarella/out/amba_out/cv72_gage/bst_bld_env_dtb_dtb2_kernel_kernel2_rootfs_rootfs2.elf Prepare the images for AB upgrade used by the upgrade_partition tool For the images to be used the user can refer to 3.4.2 Images for Upgrading and copy them to a SD card such as under a upgrade folder Get the allocated partitions For NAND For eMMC Here is not an eMMC partition allocation example for AB upgrade just for showing the eMMC partitions The partition name can be obtained from device-tree information Insert the SD card and upgrade the system B partitions s image Assume the SD card will be auto-mounted to If eMMC is used the user can clean the data first and then upgrade the partition image If eMMC boot partition is used as BST partition the user must get the written permission first and then upgrade it Switch to system B For debugging purpose the user can switch to system B in AMBoot PBA upgrade is only supported by the Amba build For flexible firmware layout two DTB partitions are used to do the switch between the main system and the PBA system Take CV72_gage as an example perform the following steps to setup PBA upgrade for flexible firmware layout Allocate the and partition size Ensure that the total size 6 M(kernel offset) 3 2 M 1 7 6 M 3 2 M 2 4 6 M is smaller than the NAND flash total size The space 6 M before the kernel is big enough for the bst bld dtb dtb2 env and cfg in this example The partition allocation above is not suitable for eMMC When eMMC is used the user must allocate the partition according to the actual need especially for the rootfs size Create a dts file and change the bootargs for the PBA system When eMMC is used the boot arguments for the main system and PBA system appear as follows if the partition layout in step 1 is used For the X is the sequence number of the partitions counting from 1 bst Create a Makefile to build the dtb2.bin using the DTS file in step 2 The leading indentation before must be generated by key Create a profile for the firmware to be generated Create a new env file for partition if needed or use the default one located at boot/amboot/src/bld/default.env This file can determine which DTB kernel and rootfs partions are used for booting up the EVK board Enable PBA function in menuconfig Build the firmware and program it to the EVK board The generated firmware ambarella/out/amba_out/cv72_gage/bst_bld_env_dtb_dtb2_kernel_pba_rootfs.elf Prepare the images for PBA upgrade used by the upgrade_partition tool For the images to be used the user can refer to 3.4.2 Images for Upgrading and copy them to a SD card such as under a upgrade folder Enter PBA For debugging purpose the user can switch to PBA system in AMBoot Get the allocated partitions For NAND For eMMC Here is not a partition allocation example for PBA upgrade just for showing the eMMC partitions The partition name can be obtained from device-tree information Insert the SD card and upgrade the main system partitions image If eMMC boot partition is used as BST partition the user must get the written permission first and then upgrade it Switch back to the main system For debugging purpose the user can switch to PBA system in AMBoot For legacy firmware layout a boot flag is used to do the switch between the system A and the system B Take CV22_gage as an example perform the following steps to setup AB upgrade for legacy firmware layout Allocate the pba and rom partition size The partition allocation above is not suitable for eMMC When eMMC is used the user must allocate the partition according to the actual need especially for the rootfs size Modify the bootargs for booting up the system A Although the boot arguments bootargs can be set in the menuconfig it is sugguested to keep the same as the one set in DTS file Because the bootargs set in menuconfig will not be compiled into the DTB image It takes effect only in the programming stage When eMMC is used the bootargs for the main system and PBA system appear as follows if the partition layout in step 1 is used For the X is the sequence number of the partitions counting from 1 bst Modify the ambarella/boards/ board_name c The bootloader must obtain the boot flag boot_opt to determine which bootargs to be used and from which partition to load the kernel PRI or PBA Configure the AB system in menuconfig For CV2x SDK 3 0 Amba build For Cooper Amba build For Cooper Yocto build The generated rootfs size may be larger than the partition size allocated in step 1 the user can remove some unwanted configurations in menuconfig to reduce the size Build the firmware and program it to the EVK board For SDK 3 0 Amba Build The generated firmware path ambarella/out/cv22_walnut/images/bst_bld_pba_kernel_romfs_lnx_release.elf For Cooper SDK The generated firmware path ambarella/out/ amba|yocto _out/cv22_walnut/images/bst_bld_pba_kernel_romfs_lnx_release.elf The firmware program log Usually when programming the firmware into the flash in AMBoot through the AmbaUSB tool the available dynamic random access memory DRAM size must be large enough to store the whole firmware Because before the firmware is programmed into the flash it will be loaded into the DRAM first If the user s hardware DRAM resources are strained there are two ways for the user to handle this situation Program these partitions respectively through the AmbaUSB tool Build a normal firmware and program the extra partitions respectively via the upgrade_partition tool the same as the image upgrade operations Prepare the images for AB upgrade used by the upgrade_partition tool For the images to be used the user can refer to 3.4.2 Images for Upgrading and copy them to a SD card such as under a upgrade folder Verify the partition after booting up the board Verify the partitions For NAND For eMMC Here is not a partition allocation example for AB upgrade just for showing the eMMC partitions The partition name can be got from device-tree info Switch to the system B Switch back to the system A Insert the SD card and upgrade the system B partitions image Assume the SD card will be auto-mounted to If eMMC is used the user can clean the data first and then upgrade the partition image If eMMC boot partition is used as BST partition the user must get the written permission first and then upgrade it Switch to the system B For legacy firmware layout a boot flag is used to do the switch between the main system and the PBA system Take CV22_gage as an example perform the following steps to setup PBA upgrade for legacy firmware layout Alloc the PBA partition size The partition allocation above is not suitable for eMMC When eMMC is used the user must allocate the partition according to the actual need especially for the rootfs size Modify the bootargs for booting up the main system Although the bootargs can be set in the menuconfig it is sugguested to keep the same as the one set in DTS file Because the bootargs set in menuconfig will not be compiled into the DTB image It takes effect only in the programming stage For the X is the sequence number of the partitions counting from 1 bst When eMMC is used the bootargs for the main system appear as follows if the partition layout in step 1 is used Modify the ambarella/boards/ board_name c The bootloader must obtain the boot flag boot_opt to determine which bootargs to be used and from which partition to load the kernel PRI or PBA Configure the PBA system in menuconfig For CV2x SDK 3 0 Amba build For Cooper Amba build To save the storage size the user can remove some unwanted kernel and rootfs configurations in menuconfig to reduce the firmware size Build the firmware and program it to the EVK board For SDK 3 0 Amba Build The generated firmware path ambarella/out/cv22_walnut/images/bst_bld_pba_kernel_lnx_release.elf For Cooper SDK The generated firmware path ambarella/out/ amba|yocto _out/cv22_walnut/firmware/bst_bld_pba_kernel_lnx_release.elf The firmware program log Prepare the images for PBA upgrade used by the upgrade_partition tool For the images to be used the user can refer to 3.4.2 Images for Upgrading and copy them to a SD card such as under a upgrade folder Verify the partition after booting up the board Verify the partitions For NAND For eMMC Here is not a partition allocation example for PBA upgrade just for showing the eMMC partitions The partition name can be obtained from device-tree information Switch to the PBA system Switch back to the main system Insert the SD card and upgrade the main system partitions image The SD card might not be auto-mounted The user can use the following command to mount the SD card Then perform the upgrade opertations If eMMC is used the user can clean the data first and then upgrade the partition image If eMMC boot partition is used as BST partition the user must get the written permission first and then upgrade it Switch to the main system Sometimes the system on chip SoC cannot start normally after the system is upgraded The reasons for this may include an issue with the upgraded firmware itself or bad blocks appearing in the firmware storage medium among others To handle this abnormal situation the software development kit SDK provides an automatic recovery solution This chapter contains the following sections Section 4.1 Partition Auto-Recovery Introduction Section 4.2 Example: Build the Recovery Image Section 4.3 Example: Partition Auto-Recovery Test Section 4.4 MCU Communication Protocol Introduction This section introduces the partition auto-recovery mechanism The recovery mechanism requires the assistance of the microcontroller unit MCU because after the system fails to start the SoC may not be able to pull up the recovery pin to enter recovery mode by itself After the MCU pulls up the designated recovery pin the SoC will enter into recovery mode and execute the bootloader stored in the BAK partition to perform the recovery operation Figure 4-1 Partition Auto-Recovery Flow After the system boots up successfully in one partition the SoC will send this partition boot success report to the MCU through the universal asynchronous receiver transmitter UART and the MCU will record the partition state If the MCU does not receive a boot success report within the timeout when the system boots in a certain partition the MCU restarts the SoC After restarting N times if the corresponding boot success report is still not received the MCU will pull up the recovery pin of the SoC and then restart the SoC to let the SoC enter recovery mode After entering recovery mode the SoC will query the failed partitions from the MCU and then perform the recovery operation for the corresponding partitions After the partitions are restored successfully the SoC notifies the MCU that the recovery was successful Then the MCU pulls low the recovery pin and restarts the SoC The following example describes how to enable the partition auto-recovery function Enable the recovery function and select the UART interface to communicate between the SoC and the MCU UART1 is used as an example here After enabling the recovery function the BST BLD and ATF images will be packed into the BAK image For CV2x SDK 3 0 Amba build For Cooper Amba build For Cooper Yocto build The Build Compressed Recovery Firmware Images can be selected to save the size of the BAK partition The baudrate used by UART is set to 1 1 5 2 0 0 by default in the BLD A simple communication protocol is used between the SoC and the MCU 4 4 Communication Protocol Introduction Though BST is packed into the BAK image if BST is corrupted in current running system the recovery mechanism will not run Because the recovery mechanism is based on a working BST Add the kernel image to the BAK image For CV2x SDK 3 0 Amba build For Cooper SDK Amba build For Cooper SDK Yocto build Add the fs image to the BAK image For CV2x SDK 3 0 Amba build For Cooper SDK Amba build For Cooper SDK Yocto build Allocate the BAK partition in ambarella/boards/ board_name h The BAK partition must be large enough to accommodate the sum of the images selected above Configure the recovery pin in ambarella/boards/ board_name ini The general purpose input output GPIO 1 0 6 is used as an example here Configure the UART1 mentioned above which can be used to report the Linux boot state in the file system Build and burn the firmware ambarella/out/cvx_board/images/bst_bld_atf_pba_kernel_backup_lnx_release.elf on CV2x SDK 3.0 or ambarella/ amba|yocto _out/cvx_board/firmware/bst_bld_atf_pba_kernel_backup_lnx_release.elf on Cooper SDK to the board This example is tested on an eMMC boot device Verify the partition after booting up the board If the boot media is an eMMC device use the following command to check the specified partition instead of cat which is used for the memory technology device MTD such as NAND Upgrade the BLD using a corrupted image or erase the BLD or Inform the MCU to restart the SoC through UART1 in the file system or power cycle the whole device Wait for the auto recovery operation the logs from the SoC are as shown below Figure 4-2 Partition Auto Recovery Log After recovery the SoC will be restarted by the MCU and then boot normally This communication protocol is used between the SoC and the MCU Its fields are defined as follows Figure 4-3 Communication Protocol The protocol implementation can be found under ambarella/amboot/src/bld/recovery</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">page_sysdoc_lychee_os</field>
    <field name="url">dc/da7/page_sysdoc_lychee_os.html</field>
    <field name="keywords"></field>
    <field name="text">BASE Lychee OS BASE Lychee OS Lychee OS History System Version Updated Date Modification 2 0 2 3 1 2 a 2 0 2 3 1 2 2 6 Initial Version Lychee operating system OS is built on the Fedora desktop system and it is a specialized Linux distribution tailored for Ambarella system on chip SoC featuring CortexÂ® A76 A78 architecture and optimized for high performance Built upon the foundation of Fedora Lychee OS leverages Fedora s extensive software repository utilizing it as the primary open-source software OSS source The distribution employs customized compile options specifically designed for the Cortex A76 A78AE architecture of Ambarella SoC Lychee OS is compatible with CV5 CV72 and CV3 with the added advantage of graphics processing unit GPU acceleration for the graphical user interface GUI on CV3 Figure 1-1 LycheeOS Logo Lychee OS incorporates a comprehensive set of development tools encompassing GCC Clang LLVM RUST Golang BCC Perl Python Lua and Java As a natively compiled system it is proficient in generating full-feature OSS while being optimized for both feature richness and code size reduction The distribution uses Red Hat Packet Manager RPM package management ensuring explicit package dependency checks for enhanced reliability What s more Lychee OS supports a variety of popular open source middleware of multimedia autonomous-driving and robotics such as GStreamer Apollo CyberRT and ROS2 Users can easily install utilize and develop these open source modules with Lychee OS Figure 1-2 Render Point Cloud with Rviz2 in LycheeOS Desktop Figure 1-3 NN Inference with GStreamer in LycheeOS Desktop Quicker Reduce compile time improve work efficiency connect the user s keyboard and mouse compile drivers and applications on Ambarella CV3 CV72 with Lychee Easier Get just what you need and compile exactly what you need just design a brick but not build a full house from scratch More Standard Drivers and applications can work with different hardware HW configurations and it is no need to recompile for HW changes Similar to a standard PC or smartphone application compile it and drop it will work! Figure 1-4 LycheeOS Desktop Preparation Connect and port with USB cable to the PC Install AmbaUSB application with the version at least 5.0.7 to the PC Prepare an secure digital SD card with at least 6 4 G It is recommended to use a 1 2 8 G SD card but the maximum size cannot exceed 2 5 6 G Select the required version of Uboot At present there are mainly three kinds of Uboot 2 8 0 8 MHz clock 3 2 GB memory 3 1 9 2 MHz clock 3 2 GB memory 3 1 9 2 MHz clock 6 4 GB memory Select the requred version of Lychee OS Please contact the Ambarella support team to obtain the Uboot and Lychee OS Flash Uboot Steps Click and serial consoles There are two important and different consoles MCU Console input sequence to control the CV3 Dk_mini power on off change to USB download mode USB Console print and display the log Click the MCU Console and then enter the p command to power on the CV3 Dk_mini Open the MCU Console and then enter the u command to change the status of MCU to download Download Uboot Open the AmbaUSB application Select CV3 in the chip selection box Click Find button to find prepared Uboot file such as uboot-cooper-sdk-2808MHz.elf Click Download button Wait for the download to complete and view the flash information in the console to determine if the flashing was successful After flashing Uboot enter p in to power off the device There are two methods for installing Lychee OS One method is to automatically run an installation sricpt to automatically install Lychee OS and the other is to manually install it Ambarella recommends the automatic installation method as it is convenient and fast If users require more advanced configurations such as customizing the SD storage space it is recommended to use the manual installation method Both methods only support desktop Linux systems Perpare the Tools Required for Installation gparted This is disk partitioning tool and it is used to partition the SD card lsblk This is a Linux tool used to list information about block devices in the system losetup This is a Linux tool for setting up and controlling loopback devices rsync This is a fast and flexible tool for synchronizing files and directories If these tools are not installed execute the corresponding installation command below according to the user s Linux system Automatical Installation Recommended Insert the SD card into the desktop Linux PC and then run Install_Lychee_Raw_Disk_Image_v4.4.1.sh on desktop Linux PC If the installation is successful the following print information will display Manual Installation Insert the SD card users prepared into your desktop Linux PC Make partitions to this SD card Run sudo gparted command to open the application Delete the original paritions of this SD card Create a new partition table Create the 1 st partition boot partition change the size to 1 GB 1 0 2 4 MB file system type MUST change the partition label to lychee.boot MUST Create the 2 nd partition root partition change the size to 6 0 GB 6 1 4 4 0 MB file system type MUST Change the partition label to lychee.root MUST Create the 3 rd partition home partition change the size to 5 0 GB 5 1 2 0 0 MB file system type MUST change the partition label to lychee.home MUST Confirm that the partitions lychee.root and lychee.boot already exist Mount the boot and root partitions on the SD card Make the loopback device of Lychee OS with losetup tool Copy boot data to boot partition in the SD card Copy root data to root partition in the SD card Uninstall loopback devices Umount lychee.root and lychee.boot Insert the SD card into the CV3 Dk_mini Connect CV3 board to a monitor with full HD resolution 1 9 2 0 x1080 using high definition multimedia interface HDMIÂ® cable Connect eth0 with an Ethernet cable to a router with internet access IMPORTANT Connect the keyboard and mouse to CV3 USB port MUST for the first time boot to do the initial setup Input p in to power on the device then wait for the to show up in the monitor Set up Time Zone in the GUI program Set up Host Name Set up Root User in the GUI program choose Enable root Set up User Account in the GUI program in advanced section add the user to wheel root disk dialout video sys admin group Press Finish in the GUI program After pressing the Finish button wait approximately 5 minutes as the system is running selinux-autorelabel.service User Group Explaination Table 2 1 User Group Explaination Group Explaination wheel Users in wheel group will be granted to run commands that are only allowed for root root Users in root group will be granted to access files in root group disk Users in disk group will be granted to access device node in disk group for example and more dialout Users in dialout group will be granted to access the serial device for example video Users in video group will be granted to access the video device for example and sys Users in sys group will be granted to access file system admin Users in admin group will be granted to access system administrator s tools 1 Set Up MAC Address Set proper address for users network device Select the network card that needs to be connected to the internet and click the Settings button in the lower left corner Select random in the cloned MAC address column in the Ethernet page Save and quit 2 Config System Time Configure to maintain the RTC in universal time and synchronize the RTC from the system clock 3 Update the System Run the command to upgrade the user s system to the latest And in the future if Lychee OS has a newer release users do not require to go through this process again to re-install just need to install Lychee OS repo file and run the command Users should consider this Lychee OS as a complete desktop Linux and use normal user account to login and work Uboot only supports boot partition with ext4 file system type this is probably enhanced in the newer Uboot version The default system language is English which can be changed after logging into Linux desktop 4 Optional Enable Dual-VOUT Check if the default DTB supports dual-VOUT The content may be as shown below note the default label for boot If the default DTB name ambarella-cv3-gpu-dual-vout.dtb in line 7 above for example includes dual-VOUT it means dual-VOUT is supported Or users should change default DTB to one that supports dual-VOUT Or modify dtb to support feature Advanced Change the content in conf in line 7 above for example replace the DTB name with one in step 2 shown such as ambarella-cv3-gpu-4K-llava-dual-vout.dtb Change lua configuration for HDMI VOUT Reboot Lychee and dual-VOUT can be used now Configure Local Repository Get sdk-release-cv3 local repository Contact the Ambarella support team Place the sdk-release-cv3-local-repo-20231115.tar.xz in the dectory Extract files to the folder Create Local SDK repo File Create a yum repo file so that users can use dnf command to manage software packages in Lychee OS Paste the content below to the repo file for dnf to track and configure the local SDK repo Install SDK Packages to the System Local SDK release repo contains packages Install Local SDK release run-time develop debug meta package contains the packages mentioned above If users want to download the source RPM for example EazyAI use the following command To Upgrade SDK Release Packages The commonly used commands for package management in Lychee include Package contains components private-driver cavalry imglib 3 A vproc tof eazydds data-transfer lwmedia xorg-ambafbdev dsp-monitor cvlib utility of Ambarella Cooper SDK Install all of them using the following command For more information about DNF Fedora official document introduction Lychee OS licensed under the MIT license Ambarella SDK software packages license is as follow Copyright c 2 0 2 4 Ambarella International LP This file and its contents are protected by intellectual property rights including without limitation U.S and/or foreign copyrights This Software is also the confidential and proprietary information of Ambarella International LP and its licensors You may not use reproduce disclose distribute modify or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates In the absence of such an agreement you agree to promptly notify and return this Software to Ambarella International LP THIS SOFTWARE IS PROVIDED AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS COMPUTER FAILURE OR MALFUNCTION OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">page_sys_mg_legacy</field>
    <field name="url">dc/dd9/page_sys_mg_legacy.html</field>
    <field name="keywords"></field>
    <field name="text">Migration Guide from CV5x Legacy SDK Migration Guide from CV5x Legacy SDK Updated Date Modification 2 0 2 3 0 4 2 7 Initial Version 2 0 2 3 0 7 2 5 1 Updated Section 3.1 Application Programming Interface API Differences 2 Updated Section 4.1 IAV_IOC_SET_CHAN_CONFIG 2 0 2 3 0 8 0 3 Updated Section 3.1.2 Multi-VIN Stitching 2 0 2 3 1 0 2 5 Added Section 2 Highlights for DSP APIs 2 0 2 4 0 1 2 2 Updated Section 2 Highlights for DSP APIs This document provides users with instructions for migrating single- and multiple-video input VIN channel designs from the CV5x legacy software development kit SDK to the Cooper Linux SDK This chapter describes the highlights for this SDK version compared with the previous SDK version The custom SEI API is added to insert customized SEI for AVC HEVC MJPEG streams and the working flow is refined inside DSP IAV and the API is not fully compatible with CV2x The ISP NN interface are added to support lite NN based motion detection in encode mode 5 The lite NN based motion detection feature is also called The multiple pass API is added to support up to 2 passes This feature is redesigned with 2 channels instead of 2 passes in the same channel With the new design it is possible to generate multiple source buffers from a multi-view canvas IDSP vertical slice related interfaces are added for IDSP veritical slicing feature This can possibly improve the IDSP pipeline latency RAW fps can be specified in the channel cfg It is the fps after VIN stage and before IDSP stage So this fps may possibly be different from sensor fps and IDSP fps The blur color API is added to specify the blur color if needed The stream overlay API is updated to support Y blend only or UV blend only Default is to blend both Y and UV The motion data API is added to support the motion data query The encoded frame num is supported into iav_framedesc and iav_slicedesc to report stream based frame number The new IAV memory IAV_PART_IMG_NN is added to support for image NN buffer which can be used for NN based image processing The option is added in iav_stream_resource and iav_canvas_cfg to enable padding to improve HEVC encoding efficiency The option is added to support extra paddding for stream encoding to eliminate the potential encoding boundary artifacts due to alignment The overlay blur audit is added to audit frame sync failure count The IDSP audit is updated to support grouping frame drop count IDSP channel num is increased from 8 to 1 6 The MJPEG encoding width is limited to be 1 6 aligned and height to be 8 aligned In preview SDK versions both width and height are incorrectly limited to 4 aligned The valid values are 0 2 with value 0 weakest blur effect and 2 strongest blur effect The parameter vout_possible_map must be specified if other than VOUT 1 may be supported VIN ROI related interfaces are added into VIN APIs The RAW width and height information is added into iav_chan_cfg structure which stands for the actual output RAW size information RAW slice related interfaces are added for RAW vertical slicing feature Blur coefficients parameters is added to achieve different blur effects The skip strengh is by default set to 2 for AVC HEVC for better encoding efficiency The AVC scalelist strength is added for better encoding efficiency The blending DPTZ APIs are added to support blending DPTZ runtime update for the canvas The IDSP encode sync API is added to support synchronization for IDSP and encoder The image scalar audit API is added for IDSP clock audit The encoder audit API is added for encoder clock audit The IQ ADJ parameters has been refined with structure changes so it is not fully compatible with previous SDK versions This chapter describes the migration of the software from the CV5x legacy SDK to the Cooper Linux SDK The blur effect in the Cooper Linux SDK is improved to achive better consistency across preview buffers and create more visual effects The maximum-supported blur strength level is extended to four while there are only three strength levels in the legacy SDK When mosaic-like blur is enabled each mosaic block s size will be fixed to 8 x8 1 6 x16 3 2 x32 or 6 4 x64 pixels in the respective strength level This presents more flexibilities for users to choose from different resolutions of preview buffers Pyramid is still required to be enabled for blur but pyramid layer selection is managed entirely in the SDK It is no longer required for users to enable the pyramid layer used by blur Channel groups are not required for blur in the Cooper Linux SDK The new blur coefficients are supported in the Cooper Linux SDK to achieve different blur effects The valid values are 0 2 with value 0 weakest blur effect and 2 strongest blur effect The maximum blur number for a single stream is increased from 8 in CV5x Legacy SDK to 1 6 in Cooper Linux SDK There is less dynamic random-access memory DRAM footprint when the blur is enabled in the Cooper Linux SDK compared to the CV5x legacy SDK In the legacy SDK each canvas s stitching is performed independently In the Cooper Linux SDK the stitching effect is decided by the layout of the main buffers Stitching on sub-buffers is scaled from the main buffer and copied to sub-buffers To skip blend stitching for a certain sub-buffer users should set in the structure iav_canvas_cfg in the legacy SDK and should set in the structure iav_chan_cfg in the Cooper Linux SDK In the Cooper Linux SDK a preview buffer is sacrificed for stitching the fifth buffer on CV5x and the second buffer on other chips In other words the fifth buffer or the second buffer cannot be placed into any canvas or used as pyramid input when stitching is enabled In the Cooper Linux SDK the sixth buffer cannot enable the stitch this restriction doesn t exist in the legacy SDK In the legacy SDK the arbitrary image scaler only supports NV12 and NV16 formats and the format is decided when entering into the preview Ambarella does not support scaling different image formats after preview In the Cooper Linux SDK the arbitrary image scaler supports NV12 NV16 and MONO formats Users can send scaler jobs with mixed YUV formats after preview In the legacy SDK the offset and size of the image scaler all must be aligned to four While the width and x-offset must be aligned to four in the Cooper Linux SDK the height and y-offset must be aligned only to 2 The seventh preview buffer is not supported in the Cooper Linux SDK In the legacy SDK electronic image stabilization EIS uses the two-channel approach and the EIS source channel can run in mode 0 or mode 5 In the Cooper Linux SDK although EIS still uses the two-channel approach the EIS source channel should run in mode 8 This saves system resources as the first EIS channel is only used to generate 3 A auto exposure AE auto white balance AWB auto focus AF statistics data The total overlay number of all streams cannot exceed 6 4 in the Cooper Linux SDK With Cooper Linux SDK the VOUT possible map parameter vout_possible_map must be specified when booting DSP if there is potential requirement to use VOUT 0 2 or multiple VOUT devices If there is only potential VOUT 1 is needed then there is no need to configure this The legacy SDK and the Cooper Linux SDK share the same API files so they include identical IOCTLs and structures Only some structure members may not be required in the Cooper Linux SDK or they may be used for a different purpose This chapter describes software migration and provides IOCTL differences between the legacy SDK and the Cooper Linux SDK The IOCTLs are as follows 3 1 IAV_IOC_SET_CHAN_CONFIG 3 2 IAV_IOC_GET_CHAN_CONFIG 3 3 IAV_IOC_SET_SYSTEM_RESOURCE 3 4 IAV_IOC_GET_SYSTEM_RESOURCE The structure parameter changes are listed below Table 3 1 iav_chan_cfg Structure Definition Parameter Used in legacy Used in Cooper â Not implemented â Not implemented â â â â For rotation pipeline only â â â Refer to the structure parameter change from IOCTL IAV_IOC_SET_CHAN_CONFIG Because the image format of arbitrary image scaler is not required to be specified at preview the member in the structure iav_img_scale_cfg will not be used in the Cooper Linux SDK The following lists the changes in the structure parameter iav_img_scale_cfg for the IOCTL IAV_IOC_SET_SYSTEM_RESOURCE Table 3 2 iav_img_scale_cfg Structure Definition Parameter Used in legacy Used in Cooper â Refer to the structure parameter change from IOCTL IAV_IOC_SET_SYSTEM_RESOURCE CV5x legacy SDK and the Cooper Linux SDK use the same toolchain Question Is it difficult to migrate from the legacy SDK to the Cooper Linux SDK Answer Migrating from the CV5x legacy SDK to the Cooper Linux SDK is simple as they share the same API header files Only a few changes are required for migration Copyright c 2 0 2 4 Ambarella International LP This file and its contents are protected by intellectual property rights including without limitation U.S and/or foreign copyrights This Software is also the confidential and proprietary information of Ambarella International LP and its licensors You may not use reproduce disclose distribute modify or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates In the absence of such an agreement you agree to promptly notify and return this Software to Ambarella International LP THIS SOFTWARE IS PROVIDED AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS COMPUTER FAILURE OR MALFUNCTION OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">page_sysdoc_multi_cluster</field>
    <field name="url">df/d1e/page_sysdoc_multi_cluster.html</field>
    <field name="keywords"></field>
    <field name="text">BASE Multi-Clusters BASE Multi-Clusters SDK Version Updated Date Modification Cooper SDK 1.6.0 2 0 2 3 1 2 2 5 Initial Version This chapter describes the multiple clusters on Ambarella platforms Currently only CV3-DEV-H and CV3AD685 chips can support multiple clusters Platform Cluster CV3-DEV-H 4 clusters x quad-A78 CV3AD685 3 clusters x quad-A78 Each cluster is assigned to an independent Linux kernel Clusters are able to communicate with each other by a virtual ethernet Blazenet Each cluster has its own DRAM address space and IO resource Cluster 0 is the primary cluster others are secondary clusters The primary cluster creates a network file system NFS service for secondary clusters Taking cv3_dk_mini board as an example to show the design concept of multiple clusters Table 2 1 CV3 DK_mini IO Resource Resource Description Dynamic random access memory DRAM 3 2 GiB Universal asynchronous receiver transmitter UART 4 x USB to serial debug UART Ethernet port 4 x port The figure below describes the memory layout of multiple clusters Figure 2-1 CV3 Dk_mini Memory Layout Each secondary cluster has 4 GiB work memory The work memory size of primary cluster is 2 0 4 6 2 MiB it can be computed as below 2 0 GiB is equal to 2 0 4 8 0 MiB KERNEL_RAM_START in config is 0 x1200000 1 8 MiB The size of work memory assigned to primary cluster is 2 0 4 8 0 1 8 2 0 4 6 2 MiB Primary cluster s work memory is declared in bootargs cv3_dk_mini.dts Table 2 2 CV3 Dk_mini IO Assignment cluster tty ethernet blazenet 0 APB_UART eth0 blazenet 0 1 1 AHB_UART0 eth1 blazenet 0 1 2 AHB_UART1 eth2 blazenet 0 2 3 AHB_UART2 eth3 blazenet 0 3 In order to simplify the system design all physical Ethernet ports are assigned to the primary cluster by default In customer own use case they can also assign physical Ethernet to secondary cluster for different purpose The following figure describes the boot flow of multiple clusters Figure 2-2 Multiple Clusters Boot Flow Blazenet is a virtual Ethernet driver which is based on remote processor messaging rpmsg device Blazenet on primary cluster is in rpmsg master mode on secondary cluster is in rpmsg slave mode However Linux kernel does not support rpmsg slave mode Ambarella implements an extra driver to support this mode Enable blazenet during configuration Table 3 1 Blazenet IP Assignment in Each Cluster cluster-0 cluster-1 cluster-2 cluster-3 blazenet 0 1 192.168.1.1 192.168.1.2 X X blazenet 0 2 192.168.2.1 X 192.168.2.2 X blazenet 0 3 192.168.3.1 X X 192.168.3.2 Currently Blazenet IP assignment is hardcode in script rootfs/skeleton/initramfs_sysroot/usr/bin/create_cluster_nfs.sh From secondary clusters point of view blazenet is to communicate with primary cluster only Secondary clusters are unable to directly communicate with each other Enable the ip_forward feature in the primary cluster so that secondary clusters can talk with each other The figure below describes the network routing via primary cluster Figure 3-1 Blazenet Network on CV3 Dk_mini Since seconary clusters are not assigned to any storge devices customers use NFS rootfs as secondary clusters rootfs The NFS service is created by primary cluster the NFS shared folder is The following script is responsible for creating NFS service rootfs/skeleton/initramfs_sysroot/usr/bin/create_cluster_nfs.sh The rootfs of primary and seconary clusters are stored on an extra SD card There are two partitions on SD card and The is primary s rootfs The is seconary s rootfs and it s mounted to by primary cluster which means all seconary clusters share a same rootfs Actually users can specify the rootfs by Linux bootargs cluster_nfsroot cluster_nfsroot primary device seconary device Use the following commands to build the firmware for CV3 Dk_mini Burn the firmware bst_bld_env_dtb_kernel.bin or bst_bld_env_dtb_kernel.elf using AmbaUSB-v6.x version Open other 3 USBs to the serial devices at the PC side after the system is booting up the following will display Figure 5-1 CV3 Dk_mini console The primary cluster successfully enters Linux shell and seconary clusters are blocked waitting for NFS rootfs Ethernet is up connect with host PC at ETH0 Insert a micro SD card into the slot MICRO SD Figure 5-2 CV3 Dk_mini Device Follow the steps below to make the rootfs Ping the host PC in the console of primary cluster ensure that the physical Ethernet can work properly Transfer rootfs.ext4 to the boards using FTP protocol If the host PC is Linux go to out/amba_out/cv3_dk_mini/images and use tool ftp to transfer files If the host PC is Windows use FTP app Filezilla to transfer files Figure 5-3 Filezilla After rootfs.ext4 is successfully transferred to the board users can find it under Create SD partitions Two partitions are required to be created on SD card each partition size should be larger than 1 GiB The number of cylinders for this disk is set to 4 8 9 7 2 8 There is nothing wrong with that but it is larger than 1 0 2 4 and in certain setups it can cause the following issues 1 Software that runs at boot time for example old versions of LILO 2 Booting and partitioning software from other OSs for example DOS FDISK OS/2 FDISK Program rootfs.ext4 into SD partition Now all clusters rootfs are ready reboot the board NOTE Add files to slave clusters rootfs please go to cluster0 s directory Setup network with specified IP or MAC address please refer to following script and add them in sh The Cavalry support on a multi-cluster system can provide users with the same user experience as in a single-cluster environment Users can submit Cavalry jobs on any cluster utilizing libraries such as NNCtrl Cavalry_Mem and tools like cavalry_top provided by Cavalry In multi-cluster setup each Cavalry driver instance on a cluster has its own separate private memory and this can be configured through menuconfig For Cooper Amba build Currently there are certain limitations to the use of multi-cluster Cavalry driver When starting the vector processor VP the primary CPU cluster cluster-0 must start VP before the secondary clusters cluster-1/2/3 When stopping the VP the primary cluster cluster-0 can only stop VP after all secondary clusters cluster-1/2/3 have already stopped VP Copyright c 2 0 2 4 Ambarella International LP This file and its contents are protected by intellectual property rights including without limitation U.S and/or foreign copyrights This Software is also the confidential and proprietary information of Ambarella International LP and its licensors You may not use reproduce disclose distribute modify or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates In the absence of such an agreement you agree to promptly notify and return this Software to Ambarella International LP THIS SOFTWARE IS PROVIDED AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS COMPUTER FAILURE OR MALFUNCTION OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</field>
  </doc>
  <doc>
    <field name="type">source</field>
    <field name="name">system_main_page.h</field>
    <field name="url">df/d43/system__main__page_8h_source.html#l00001</field>
    <field name="keywords"></field>
    <field name="text"></field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">page_sysdoc_rootfs_doc</field>
    <field name="url">df/d7f/page_sysdoc_rootfs_doc.html</field>
    <field name="keywords"></field>
    <field name="text">BASE Rootfs BASE Rootfs Version Updated Date Modification 1.0.0 2 0 2 4 0 1 1 6 Initial Version The Ambarella software development kit SDK can support various root file systems rootfs types The following table lists the rootfs types supported by different SDK builds The user can choose the right one according to the actual needs Table 1 1 Supported Rootfs Types Rootfs Type Cooper SDK CV2x SDK 3.0 Description Amba Build Yocto Build Amba Build UBIFS â â â Unsorted block image file system UBIFS SQUASHFS â â â A compressed read-only file system JFFS2 â â â Journaling flash file system version 2 YAFFS â â â Yet another flash file system EXT2 â â â Second extended file system EXT3 â â â Third extended file system EXT4 â â â Fourth extended file system RAMDISK â â â RAM file system generated based on EXT2 CPIO â â â RAM file system generated by CPIO utility â Supported â Not supported yet This chapter contains the following sections If other rootfs types are used the procedures are similar Section 2.1 UBIFS Guidance Section 2.2 RAMDisk Guidance UBIFS is a filesystem that works on top of unsorted block images UBI volumes which make it have the following features relative to other flash filesystems UBI UBIFS scales to large flash sizes better than JFFS2 Good fault tolerance via a number of features Built-in on-the-fly compression Good runtime performance For legacy firmware layout the user can enable the UBIFS by performing the following steps Take CV22_walnut as an example Allocate the partition size Modify the bootargs in device trees DTS file for mounting the UBIFS The user can also set the bootargs in menuconfig which will replace the one set in DTS file For CV2x SDK 3.0 Amba Build For Cooper SDK Amba Build For Cooper SDK Yocto Build Select the UBIFS in menuconfig For CV2x SDK 3.0 Amba Build For Cooper SDK Amba Build For Cooper SDK Yocto Build Add UBIFS and memory technology device MTD block device support in the kernel Build the firmware For CV2x SDK 3.0 The generated firmware ambarella/out/ board_name elf For Cooper SDK The generated firmware ambarella/out/ amba|yocto _out/ board_name elf RAMDisk file system is a virtual storage location created out of the system memory All read and write requests to RAMdisk file system are processed in memory resulting in a huge improvement in overall performance with ultra-fast speed and ultra-low latency For flexible firmware layout the user can enable the RAMDisk by performing the following steps using CV72_gage as an example Allocate the partition size Select the RAMDisk file system and configure it Modify the bootargs and configure the initial ramdisk start address Use menuconfig to set the initrd start address Modify the bootargs in ambarella/boards/ board_name board_name dts The and the must be set properly in case the kernel image overlaps with the rootfs image which could cause the kernel to fail to boot Add RAMDisk to the firmware Create a ambarella/boards/ board_name ramdisk for firmware layout The for ramdisk must not be set to Because before the ramdisk image is loaded into the dynamic random access memory DRAM the bootloader will first check the ramdisk image s header which is excluded in the raw image Create a DTS file ambarella/boards/ board_name board_name env for firmware layout Enable the profile in menuconfig Enable RAMDisk and RAM block device support in the kernel During the ramdisk booting stage if there are some errors related to the the user can enlarge the ramdisk size by adding to bootargs or enlarging the RAM disk size in kernel and then have a try Build and burn the firmware The generated firmware ambarella/out/amba_out/ board_name elf Copyright c 2 0 2 4 Ambarella International LP This file and its contents are protected by intellectual property rights including without limitation U.S and/or foreign copyrights This Software is also the confidential and proprietary information of Ambarella International LP and its licensors You may not use reproduce disclose distribute modify or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates In the absence of such an agreement you agree to promptly notify and return this Software to Ambarella International LP THIS SOFTWARE IS PROVIDED AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS COMPUTER FAILURE OR MALFUNCTION OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">index</field>
    <field name="url">index.html</field>
    <field name="keywords"></field>
    <field name="text">AMBA System Document Revision History Updated Date Modification 2 0 2 2 0 7 0 5 Initial Version 2 0 2 2 0 7 2 2 Remove CMA Driver check CMA Driver API for detailed information 2 0 2 2 0 7 2 9 Remove DRAM Optimization check DESIGN Memory Layout Optimization for detailed information 2 0 2 2 0 8 0 9 Added new page Power Management 2 0 2 2 0 8 1 2 Added new page Migration Guide From CV2x 2 0 2 2 0 8 2 9 Added new page DRAM Bandwidth Statistics 2 0 2 2 0 9 2 2 Added new structure for this doxygen project content 2 0 2 3 0 9 0 1 Added new page CooperHome 2 0 2 3 1 1 2 3 Updated Section Docker Guide 2 0 2 3 1 2 2 6 Updated Page DEBUG Tools Migration Guide from CV2x Document Overview This document provides guidelines for the mirgration from CV2x SDK to the Cooper Linux SDK The outline of Migration Guide From CV2x is listed as follows Section 0 Revision History Section Section Section Section Section Section Section Section Migration Guide from CV5x legacy SDK Document Overview This document provides guidelines for the mirgration from CV5x legacy SDK to the Cooper Linux SDK The outline of Migration Guide from CV5x Legacy SDK is listed as follows Section 0 Revision History Section Section Section Section Section Section Section AMBoot Documents Overview This document introduces AMBoot documents in the Flexible Linux SDK The outline of BASE AMBoot is listed as follows Section 0 Revision History Section Section Kernel Documents Overview This document introduces Kernel documents in the Flexible Linux SDK The outline of BASE Kernel is listed as follows Section AMBoot Documents Overview This document introduces root file system Rootfs documents in the Flexible Linux SDK The outline of BASE Rootfs is listed as follows Section 0 Revision History Section Section Section CM3 Documents Overview This document introduces CM3 documents in the Flexible Linux SDK The outline of BASE CM3 is listed as follows Section 0 Revision History Section Section Section Section Section Multi-Clusters Documents Overview This document introduces Multi-Clusters in the Cooper Linux SDK The outline of BASE Multi-Clusters is listed as follows Section 0 Revision History Section Section Section Section Section Section Section Lychee OS Documents Overview This document introduces Lychee OS in the Cooper Linux SDK The outline of BASE Lychee OS is listed as follows Section 0 Revision History Section Section Section Section Section Section Boot and Upgrade Documents Overview This document introduces Boot and Upgrade documents in the Flexible Linux SDK The outline of DESIGN Boot Upgrade is listed as follows Section 0 Revision History Section Section Section Section Hardware PTS Document Overview This document provides guidelines for the hardware PTS on the Flexible Linux SDK The outline of DESIGN Timer PTS is listed as follows Section 0 Revision History Section Section Section Section Section Section Section Section Fast Boot Design Overview This document provides guidelines for the fast boot design in the Flexible Linux SDK The outline of DESIGN Fast Boot is listed as follows Section 0 Revision History Section Section Section Section Sensor Calibration User Guide Document Overview This document provides guidelines for the system and software design and also includes information on implementation with the CV2x Flexible Linux SDK The outline of DESIGN Multiple Sensors Calibration is listed as follows Section 0 Revision History Section Section Section Section Section Section Section Section Section Section Section Section Docker is an open source application-container engine that enables developers to package their applications and dependencies into a portable container then publish or virtualize them to any Linux machine Containers are completely sandboxed and do not interface with each other This document provides guidance to run docker tool for CV5x chips and demonstrates how to run the SDK function in Docker The outline of DESIGN Docker Usage Guide is listed as follows Section 0 Revision History Section Section Section Section Section Section Section Section Section Section Section Section Section Section Porting Ubuntu Core System Guide This document provides guidelines for porting Ubuntu core system on the Flexible Linux SDK The outline of DESIGN Porting Ubuntu System is listed as follows Section 0 Revision History Section Section Section Section Section Section Memory Layout Optimization Document Overview These web pages provides guidelines for image digital signal processing DSP DRAM optimization using the Cooper Linux SDK It includes descriptions of the dynamic random-access memory DRAM partitions as well as instructions for using and reducing partition sizes for the small DRAMs provided The outline of DESIGN Memory Layout Optimization is listed as follows Section 0 Revision History Section Section Section Section Section Power Management Document Overview This document provides guidelines for the power management on the Flexible Linux SDK The outline of OPTIMIZATION Power Management is listed as follows Section 0 Revision History Section Section Section Section CooperHome Overview CooperHome is an Ambarella web application that runs on the Ambarella CV2x CV5x CV7x and CV3 systems on chip SoCs using the Cooper software development kit SDK CooperHome provides overview information of the SoC and development board monitors the status of the system starts CPU tasks digital signal processor DSP pipelines and CVflowÂ® tasks with simple clicks profiles the performance of various use cases and captures output data The outline of TOOL CooperHome is listed as follows Section 0 Revision History Section Section Section Section Section Section Dram Bandwidth Statistics Overview This document provides guidelines for the dram bandwidth statistics on the Flexible Linux SDK The outline of DEBUG DRAM Bandwidth Statistics is listed as follows Section Section SDK Debug Tools And Linux Programming Guide This document provides guidelines for the SDK debug tools and Linux programming guide on the Flexible Linux SDK The outline of DEBUG Tools is listed as follows Section 0 Revision History Section Section FAQ Document Overview This document provides guidelines for the frequently asked questions FAQ on the Flexible Linux SDK The outline of DEBUG FAQ is listed as follows Section Section Section Section Section 5 Flash Usage Section 6 GPIO Configuration Section Section Section Section Section Section Section Section Section Section Section Section Section Section License Copyright c 2 0 2 4 Ambarella International LP This file and its contents are protected by intellectual property rights including without limitation U.S and/or foreign copyrights This Software is also the confidential and proprietary information of Ambarella International LP and its licensors You may not use reproduce disclose distribute modify or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates In the absence of such an agreement you agree to promptly notify and return this Software to Ambarella International LP THIS SOFTWARE IS PROVIDED AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS COMPUTER FAILURE OR MALFUNCTION OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</field>
  </doc>
</add>
