<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>System: DESIGN - Boot &amp; Upgrade</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<link rel="search" href="../../search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="System"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-ambarella.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../Ambarella.png"/></td>
  <td id="projectalign">
   <div id="projectname">System<span id="projectnumber">&#160;Cooper_1.6.0 (CV72 &amp; CV3) @ 2024.07.10 14:12:44</span>
   </div>
   <div id="projectbrief">placeholder</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('dc/d8f/si_boot_upgrade.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">DESIGN - Boot &amp; Upgrade </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="boot_upgrade_doc_history"></a>
0. Revision History</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Version   </th><th class="markdownTableHeadLeft">Updated Date   </th><th class="markdownTableHeadLeft">Modification    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">1.0.0   </td><td class="markdownTableBodyLeft">20240115   </td><td class="markdownTableBodyLeft">Initial Version   </td></tr>
</table>
<hr  />
 <h1><a class="anchor" id="si_partition"></a>
1. Partition</h1>
<p >The Ambarella boot loader (AMBoot) uses a prior knowledge of the storge medium to allocate the different partitions for different usages in the compilation. These partitions are logical groups on the storge devices and they have the continuous physical blocks. This chapter explains two styles of firmware layouts supported by AMBoot.</p><ul>
<li>Section <a class="el" href="../../dc/d8f/si_boot_upgrade.html#si_flexible_firmware_layout">1.1 Flexible Firmware Layout</a></li>
<li>Section <a class="el" href="../../dc/d8f/si_boot_upgrade.html#si_legacy_firmware_layout">1.2 Legacy Firmware Layout</a></li>
</ul>
<h2><a class="anchor" id="si_flexible_firmware_layout"></a>
1.1 Flexible Firmware Layout</h2>
<p >For CV72, CV3 and the new evaluation kit (EVK) boards in future, the flexible firmware layout is used. The flexible firmware layout has much merits:<br  />
</p><ul>
<li>Supports up to 128 partitions, and easy to support more</li>
<li>Supports to determine each partition's name by user</li>
<li>Supports the partition size larger than 4 GB</li>
<li>Supports multi images per partition</li>
<li>Supports multi kernel images and multi dtb binaries</li>
<li>Supports to generate images that burners can use directly, that is, no need binsplit<br  />
</li>
</ul>
<p >To use the flexible firmware layout, the user must pay attention to the following three parts to do the configurations.</p>
<ul>
<li><dl class="section user"><dt>Partition Layout</dt><dd>The pre-located partition definition file is <code>ambarella/boards/&lt;board_name&gt;/bsp/bsp.h</code>. The rules for the firmware layout format is as follows: <div class="fragment"><div class="line">partitions <a class="code hl_variableRef" target="_blank" href="../../../library/d1/d82/cJSON_8h.html#adb411a44855a4c49231d72a0fc9a3b3b">format</a>: &lt;devdef&gt;[;&lt;devdef&gt;]</div>
<div class="line">&lt;devdef&gt; <a class="code hl_variableRef" target="_blank" href="../../../library/d1/d82/cJSON_8h.html#adb411a44855a4c49231d72a0fc9a3b3b">format</a>:   dev=&lt;dev&gt;:&lt;partdef&gt;[,&lt;partdef&gt;]</div>
<div class="line">&lt;partdef&gt; <a class="code hl_variableRef" target="_blank" href="../../../library/d1/d82/cJSON_8h.html#adb411a44855a4c49231d72a0fc9a3b3b">format</a>:  &lt;size&gt;[@&lt;offset&gt;](part-<a class="code hl_variableRef" target="_blank" href="../../../library/d1/d82/cJSON_8h.html#a25d22ecc7e656d2c59332072684e8766">name</a>)</div>
<div class="ttc" id="acJSON_8h_html_a25d22ecc7e656d2c59332072684e8766"><div class="ttname"><a href="../../../library/d1/d82/cJSON_8h.html#a25d22ecc7e656d2c59332072684e8766">name</a></div><div class="ttdeci">const char *const name</div></div>
<div class="ttc" id="acJSON_8h_html_adb411a44855a4c49231d72a0fc9a3b3b"><div class="ttname"><a href="../../../library/d1/d82/cJSON_8h.html#adb411a44855a4c49231d72a0fc9a3b3b">format</a></div><div class="ttdeci">char const int const cJSON_bool format</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The <code>dev</code> in &lt;devdef&gt; must be "nand", "snor" or "emmc".</li>
<li>The <code>part-name</code> in &lt;partdef&gt; can be arbitrary, but must be unique.</li>
</ul>
</dd></dl>
Below is a firmware layout example for a NAND flash. <div class="fragment"><div class="line">build$ vim ambarella/boards/&lt;board_name&gt;/bsp/bsp.h</div>
<div class="line"><span class="preprocessor">#define AMBOOT_PARTITION_LAYOUT \</span></div>
<div class="line"><span class="preprocessor">            &quot;dev=nand:&quot;</span> \</div>
<div class="line">            &quot;128k(bst),1024k(bld),896k(dtb),896k(env),128k(cfg),&quot; \</div>
<div class="line">            &quot;32m@0x600000(kernel),176m(rootfs),-(raw)&quot;</div>
</div><!-- fragment --> The bootstrap (BST), bootloader (BLD), device tree blob (DTB), environment (ENV), kernel, and root file system (rootfs) are the default partition names using in AMBoot to generate the firmware image. If the user wants to modify the partition names, the firmware profile for generating the firmware and the ENV file for choosing booting partition must be modified together. <dl class="section note"><dt>Note</dt><dd>For more information, the user can refer to <code>ambarella/boot/amboot/doc/flexible_firmware.txt</code>.</dd></dl>
</li>
<li><dl class="section user"><dt>Firmware Profile</dt><dd>The firmware profile is used for generating the firmware. The default profile is located under directory <code>ambarella/boot/ambfw/profile</code>. The user can create a new one under <code>ambarella/boards/&lt;board_name&gt;/bsp</code> and select it in menuconfig. <div class="fragment"><div class="line">build$ vim bsp/profile.new</div>
<div class="line">IMAGE_FWPROG    := $(BIN_DIR)/fwp.bin</div>
<div class="line"> </div>
<div class="line">IMAGE_0_NAME    := bst</div>
<div class="line">IMAGE_0_FILE    := $(BIN_DIR)/bst.bin</div>
<div class="line">IMAGE_0_ADDR    := -1</div>
<div class="line">IMAGE_0_FLAG    := force <a class="code hl_variableRef" target="_blank" href="../../../library/d1/d82/cJSON_8h.html#a788db922597cf2fb6389e278f822e59f">raw</a></div>
<div class="line"> </div>
<div class="line">IMAGE_1_NAME    := bld</div>
<div class="line">IMAGE_1_FILE    := $(BIN_DIR)/bld.bin</div>
<div class="line">IMAGE_1_ADDR    := -1</div>
<div class="line">IMAGE_1_FLAG    := force <a class="code hl_variableRef" target="_blank" href="../../../library/d1/d82/cJSON_8h.html#a788db922597cf2fb6389e278f822e59f">raw</a></div>
<div class="line"> </div>
<div class="line">IMAGE_2_NAME    := env</div>
<div class="line">IMAGE_2_FILE    := $(BIN_DIR)/env.bin</div>
<div class="line">IMAGE_2_ADDR    := -1</div>
<div class="line">IMAGE_2_FLAG    := force</div>
<div class="line"> </div>
<div class="line">IMAGE_3_NAME    := dtb</div>
<div class="line">IMAGE_3_FILE    := $(BIN_DIR)/dtb.bin</div>
<div class="line">IMAGE_3_ADDR    := -1</div>
<div class="line">IMAGE_3_FLAG    := force</div>
<div class="line"> </div>
<div class="line">IMAGE_4_NAME    := kernel</div>
<div class="line">IMAGE_4_FILE    := $(BIN_DIR)/kernel.bin</div>
<div class="line">IMAGE_4_ADDR    := $(KERNEL_RAM_START)</div>
<div class="line">IMAGE_4_FLAG    := verify compressed</div>
<div class="line"> </div>
<div class="line">IMAGE_5_NAME    := rootfs</div>
<div class="line">IMAGE_5_FILE    := $(BIN_DIR)/rootfs.bin</div>
<div class="line">IMAGE_5_ADDR    := -1</div>
<div class="line">IMAGE_5_FLAG    := <a class="code hl_variableRef" target="_blank" href="../../../library/d1/d82/cJSON_8h.html#a788db922597cf2fb6389e278f822e59f">raw</a></div>
<div class="ttc" id="acJSON_8h_html_a788db922597cf2fb6389e278f822e59f"><div class="ttname"><a href="../../../library/d1/d82/cJSON_8h.html#a788db922597cf2fb6389e278f822e59f">raw</a></div><div class="ttdeci">const char *const const char *const raw</div></div>
</div><!-- fragment --> <div class="fragment"><div class="line">build$ make menuconfig</div>
<div class="line">boot  ---&gt;</div>
<div class="line">[*] ambfw (boot/ambamk)  ---&gt;</div>
<div class="line">  AMBFW Configuration  ---&gt;</div>
<div class="line">    [*] Build AMBFW</div>
<div class="line">      (profile.new) Firmware Profile</div>
<div class="line">[*] amboot (boot/ambamk)  ---&gt;</div>
<div class="line">  Ambarella Bootloader Configuration  ---&gt;</div>
<div class="line">    Firmware Options  ---&gt;</div>
<div class="line">        Firmware Layout Style (Flexible Firmware Layout)  ---&gt;</div>
<div class="line">          (X) Flexible Firmware Layout</div>
</div><!-- fragment --></dd></dl>
</li>
<li><dl class="section user"><dt>ENV File</dt><dd>The ENV file is used to describe the environment variables recognized by AMBoot. The environment variables include the variables specifying which partition image is used for booting. The default ENV file is located at the <code>ambarella/boot/amboot/src/bld/default.env</code>. The user can create a new one with the customized settings named as <code>&lt;board_name&gt;.env</code> or <code>&lt;BSP_BOARD_VER&gt;.env</code> under <code>ambarella/boards/&lt;board_name&gt;/bsp</code> to replace it. The <code>&lt;BSP_BOARD_VER&gt;.env</code> has a higher priority than <code>&lt;board_name&gt;.env</code>. <div class="fragment"><div class="line">build$ vim ambarella/boards/&lt;board_name&gt;/bsp/&lt;board_name&gt;.env</div>
<div class="line">/dts-v1/;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;config.h&quot;</span></div>
<div class="line"> </div>
<div class="line">/ {</div>
<div class="line">    compatible = <span class="stringliteral">&quot;ambarella,environment&quot;</span>;</div>
<div class="line"><span class="preprocessor">    #address-cells = &lt;1&gt;;</span></div>
<div class="line"><span class="preprocessor">    #size-cells = &lt;1&gt;;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#if defined(AMBOOT_DEV_AUTO_BOOT)</span></div>
<div class="line">    auto_boot;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    serial_num = AMBOOT_DEFAULT_SN;</div>
<div class="line"> </div>
<div class="line">    bootcmd = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    bootargs = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    kernel_meta {</div>
<div class="line">        partition = <span class="stringliteral">&quot;kernel&quot;</span>;</div>
<div class="line">        binary_id = &lt;0&gt;;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    dtb_meta {</div>
<div class="line">        partition = <span class="stringliteral">&quot;dtb&quot;</span>;</div>
<div class="line">        binary_id = &lt;0&gt;;</div>
<div class="line">    };</div>
<div class="line">    rootfs_meta {</div>
<div class="line">        partition = <span class="stringliteral">&quot;rootfs&quot;</span>;</div>
<div class="line">        binary_id = &lt;0&gt;;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    netdev_eth0 {</div>
<div class="line">        mac = <span class="stringliteral">&quot;00:00:00:00:00:00&quot;</span>;</div>
<div class="line">        mask = <span class="stringliteral">&quot;0.0.0.0&quot;</span>;</div>
<div class="line">        gw = <span class="stringliteral">&quot;0.0.0.0&quot;</span>;</div>
<div class="line">        ip = <span class="stringliteral">&quot;0.0.0.0&quot;</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    tftpd {</div>
<div class="line">        server,ip = <span class="stringliteral">&quot;0.0.0.0&quot;</span>;</div>
<div class="line">        kernel,file = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">        kernel,addr = &lt;0x00000000&gt;;</div>
<div class="line">        ramdisk,file = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">        ramdisk,addr = &lt;0x00000000&gt;;</div>
<div class="line">    };</div>
<div class="line">};</div>
</div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information, the user can refer to <a href="../../txt/env.txt" target="_blank"><b>env.txt</b></a></li>
<li>When programmed to the EVK board, the ENV image allocates two copies in ENV partition on the storage medium. If any one of the ENV image is corrupted, the other one will be used to automatically recover the corrupted one.</li>
</ul>
</dd></dl>
</li>
</ul>
<h2><a class="anchor" id="si_legacy_firmware_layout"></a>
1.2 Legacy Firmware Layout</h2>
<p >For CV2x and CV5x, the legacy firmware layout is used. The legacy firmware layout is easy to use and has been used and verified by many customers over the years. Only the following partitions are supported: BST, BLD, PTB, ATF, PBA, PRI, SEC, BAK, RMD, ROM, DSP, LNX, SWP, ADD, ADC, CFG, and RAW. It has some limitations. For example, it is not allowed to add other more partitions, each partition's name is also unchangeable and so on.<br  />
 The file path for partition definition is <code>ambarella/boards/&lt;board_name&gt;/bsp/bsp.h</code>. </p><div class="fragment"><div class="line">build$ vim ambarella/boards/&lt;board_name&gt;/bsp/bsp.h</div>
<div class="line"><span class="preprocessor">#define AMBOOT_BST_SIZE     (AMBOOT_BST_FIXED_SIZE)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_BLD_SIZE     (AMBOOT_MIN_PART_SIZE * 8)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_PTB_SIZE     (AMBOOT_MIN_PART_SIZE * 7)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_ATF_SIZE     (AMBOOT_MIN_PART_SIZE * 8)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_PBA_SIZE     (16 * 1024 * 1024)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_PRI_SIZE     (16 * 1024 * 1024)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_SEC_SIZE     (0  * 1024 * 1024)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_BAK_SIZE     (0  * 1024 * 1024)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_RMD_SIZE     (0  * 1024 * 1024)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_ROM_SIZE     (0  * 1024 * 1024)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_DSP_SIZE     (0  * 1024 * 1024)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_LNX_SIZE     (144 * 1024 * 1024)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_SWP_SIZE     (0  * 1024 * 1024)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_ADD_SIZE     (12  * 1024 * 1024)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_ADC_SIZE     (0  * 1024 * 1024)</span></div>
</div><!-- fragment --><p >The BST, BLD, partition table (PTB), Arm® trusted firmware (ATF), primary (PRI), and Linux (LNX) are used by default. Those partitions whose size is set to 0 are recognized as unused. All optional and reserved partitions can be utilized for user storage. For example, Android data (ADD) pre-boot authentication (PBA), SEC, backup (BAK), RAMDisk (RMD), or read-only memory (ROM) can be used as user partitions.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The legacy firmware layout only supports a fixed number of partitions.</li>
<li>Each partition's name is unchangeable.</li>
<li>One partition only supports one image.</li>
</ul>
</dd></dl>
<p>The following conventions are used in the partition names. </p><a class="anchor" id="firmware_partition_table"></a>
<table class="doxtable">
<caption>Table 1-1. List of Fixed Partition Names.</caption>
<tr>
<th align="center">Partition</th><th align="center">Choice</th><th align="center">Description </th></tr>
<tr>
<td>BST</td><td>Mandatory</td><td>AMBoot bootstrap code for hardware initialization </td></tr>
<tr>
<td>BLD</td><td>Mandatory</td><td>AMBoot bootloader </td></tr>
<tr>
<td>PTB</td><td>Mandatory</td><td>Device tree binary (DTB) and partition table, save the command line and boot flags. </td></tr>
<tr>
<td>ATF</td><td>Mandatory</td><td>Arm® trusted firmware (ATF), which can be used as bl2 to verify bl3x.bin in secure boot </td></tr>
<tr>
<td>PBA</td><td>Optional</td><td>Persistent basic input / output system (BIOS) application for safe recovery<br  />
 For AB upgrade, the system stores kernel B image; for PBA upgrade, it stores kernel+ramfs.<br  />
 If PRI or RMD / ROM is corrupted, AMBoot can boot from the PBA partition and execute the recovery processes. </td></tr>
<tr>
<td>PRI</td><td>Mandatory</td><td>Primary code image, which refers to the Linux kernel image<br  />
 For AB and PBA upgrades, the system stores the kernel A image. </td></tr>
<tr>
<td>SEC</td><td>Optional</td><td>Secondary code image, which can be used to store the private customer data </td></tr>
<tr>
<td>BAK</td><td>Optional</td><td>Backup code image, which can be uesed to backup images of all other specifized partitons </td></tr>
<tr>
<td>RMD</td><td>Optional</td><td>RAMDisk rootfs. If RAMDisk is selected, AMBoot loads the RAMDisk image at the boot stage. </td></tr>
<tr>
<td>ROM</td><td>Optional</td><td>For AB upgrades, ROM stores kernel B rootfs. It is not used for PBA upgrades </td></tr>
<tr>
<td>DSP</td><td>Reserved</td><td>Backup digital signal processor (DSP) microcode </td></tr>
<tr>
<td>LNX</td><td>Mandatory</td><td>Stores kernel A rootfs for AB and PBA upgrades </td></tr>
<tr>
<td>SWP</td><td>Reserved</td><td>(Reserved) </td></tr>
<tr>
<td>ADD</td><td>Reserved</td><td>Android data partition, or used for Oryx configuration </td></tr>
<tr>
<td>ADC</td><td>Reserved</td><td>Android cache partition, or used for Oryx upgrade firmware </td></tr>
<tr>
<td>RAW</td><td>Optional</td><td>Remaining space in current storage media<br  />
 If there is remaining space in the storage media, especially in the case of electronic multi-media cards (eMMCs), Ambarella suggests that users enable this partition in order to make use of all available space. </td></tr>
</table>
<hr  />
<h1><a class="anchor" id="si_boot"></a>
2. Boot</h1>
<p >This chapter explains the boot flow based on the CV2x SDK 3.0. The boot flow for the Cooper software development kit (SDK) is similar. This chapter contains the following sections:</p><ul>
<li>Section <a class="el" href="../../dc/d8f/si_boot_upgrade.html#si_normal_boot">2.1 Normal Boot</a></li>
<li>Section <a class="el" href="../../dc/d8f/si_boot_upgrade.html#si_secure_boot">2.2 Secure Boot</a></li>
</ul>
<h2><a class="anchor" id="si_normal_boot"></a>
2.1 Normal Boot</h2>
<h3><a class="anchor" id="si_normal_boot_flow"></a>
2.1.1 Normal Boot Flow</h3>
<div class="image">
<img src="../../normal_boot_flow.jpg" alt=""/>
<div class="caption">
Figure 2-1. Normal Boot Flow.</div></div>
<ul>
<li>BST: 4K bootstrap binary for CVxx written by assembly.<ul>
<li>BST starts from <code>ambarella\amboot\src\bst\&lt;chip_name&gt;\start.S</code>.</li>
</ul>
</li>
<li>BLD: The boot loader is the main part of AMBoot.<ul>
<li>It initializes hardware devices and maps memory space, then jumps to the kernel partition.</li>
<li>BLD starts from <code>ambarella\amboot\src\bld\main.c</code>.</li>
</ul>
</li>
<li>PTB: In the normal boot process, the boot flag and command line are from the PTB.</li>
</ul>
<h2><a class="anchor" id="si_secure_boot"></a>
2.2 Secure Boot</h2>
<h3><a class="anchor" id="si_secure_boot_flow"></a>
2.2.1 Secure Boot Flow</h3>
<div class="image">
<img src="../../secure_boot_flow.jpg" alt=""/>
<div class="caption">
Figure 2-2. Secure Boot Flow.</div></div>
<ul>
<li>BST: <code>bstemmc.S</code>, <code>bstemmc.S</code>, <code>bstspinor.S</code><ul>
<li>Load <code>bl2.bin</code> into dynamic random access memory (DRAM) and verify <code>bl2.bin</code>.</li>
<li>If the authentication is successful, jump to bl2 address x22 (bl2_main).</li>
<li>If the authentication fails, halt the CPU to die (loop at the current instruction address).</li>
</ul>
</li>
<li>BL2: <code>external\tee\arm-trusted-firmware\bl2</code><ul>
<li>Load <code>bl3x.bin</code> (BL31, BL32, BL33) into DRAM and verify <code>bl3x.bin</code>.</li>
<li>If the authentication is successful or if the verification step is skipped, jump to bl31 DRAM first address (next_load_info).</li>
<li>If the authentication fails, the <code>bl31.bin</code> will be erased from the memory and enter into the CPU loop.</li>
</ul>
</li>
<li>BL31: <code>tee\arm-trusted-firmware\bl31</code><ul>
<li>Initialize and start the open portable trusted execution environment (OP-TEE) operating system (OS) (BL32).</li>
<li>Obtain the address of the kernel image in read-only memory (ROM).</li>
<li>Jump to BL33 (BLD).</li>
</ul>
</li>
<li>BL32: optee_os<ul>
<li>Data encryption can be performed in the un-secure world (Linux) or in the secure world (OP-TEE).</li>
<li>The trusted application (TA) functions can be run in the secure world (OP-TEE).</li>
</ul>
</li>
<li>BL33: <code>bld.bin</code><ul>
<li>Load kernel image and verify <code>kernel_release.bin</code>.</li>
<li>If the authentication is successful, jump to the kernel (the jump partition depends on bootflags in bl33).</li>
<li>If the authentication fails, halt the CPU to die (loop at the current instruction address).</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="si_secure_boot_key_mgr"></a>
2.2.2 Key Management</h3>
<ol type="1">
<li>Local approach:</li>
</ol>
<div class="image">
<img src="../../secure_boot_local_key.jpg" alt=""/>
<div class="caption">
Figure 2-3. Local Key Approach.</div></div>
<p >The private keys are stored in the local area.</p><ul>
<li>Root of trust (RoT) public key: <code>ambarella\amboot\build\keys\rot_public.bin</code></li>
<li>RoT private key: <code>ambarella\amboot\build\keys\rot_private.pem</code></li>
<li>Kernel private key: <code>ambarella\amboot\build\keys\auth_kernel_private.txt</code></li>
<li>TA private key: <code>external\tee\optee_os\keys\default_ta.pem</code></li>
</ul>
<p >Remote procedure call (RPC) ToolKit approach:</p>
<div class="image">
<img src="../../secure_boot_rpc_key.jpg" alt=""/>
<div class="caption">
Figure 2-4. RPC Key Approach.</div></div>
<p >The private keys are stored in the remote server.</p><ul>
<li>Remote RoT public key: <code>ambarella\packages\security\build\tz_dev_server\rot_public.bin</code></li>
<li>RoT private key: <code>ambarella\packages\security\build\tz_dev_server\rot_private.pem</code></li>
<li>Kernel private key: <code>ambarella\packages\security\build\tz_dev_server\kernel_private.pem</code></li>
<li>TA private key: <code>ambarella\packages\security\build\tz_dev_server\default_ta.pem</code></li>
</ul>
<p >RPC usage:</p><ol type="1">
<li>Select in menuconfig and specify the different local port for the different account. <div class="fragment"><div class="line">build $ make menuconfig</div>
<div class="line">  Ambarella Package Configuration -&gt;</div>
<div class="line">    [*] Build Utilities -&gt;</div>
<div class="line">      [*] Build Ambarella Security Package -&gt;</div>
<div class="line">        [*] Build Security Package <span class="keywordflow">for</span> AMBOOT -&gt;</div>
<div class="line">          [*] Using RPC(Remote Procedure Call) Toolkit to sign binary -&gt;</div>
<div class="line">             (9088) Local port</div>
</div><!-- fragment --></li>
<li>Set up the development server and daemon before compilation. <div class="fragment"><div class="line">host $ cd ambarella/packages/security/build/tz_dev_server/</div>
<div class="line">host $ ./tz_dev_server ./db 9002</div>
<div class="line">host $ cd ambarella/packages/security/build/tz_dev_daemon/</div>
<div class="line">host $ ./tz_dev_daemon 10.4.8.67 9002 9088</div>
</div><!-- fragment --></li>
<li>For more details, refer to <code>ambarella\packages\security\build\trustzone_secure_boot_toolkit_help.txt</code>.</li>
</ol>
<h3><a class="anchor" id="si_secure_boot_en_otp"></a>
2.2.3 Enable OTP</h3>
<ol type="1">
<li>Enable one-time programmable (OTP) with a power-on configuration (POC) pin.<br  />
<ul>
<li>If POC[6] pulls up, secure boot can be enabled temporarily.</li>
<li>If POC[6] pulls low, secure boot will be disabled.</li>
</ul>
</li>
<li>Enable OTP permanently.<br  />
 If the eFUSE bit is used, the secure boot will be permanently enabled. If the secure boot is permanently enabled, POC[6] cannot enable / disable the secure boot. Because this process is irrevocable. The user uses it with cautions while performing this operation. Typically, this step is performed in manufacturing. <div class="fragment"><div class="line">board # modprobe optee</div>
<div class="line">board # tee-supplicant &amp;</div>
<div class="line">board # test_program_otp --enablesecurebootpermanently</div>
</div><!-- fragment --></li>
</ol>
<hr  />
<h1><a class="anchor" id="si_upgrade"></a>
3. Upgrade</h1>
<p >Since Cooper SDK supports two styles of firmware layouts, the upgrade will be described based on these styles.<br  />
 This chapter contains the following sections:</p><ul>
<li>Section <a class="el" href="../../dc/d8f/si_boot_upgrade.html#si_fw_and_image">3.1 Firmware and Image</a></li>
<li>Section <a class="el" href="../../dc/d8f/si_boot_upgrade.html#si_tftp_upgrade">3.2 TFTP Upgrade</a></li>
<li>Section <a class="el" href="../../dc/d8f/si_boot_upgrade.html#si_sd_upgrade">3.3 SD Upgrade</a></li>
<li>Section <a class="el" href="../../dc/d8f/si_boot_upgrade.html#si_image_upgrade">3.4 Image Upgrade</a></li>
</ul>
<h2><a class="anchor" id="si_fw_and_image"></a>
3.1 Firmware and Image</h2>
<p >After SDK compilation, various binaries are generated according to the different configurations. Ambarella uses the following conventions for different binaries according its usages:</p><ul>
<li><b>Binary</b>: It is generated directly by compilation and it is executable code, data, filesystem or others.</li>
<li><b>Image</b>: It may have a header and contains one or several binaries. It can be burned into storage media.</li>
<li><b>Firmware</b>: It consists of self-burning header and several images and binaries. It can be used by AmbaUSB programming, trivial file transfer protocol (TFTP) upgrade and secure card (SD) upgrade.<br  />
</li>
</ul>
<p >According to the Ambarella SDK version and its build methods, the user gets the firmwares, images and binaries from different paths: </p><dl class="section user"><dt>For Flexible Firmware Layout:</dt><dd><a class="anchor" id="si_flex_fw_table"></a>
<table class="doxtable">
<caption>Table 3-1. List of Firmwares, Images, and Binaries’ Path for Flexible.</caption>
<tr>
<th rowspan="2" align="center">Type </th><th colspan="2" align="center">Cooper SDK  </th></tr>
<tr>
<th align="center">Amba Build </th><th align="center">Yocto Build  </th></tr>
<tr>
<th align="center">Firmware Path </th><td><code>out/amba_out/&lt;board_name&gt;/firmware</code> </td><td><code>out/yocto_out/&lt;board_name&gt;/firmware</code>  </td></tr>
<tr>
<th align="center">Image Path </th><td><code>out/amba_out/&lt;board_name&gt;/objects/boot/ambfw</code> </td><td><code>out/yocto_out/&lt;board_name&gt;/tmp/work/cortexaXX-poky-linux/ambfw/1.0-r0/ambfw-1.0</code>  </td></tr>
<tr>
<th align="center">Binary Path </th><td><code>out/amba_out/&lt;board_name&gt;/images</code> </td><td><code>out/yocto_out/&lt;board_name&gt;/images</code>  </td></tr>
</table>
</dd></dl>
<a class="anchor" id="si_flex_fw_table"></a>
<table class="doxtable">
<caption>Table 3-2. List of Firmwares, Images, and Binaries. </caption>
<tr>
<th rowspan="3" align="center">Image Type </th><th colspan="6" align="center">Cooper SDK </th><th rowspan="3" align="center">Description  </th></tr>
<tr>
<th colspan="3" align="center">Amba Build </th><th colspan="3" align="center">Yocto Build  </th></tr>
<tr>
<th align="center">Firmware </th><th align="center">Image </th><th align="center">Binary </th><th align="center">Firmware </th><th align="center">Image </th><th align="center">Binary  </th></tr>
<tr>
<th align="center">BST </th><td><code>bst.elf</code></td><td><code>bst.img</code></td><td><code>bst.bin</code> </td><td><code>bst.elf</code></td><td><code>bst.img</code></td><td><code>bst.bin</code> </td><td>BST partition binary  </td></tr>
<tr>
<th align="center">BLD </th><td><code>bld.elf</code></td><td><code>bld.img</code></td><td><code>bld.bin</code> </td><td><code>bld.elf</code></td><td><code>bld.img</code></td><td><code>bld.bin</code> </td><td>BLD partition binary for normal boot  </td></tr>
<tr>
<th align="center">BL2 </th><td><code>bl2.elf</code></td><td><code>bl2.img</code></td><td><code>bl2.bin</code> </td><td><code>bl2.elf</code></td><td><code>bl2.img</code></td><td><code>bl2.bin</code> </td><td>BL2 partition binary for secure boot  </td></tr>
<tr>
<th align="center">FIP </th><td><code>fip.elf</code></td><td><code>fip.img</code></td><td><code>fip.bin</code> </td><td><code>fip.elf</code></td><td><code>fip.img</code></td><td><code>fip.bin</code> </td><td>FIP partition binary for secure boot  </td></tr>
<tr>
<th align="center">ENV </th><td><code>env.elf</code></td><td><code>env.img</code></td><td><code>env.bin</code> </td><td><code>env.elf</code></td><td><code>env.img</code></td><td><code>env.bin</code> </td><td>ENV partition binary  </td></tr>
<tr>
<th align="center">DTB </th><td><code>dtb.elf</code></td><td><code>dtb.img</code></td><td><code>dtb.bin</code> </td><td><code>dtb.elf</code></td><td><code>dtb.img</code></td><td><code>dtb.bin</code> </td><td>ENV partition binary  </td></tr>
<tr>
<th align="center">KERNEL </th><td><code>kernel.elf</code></td><td><code>kernel.img</code></td><td><code>kernel.bin</code> </td><td><code>kernel.elf</code></td><td><code>kernel.img</code></td><td><code>kernel.bin</code> </td><td>Kernel partition binary  </td></tr>
<tr>
<th align="center">PBA </th><td><code>pba.elf</code></td><td><code>pba.img</code></td><td><code>pba.bin</code> </td><td></td><td></td><td></td><td>PBA partition binary  </td></tr>
<tr>
<th align="center">ROOTFS </th><td><code>rootfs.elf</code></td><td><code>rootfs.img</code></td><td><code>rootfs.bin</code> </td><td><code>rootfs.elf</code></td><td><code>rootfs.img</code></td><td><code>rootfs.bin</code> </td><td>Rootfs partition binary  </td></tr>
<tr>
<th align="center">ALL </th><td><code>bst_bld_env_dtb_kernel_rootfs.elf</code> or <code>bst_bl2_fip_env_dtb_kernel_rootfs.elf (Secure Boot)</code></td><td></td><td></td><td><code>bst_bld_env_dtb_kernel_rootfs.elf</code> or <code>bst_bl2_fip_env_dtb_kernel_rootfs.elf (Secure Boot)</code></td><td></td><td></td><td>Firmware for all partitions (Normal Boot)  </td></tr>
<tr>
<th align="center">ALL </th><td><code>bst_bl2_fip_env_dtb_kernel_rootfs.elf</code></td><td></td><td></td><td><code>bst_bl2_fip_env_dtb_kernel_rootfs.elf</code></td><td></td><td></td><td>Firmware for all partitions (Secure Boot)  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The final generated firmware contains images and binaries used by the following partitions respectively:<ul>
<li>Images: ENV, DTB, KERNEL, PBA</li>
<li>Binaries: BST, BLD, ROOTFS, BL2, FIP</li>
</ul>
</li>
<li>These images and binaries are also used by the <a class="el" href="../../dc/d8f/si_boot_upgrade.html#si_image_upgrade">Image Upgrade</a></li>
</ul>
</dd></dl>
<dl class="section user"><dt>For Legacy Firmware Layout:</dt><dd><a class="anchor" id="si_legacy_fw_path_table"></a>
<table class="doxtable">
<caption>Table 3-3. List of Firmwares, Images, and Binaries’ Path.</caption>
<tr>
<th rowspan="2" align="center">Type </th><th colspan="2" align="center">Cooper SDK </th><th align="center">CV2x SDK 3.0  </th></tr>
<tr>
<th align="center">Amba Build </th><th align="center">Yocto Build </th><th align="center">Amba Build  </th></tr>
<tr>
<th align="center">Firmware Path </th><td><code>out/amba_out/&lt;board_name&gt;/firmware</code> </td><td><code>out/yocto_out/&lt;board_name&gt;/firmware</code> </td><td><code>out/&lt;board_name&gt;/images</code>  </td></tr>
<tr>
<th align="center">Image/Binary Path </th><td><code>out/amba_out/&lt;board_name&gt;/images</code> </td><td><code>out/yocto_out/&lt;board_name&gt;/images</code> </td><td>BST, BLD, ATF, DTB: <code>out/&lt;board_name&gt;/amboot</code><br  />
KERNEL, PBA: <code>out/&lt;board_name&gt;/kernel</code><br  />
ROOTFS: <code>out/&lt;board_name&gt;/rootfs</code>  </td></tr>
</table>
</dd></dl>
<a class="anchor" id="si_legacy_fw_table"></a>
<table class="doxtable">
<caption>Table 3-4. List of Firmwares, Images, and Binaries.</caption>
<tr>
<th rowspan="3" align="center">Image Type </th><th colspan="4" align="center">Cooper SDK </th><th colspan="2" align="center">CV2x SDK 3.0 </th><th rowspan="3" align="center">Description  </th></tr>
<tr>
<th colspan="2" align="center">Amba Build </th><th colspan="2" align="center">Yocto Build </th><th colspan="2" align="center">Amba Build  </th></tr>
<tr>
<th align="center">Firmware </th><th align="center">Image / Binary </th><th align="center">Firmware </th><th align="center">Image / Binary </th><th align="center">Firmware </th><th align="center">Image / Binary  </th></tr>
<tr>
<th align="center">BST </th><td><code>bst_release.elf</code></td><td><code>bst.bin</code> </td><td><code>bst_release.elf</code></td><td><code>bst.bin</code> </td><td><code>bst_release.elf</code></td><td><code>bst_release.bin</code> </td><td>BST partition image </td></tr>
<tr>
<th align="center">BLD </th><td><code>bld_release.elf</code></td><td><code>bld.bin</code> </td><td><code>bld_release.elf</code></td><td><code>bld.bin</code> </td><td><code>bld_release.elf</code></td><td><code>bld_release.bin</code> </td><td>BLD partition binary for normal boot  </td></tr>
<tr>
<th align="center">ATF </th><td><code>atf_release.elf</code></td><td><code>atf.bin</code> </td><td><code>atf_release.elf</code></td><td><code>atf.bin</code> </td><td><code>atf_release.elf</code></td><td><code>atf_release.bin</code> </td><td>ATF partition binary for secure boot  </td></tr>
<tr>
<th align="center">FIP </th><td><code>fip_release.elf</code></td><td><code>fip.bin</code> </td><td><code>fip_release.elf</code></td><td><code>fip.bin</code> </td><td><code>fip_release.elf</code></td><td><code>fip_release.bin</code> </td><td>BLD partition binary for secure boot  </td></tr>
<tr>
<th align="center">DTB </th><td></td><td><code>dtb.bin</code> </td><td></td><td><code>dtb.bin</code> </td><td></td><td><code>&lt;board_name&gt;.dtb</code> </td><td>DTS binary stored in PTB partition  </td></tr>
<tr>
<th align="center">KERNEL </th><td><code>kernel_release.elf</code></td><td><code>kernel.bin</code> or <code>Image.SIGNED (secure boot)</code> </td><td><code>kernel_release.elf</code></td><td><code>kernel.bin</code> or <code>Image.SIGNED (secure boot)</code> </td><td><code>kernel_release.elf</code></td><td><code>Image</code> or <code>Image.SIGNED (secure boot)</code> </td><td>PRI partition binary  </td></tr>
<tr>
<th align="center">PBA </th><td><code>pba_release.elf</code></td><td><code>pba.bin</code> or <code>Image.SIGNED (secure boot)</code> </td><td></td><td></td><td><code>pba_release.elf</code></td><td><code>pba_zImage</code> or <code>pba_zImage.SIGNED (secure boot)</code> </td><td>PBA partition binary  </td></tr>
<tr>
<th align="center">ROOTFS </th><td><code>lnx_release.elf</code></td><td><code>rootfs.bin</code> </td><td><code>lnx_release.elf</code></td><td><code>rootfs.bin</code> </td><td><code>lnx_release.elf</code></td><td><code>ubifs</code> (Take UBIFS as an example) </td><td>LNX partition binary  </td></tr>
<tr>
<th align="center">ALL </th><td><code>bst_bld_kernel_lnx_release.elf</code> or <code>bst_bld_atf_kernel_lnx_release.elf (Secure Boot)</code></td><td></td><td><code>bst_bld_kernel_lnx_release.elf</code> or <code>bst_bld_atf_kernel_lnx_release.elf (Secure Boot)</code></td><td></td><td><code>bst_bld_kernel_lnx_release.elf</code> or <code>bst_bld_atf_kernel_lnx_release.elf (Secure Boot)</code></td><td></td><td>Firmware for all partitions  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For legacy firmware layout, there is no difference between images and binaries. They are all raw binaries.</li>
<li>These images / binaries are also used by <a class="el" href="../../dc/d8f/si_boot_upgrade.html#si_image_upgrade">Image Upgrade</a>.</li>
</ul>
</dd></dl>
<h2><a class="anchor" id="si_tftp_upgrade"></a>
3.2 TFTP Upgrade</h2>
<p >The default configuration for the platform is to boot from flash with the file system on the EVK board's NAND flash.<br  />
 In some cases, only Ethernet access is available. This section describes upgrading the NAND flash file system by using the trivial file transfer protocol (TFTP) server.</p>
<h3><a class="anchor" id="si_tftp_upgrade_methods"></a>
3.2.1 TFTP Upgrade Methods</h3>
<p >There are two different methods to perform the upgrade: upgrade_partition and AMBoot shell.<br  />
 The <b>upgrade_partition</b> tool helps users manage the Ambarella boot configuration in rootfs and enables them to set up the Ambarella bootloader options easily without inputting much command lines to the <b>AMBoot</b> shell.</p>
<a class="anchor" id="tftp_commands_table"></a>
<table class="doxtable">
<caption>Table 3-5. List of TFTP Upgrade Commands.</caption>
<tr>
<th align="center">TFTP Upgrade for Flexible Firmware Layout<br  />
 in the Linux System </th><th align="center">TFTP Upgrade for Legacy Firmware Layout<br  />
 in the Linux System </th><th align="center">TFTP Upgrade<br  />
 in the AMBoot Shell </th><th align="center">Description  </th></tr>
<tr>
<td><code>upgrade_partition -e /dev/mtd3 --auto_boot 0</code> </td><td><code>upgrade_partition --auto_boot 0</code> </td><td><code>setenv auto_boot 0</code> </td><td>1 (Load Linux kernel from NAND flash) or 0  </td></tr>
<tr>
<td><code>upgrade_partition -e /dev/mtd3 -E -i 0 --mac 20:11:09:19:10:39</code> </td><td><code>upgrade_partition --ethmac 20:11:09:19:10:39</code> </td><td><code>setenv eth 0 mac 20:11:09:19:10:39</code> </td><td>Eth0 MAC address  </td></tr>
<tr>
<td><code>upgrade_partition -e /dev/mtd3 -E -i 0 --ip 10.0.0.2</code> </td><td><code>upgrade_partition --lan_ip 10.0.0.2</code> </td><td><code>setenv eth 0 ip 10.0.0.2</code> </td><td>Eth0 IP address  </td></tr>
<tr>
<td><code>upgrade_partition -e /dev/mtd3 -E -i 0 --mask 255.255.255.0</code> </td><td><code>upgrade_partition --lan_mask 255.255.255.0</code> </td><td><code>setenv eth 0 mask 255.255.255.0</code> </td><td>Eth0 netmask  </td></tr>
<tr>
<td><code>upgrade_partition -e /dev/mtd3 -E -i 0 --gw 10.0.0.1</code> </td><td><code>upgrade_partition --lan_gw 10.0.0.1</code> </td><td><code>setenv eth 0 gw 10.0.0.1</code> </td><td>Eth0 default gateway  </td></tr>
<tr>
<td><code>upgrade_partition -e /dev/mtd3 --tftpd_ip 10.0.0.1</code> </td><td><code>upgrade_partition --tftpd 10.0.0.1</code> </td><td><code>setenv tftpd 10.0.0.1</code> </td><td>TFTP server IP address  </td></tr>
<tr>
<td><code>reboot</code> </td><td><code>reboot</code> </td><td></td><td>Reboot to enter into Amboot.  </td></tr>
<tr>
<td><code>tftp program firmware.bin 0x4000000 1</code> </td><td><code>tftp program firmware.bin 0x4000000 1</code> </td><td><code>tftp program firmware.bin 0x4000000 1</code> </td><td>Use tftp to download the firmware and program it.  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Assume that the <code>/dev/mtd3</code> in the first column is the ENV partition.</dd></dl>
<h3><a class="anchor" id="si_tftp_upgrade_example"></a>
3.2.2 Example: TFTP Upgrade</h3>
<ol type="1">
<li>Prepare the TFTP upgrade.<ul>
<li>The user must confirm that the Ethernet cable is connected and the TFTP server is running on the host PC.</li>
<li>If the user uses the <code>upgrade_partition</code> tool, the following option must be selected. <dl class="section user"><dt>For CV2x SDK 3.0 Amba build:</dt><dd><div class="fragment"><div class="line">build $ make menuconfig</div>
<div class="line">  Ambarella Application Configuration -&gt;</div>
<div class="line">    Build Utilities -&gt;</div>
<div class="line">      [*] Build Ambarella upgrade partition</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>For Cooper Amba Build:</dt><dd><div class="fragment"><div class="line">build $ make menuconfig</div>
<div class="line">  app ---&gt;</div>
<div class="line">    utility ---&gt;</div>
<div class="line">      upgrade_partition ---&gt;</div>
<div class="line">        [*] upgrade-partition (app/utility/upgrade_partition/app)</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>For Cooper Yocto Build:</dt><dd><div class="fragment"><div class="line">build $ make menuconfig</div>
<div class="line">  meta-ambaapp ---&gt;</div>
<div class="line">    recipes-upgrade-partition ---&gt;</div>
<div class="line">      [*] upgrade-partition (meta-ambaapp/recipes-upgrade-partition/upgrade-partition)</div>
</div><!-- fragment --></dd></dl>
</li>
<li>The <code>AMBoot</code> must enable the Ethernet to download the firmware. The following option must be selected. <dl class="section user"><dt>For CV2x SDK 3.0 Amba build:</dt><dd><div class="fragment"><div class="line">build $ make menuconfig</div>
<div class="line">  Ambarella Bootloader Configuration  ---&gt;</div>
<div class="line">    Hardware Options  ---&gt;</div>
<div class="line">      [*] Support Micrel Ethernet Phy</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>For Cooper Amba Build:</dt><dd><div class="fragment"><div class="line">build $ make menuconfig</div>
<div class="line">  [*] boot (boot) ---&gt;</div>
<div class="line">    Bootloader ---&gt;</div>
<div class="line">      Ambarella Bootloader Configuration  ---&gt;</div>
<div class="line">        Hardware Options  ---&gt;</div>
<div class="line">          [*] Support Micrel Ethernet Phy</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>For Cooper Yocto Build:</dt><dd><div class="fragment"><div class="line">build $ make menuconfig</div>
<div class="line">  meta-ambabsp ---&gt;</div>
<div class="line">    recipes-bsp ---&gt;</div>
<div class="line">      [*] boot (meta-ambabsp/recipes-bsp/boot) ---&gt;</div>
<div class="line">        Bootloader ---&gt;</div>
<div class="line">          Ambarella Bootloader Configuration  ---&gt;</div>
<div class="line">            Hardware Options  ---&gt;</div>
<div class="line">              [*] Support Micrel Ethernet Phy</div>
</div><!-- fragment --></dd></dl>
</li>
<li>The generated firmware path can be found in the following path:<ul>
<li>For CV2x SDK 3.0: <code>ambarella/out/&lt;board_name&gt;/images/xxx_release.bin</code></li>
<li>For Cooper SDK Amba Build: <code>ambarella/out/amba_out/&lt;board_name&gt;/firmware/xxx_release.bin</code></li>
<li>For Cooper SDK Yocto Build: <code>ambarella/out/yocto_out/&lt;board_name&gt;/firmware/xxx_release.bin</code></li>
</ul>
</li>
<li>The user must place the firmware in the TFTP server's directory.</li>
<li>The user might need to rename the default firmware name. The firmware name size must not exceed the TFTP server's limitation (32 characters).</li>
</ul>
</li>
<li>Configure the TFTP parameters.<ul>
<li>For upgrade_partition:<ul>
<li>For flexible firmware layout: <div class="fragment"><div class="line">board # upgrade_partition -e /dev/mtd3 -E -i 0 --mac 20:11:09:19:10:39</div>
<div class="line">board # upgrade_partition -e /dev/mtd3 -E -i 0 --ip 10.0.0.2</div>
<div class="line">board # upgrade_partition -e /dev/mtd3 -E -i 0 --mask 255.255.255.0</div>
<div class="line">board # upgrade_partition -e /dev/mtd3 -E -i 0 --gw 10.0.0.1</div>
<div class="line">board # upgrade_partition -e /dev/mtd3 --auto_boot 0</div>
<div class="line">board # upgrade_partition -e /dev/mtd3 --tftpd_ip 10.0.0.1</div>
</div><!-- fragment --></li>
<li>For legacy firmware layout: <div class="fragment"><div class="line">board # upgrade_partition --ethmac 20:11:09:19:10:39</div>
<div class="line">board # upgrade_partition --lan_ip 10.0.0.2</div>
<div class="line">board # upgrade_partition --lan_mask 255.255.255.0</div>
<div class="line">board # upgrade_partition --lan_gw 10.0.0.1</div>
<div class="line">board # upgrade_partition --auto_boot 0</div>
<div class="line">board # upgrade_partition --tftpd 10.0.0.1</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>For AMBoot shell: <div class="fragment"><div class="line">amboot&gt; setenv auto_boot 0</div>
<div class="line">amboot&gt; setenv eth 0 mac 20:11:09:19:10:39</div>
<div class="line">amboot&gt; setenv eth 0 ip 10.0.0.2</div>
<div class="line">amboot&gt; setenv eth 0 mask 255.255.255.0</div>
<div class="line">amboot&gt; setenv eth 0 gw 10.0.0.1</div>
<div class="line">amboot&gt; setenv tftpd 10.0.0.1</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>Display the current settings.<ul>
<li>For AMBoot shell: <div class="fragment"><div class="line">amboot&gt; show netboot</div>
<div class="line">eth0_mac: 20:11:09:19:10:39</div>
<div class="line">eth0_ip: 10.0.0.2</div>
<div class="line">eth0_mask: 255.255.255.0</div>
<div class="line">eth0_gw: 10.0.0.1</div>
<div class="line">eth1_mac: 0.0.0.0</div>
<div class="line">eth1_ip: 0.0.0.0</div>
<div class="line">eth1_mask: 0.0.0.0</div>
<div class="line">eth1_gw: 0.0.0.0</div>
<div class="line">tftpd: 10.0.0.1</div>
<div class="line">pri_addr: 0x00000000</div>
<div class="line">pri_file:</div>
<div class="line">rmd_addr: 0x00000000</div>
<div class="line">rmd_file:</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>Enter AMBoot, download and program the firmware.<ul>
<li>Type the following command to start the upgrade: <div class="fragment"><div class="line">amboot&gt; tftp program firmware.bin 0x4000000 1</div>
</div><!-- fragment --></li>
<li>The downloading progress is shown below. <div class="image">
<img src="../../tftp_boot_enter_netboot_mode.png" alt=""/>
<div class="caption">
Figure 3-1. Enter Netboot Mode.</div></div>
</li>
<li>When the firmware download is complete, the message "Success" is displayed on the serial console. <dl class="section note"><dt>Note</dt><dd><ul>
<li>The EVK board boots if the firmware is configured to automatically boot after the download is complete.</li>
<li>If the firmware is not configured to automatically boot, press the <b>RESET</b> button on the EVK board to load the firmware.</li>
</ul>
</dd></dl>
</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="si_sd_upgrade"></a>
3.3 SD Upgrade</h2>
<p >This section describes the usage of the SD upgrade.</p>
<h3><a class="anchor" id="si_sd_upgrade_images"></a>
3.3.1 Images for SD Upgrade</h3>
<p >If the default build configuration (<code>make cvx_ipcam_config</code>) is used, only one BLD, BST, kernel, and rootfs will be generated. After the compilation is complete, there will be six files in <code>ambarella\out\cvx_board\images</code>.</p>
<a class="anchor" id="sd_upgrade_images"></a>
<table class="doxtable">
<caption>Table 3-6. Firmwares for SD Upgrade.</caption>
<tr>
<th align="center">Image Name </th><th align="center">Description  </th></tr>
<tr>
<td><code>bst_release.bin</code></td><td>BST partition binary </td></tr>
<tr>
<td><code>bld_release.bin</code></td><td>BLD partition binary </td></tr>
<tr>
<td><code>bst_bld_release.bin</code></td><td>BST and BLD partition binary </td></tr>
<tr>
<td><code>kernel_release.bin</code></td><td>PRI partition binary (kernel image) </td></tr>
<tr>
<td><code>lnx_release.bin</code></td><td>LNX partition binary (root file system) </td></tr>
<tr>
<td><code>bst_bld_kernel_lnx_release.bin</code></td><td>All the binary files including PTB partition binary </td></tr>
</table>
<h3><a class="anchor" id="si_sd_upgrade_example"></a>
3.3.2 Example: SD Upgrading the Partitions</h3>
<p >In the serial console window, press and hold the <b>ENTER</b> key on the keyboard, and then press the <b>RESET</b> button on the EVK board. The EVK board will switch to the AMBoot shell.</p>
<p >Then, users can type the following commands to upgrade different partitions. The binary name is shown in the <a class="el" href="../../dc/d8f/si_boot_upgrade.html#si_sd_upgrade_images">3.2.1 Images for SD Upgrade</a>. </p><div class="fragment"><div class="line">amboot&gt; sd init 0 hs</div>
<div class="line">amboot&gt; fs init</div>
<div class="line">amboot&gt; fs ls</div>
<div class="line">amboot&gt; fs read &lt;binary name&gt; &lt;MEMFWPROG_RAM_START&gt; 1</div>
</div><!-- fragment --><h2><a class="anchor" id="si_image_upgrade"></a>
3.4 Image Upgrade</h2>
<p >In some cases, the user might want to change some partition images stored in the development board rather than replacing the entire firmware. This section will introduce the upgrade methods and procedures to fullfill this goal.</p>
<h3><a class="anchor" id="si_image_upgrade_modes"></a>
3.4.1 Image Upgrade Modes</h3>
<p >In Ambarella SDK design, two image upgrade modes are recommended: <b>AB Upgrade</b> and <b>PBA Upgrade</b>.</p>
<dl class="section user"><dt>AB Upgrade:</dt><dd><ul>
<li>Advantages:<ul>
<li>During AB upgrade, the system functions can still run normally.</li>
<li>If the AB upgrade fails, the system which performing the upgrade operation can still run normally.</li>
<li>Rolling back to the previous system version at any time is possible.</li>
<li>If the current file system has been damaged, rolling back to another file system to restore it is possible.</li>
</ul>
</li>
<li>Disadvantages:<ul>
<li>Compared to PBA upgrade, an additional rootfs partition must be allocated to enable the AB upgrade function.</li>
<li>The system version control must be performed to prevent a system version rollback.</li>
</ul>
</li>
<li>AB upgrade flow for flexbile firmware layout: <div class="image">
<img src="../../ab_upgrade_flow_flexible.jpg" alt=""/>
<div class="caption">
Figure 3-2. AB Upgrade Flow for Flexbile Firmware Layout.</div></div>
</li>
<li>AB upgrade flow for legacy firmware layout: <div class="image">
<img src="../../ab_upgrade_flow_legacy.jpg" alt=""/>
<div class="caption">
Figure 3-3. AB Upgrade Flow for Legacy Firmware Layout.</div></div>
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>PBA Upgrade:</dt><dd><ul>
<li>Advantages:<ul>
<li>ROM only requires one additional partition for PBA (PBA is a small system used to perform online upgrades only); additional rootfs are not required.</li>
<li>The ROM size for PBA partition is just a little bigger than size of the kernel image.</li>
<li>Users are not required to pay extra attention to the system version.</li>
<li>If the PBA upgrade is interrupted unexpectedly, the user can still enter the PBA system to do the upgrade again.</li>
</ul>
</li>
<li>Disadvantages:<ul>
<li>If the PBA upgrade failed, the only way to restore the system is to upgrade again in PBA system.</li>
<li>The system cannot roll back to the previous system version.</li>
</ul>
</li>
<li>PBA upgrade flow for flexbile firmware layout: <div class="image">
<img src="../../pba_upgrade_flow_flexible.jpg" alt=""/>
<div class="caption">
Figure 3-4. PBA Upgrade Flow for Flexbile Firmware Layout.</div></div>
</li>
<li>PBA upgrade flow for legacy firmware layout: <div class="image">
<img src="../../pba_upgrade_flow_legacy.jpg" alt=""/>
<div class="caption">
Figure 3-5. PBA Upgrade Flow for Legacy Firmware Layout.</div></div>
</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>No matter what upgrade method is used, there is only one copy for BST, BLD and ATF / BL2 (secure boot) partition. They are shared by the kernel and the rootfs that have two copies.</li>
<li>If any of them except BST fails to boot after upgrade, the user can restore them through the <code>BAK</code> partition which can save backups for these partitions.</li>
<li>In rare cases, new upgrade kernel may be not compatible with the old BLD image in the board, the user must upgrade the BLD (BST and ATF / BL2 may be also needed) together with the kernel in such cases.</li>
<li>For BST, if it fails to boot, the only way to rescue it is to let the system enter force USB boot mode and download the firmware through the AmbaUSB tool. So users are suggested not to upgrade this partition unless necessary.</li>
<li>The <code>upgrade_partition</code> tool used for upgrading the images are not compatible for flexible and legacy firmware layout.</li>
<li>PBA upgrade is not supported by the Yocto Build.</li>
<li>For flexible firmware layout:<ul>
<li>No matter what upgrade method is used, there is only one copy for BST, BLD, BL2 (secure boot) and ENV partition. They are shared by the kernel and the rootfs that have two copies.</li>
<li>There are two DTB partitions that store different boot arguments for switching to the rootfs to be used.</li>
<li>ENV partition has two copies in one partition by default in case of the data corruption, the user must take care of this when modifying it in the apps.</li>
<li>ENV partition is used to switch the DTB, kernel and rootfs partitions to be used.</li>
</ul>
</li>
<li>For legacy firmware layout:<ul>
<li>No matter what upgrade method is used, there is only one copy for BST, BLD, ATF (secure boot) and PTB partition. They are shared by the kernel and the rootfs that have two copies.</li>
<li>The DTB is also stored in the PTB partition and PTB partition has two copies in one partition by default in case of the data corruption. The user must take care of this when modifying it in the apps.</li>
</ul>
</li>
</ol>
</dd></dl>
<h3><a class="anchor" id="si_images_for_upgrading"></a>
3.4.2 Images for Upgrading</h3>
<p >From the following tables, the user can get a quick overview on where to get the images used by the upgrade. </p><dl class="section user"><dt>For Flexible Firmware Layout:</dt><dd><a class="anchor" id="si_flex_fw_table"></a>
<table class="doxtable">
<caption>Table 3-7. Images for Image Upgrade. </caption>
<tr>
<th rowspan="2" align="center">Image Type </th><th colspan="2" align="center">Cooper SDK </th><th rowspan="2" align="center">Description  </th></tr>
<tr>
<th align="center">Amba Build </th><th align="center">Yocto Build  </th></tr>
<tr>
<th align="center">BST </th><td><code>out/amba_out/&lt;board_name&gt;/images/bst.bin</code> </td><td><code>out/yocto_out/&lt;board_name&gt;/images/bst.bin</code> </td><td>BST partition binary  </td></tr>
<tr>
<th align="center">BLD </th><td><code>out/amba_out/&lt;board_name&gt;/images/bld.bin</code> </td><td><code>out/yocto_out/&lt;board_name&gt;/images/bld.bin</code> </td><td>BLD partition binary for normal boot  </td></tr>
<tr>
<th align="center">BL2 </th><td><code>out/amba_out/&lt;board_name&gt;/images/bl2.bin</code> </td><td><code>out/yocto_out/&lt;board_name&gt;/images/bl2.bin</code> </td><td>BL2 partition binary for secure boot  </td></tr>
<tr>
<th align="center">FIP </th><td><code>out/amba_out/&lt;board_name&gt;/images/fip.bin</code> </td><td><code>out/yocto_out/&lt;board_name&gt;/images/fip.bin</code> </td><td>FIP partition binary for secure boot  </td></tr>
<tr>
<th align="center">ENV </th><td><code>out/amba_out/&lt;board_name&gt;/objects/boot/ambfw/env.img</code> </td><td><code>out/yocto_out/&lt;board_name&gt;/tmp/work/cortexaXX-poky-linux/ambfw/1.0-r0/ambfw-1.0/env.img</code> </td><td>ENV partition binary  </td></tr>
<tr>
<th align="center">DTB </th><td><code>out/amba_out/&lt;board_name&gt;/objects/boot/ambfw/dtb.img</code> </td><td><code>out/yocto_out/&lt;board_name&gt;/tmp/work/cortexaXX-poky-linux/ambfw/1.0-r0/ambfw-1.0/dtb.img</code> </td><td>ENV partition binary  </td></tr>
<tr>
<th align="center">KERNEL </th><td><code>out/amba_out/&lt;board_name&gt;/objects/boot/ambfw/kernel.img</code> </td><td><code>out/yocto_out/&lt;board_name&gt;/tmp/work/cortexaXX-poky-linux/ambfw/1.0-r0/ambfw-1.0/kernel.img</code> </td><td>Kernel partition binary  </td></tr>
<tr>
<th align="center">PBA </th><td><code>out/amba_out/&lt;board_name&gt;/objects/boot/ambfw/pba.img</code> </td><td></td><td>PBA partition binary  </td></tr>
<tr>
<th align="center">ROOTFS </th><td><code>out/amba_out/&lt;board_name&gt;/images/rootfs.bin</code> </td><td><code>out/yocto_out/&lt;board_name&gt;/images/rootfs.bin</code> </td><td>Rootfs partition binary  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>For Legacy Firmware Layout:</dt><dd><a class="anchor" id="si_legacy_fw_table"></a>
<table class="doxtable">
<caption>Table 3-8. Images for Image Upgrade.</caption>
<tr>
<th rowspan="2" align="center">Image Type </th><th colspan="2" align="center">Cooper SDK </th><th colspan="1" align="center">CV2x SDK 3.0 </th><th rowspan="2" align="center">Description  </th></tr>
<tr>
<th align="center">Amba Build </th><th align="center">Yocto Build </th><th align="center">Amba Build  </th></tr>
<tr>
<th align="center">BST </th><td><code>out/amba_out/&lt;board_name&gt;/images/bst.bin</code> </td><td><code>out/yocto_out/&lt;board_name&gt;/images/bst.bin</code> </td><td><code>out/&lt;board_name&gt;/amboot/bst_release.bin</code> </td><td>BST partition image </td></tr>
<tr>
<th align="center">BLD </th><td><code>out/amba_out/&lt;board_name&gt;/images/bld.bin</code> </td><td><code>out/yocto_out/&lt;board_name&gt;/images/bld.bin</code> </td><td><code>out/&lt;board_name&gt;/amboot/bld_release.bin</code> </td><td>BLD partition binary for normal boot  </td></tr>
<tr>
<th align="center">ATF </th><td><code>out/amba_out/&lt;board_name&gt;/images/atf.bin</code> </td><td><code>out/yocto_out/&lt;board_name&gt;/images/atf.bin</code> </td><td><code>out/&lt;board_name&gt;/amboot/atf_release.bin</code> </td><td>ATF partition binary for secure boot  </td></tr>
<tr>
<th align="center">FIP </th><td><code>out/amba_out/&lt;board_name&gt;/images/fip.bin</code> </td><td><code>out/yocto_out/&lt;board_name&gt;/images/fip.bin</code> </td><td><code>out/&lt;board_name&gt;/amboot/fip_release.bin</code> </td><td>BLD partition binary for secure boot  </td></tr>
<tr>
<th align="center">DTB </th><td><code>out/amba_out/&lt;board_name&gt;/images/dtb.bin</code> </td><td><code>out/yocto_out/&lt;board_name&gt;/images/dtb.bin</code> </td><td><code>out/&lt;board_name&gt;/amboot/&lt;board_name&gt;.dtb</code> </td><td>DTS binary stored in PTB partition  </td></tr>
<tr>
<th align="center">KERNEL </th><td><code>out/amba_out/&lt;board_name&gt;/images/kernel.bin</code> or <code>Image.SIGNED (secure boot)</code> </td><td><code>out/yocto_out/&lt;board_name&gt;/images/kernel.bin</code> or <code>Image.SIGNED (secure boot)</code> </td><td><code>out/&lt;board_name&gt;/kernel/Image</code> or <code>Image.SIGNED (secure boot)</code> </td><td>PRI partition binary  </td></tr>
<tr>
<th align="center">PBA </th><td><code>out/amba_out/&lt;board_name&gt;/images/pba.bin</code> or <code>Image.SIGNED (secure boot)</code> </td><td></td><td><code>out/&lt;board_name&gt;/kernel/pba_zImage</code> or <code>pba_zImage.SIGNED (secure boot)</code> </td><td>PBA partition binary  </td></tr>
<tr>
<th align="center">ROOTFS </th><td><code>out/amba_out/&lt;board_name&gt;/images/rootfs.bin</code> </td><td><code>out/yocto_out/&lt;board_name&gt;/images/rootfs.bin</code> </td><td><code>out/&lt;board_name&gt;/rootfs/ubifs</code> (Take UBIFS as an example) </td><td>LNX partition binary  </td></tr>
</table>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For secure boot, the DTB binary together with <code>bld.bin</code> is packed into the <code>fip.bin</code>, the DTB binary stored in DTB or PTB partition takes no effect unless <code>CONFIG_RELOAD_UNTRUSTED_DTB</code> is selected in menuconfig.</dd></dl>
<h3><a class="anchor" id="si_image_upgrade_tool"></a>
3.4.3 The Upgrade Tool</h3>
<p >To perform the upgrade operation, the Ambarella SDK provides a tool named <code>upgrade_partition</code> for the user. The user can use this tool in both upgrade modes. <br  />
 The user can select this tool in menuconfig:</p><ul>
<li>For CV2x SDK 3.0 Amba build: <div class="fragment"><div class="line">build $ make menuconfig</div>
<div class="line">  Ambarella Application Configuration -&gt;</div>
<div class="line">    Build Utilities -&gt;</div>
<div class="line">      [*] Build Ambarella upgrade partition</div>
</div><!-- fragment --></li>
<li>For Cooper Amba build: <div class="fragment"><div class="line">build $ make menuconfig</div>
<div class="line">  app ---&gt;</div>
<div class="line">    utility ---&gt;</div>
<div class="line">      upgrade_partition ---&gt;</div>
<div class="line">        [*] upgrade-partition (app/utility/upgrade_partition/app)</div>
</div><!-- fragment --></li>
<li>For Cooper Yocto build: <div class="fragment"><div class="line">build $ make menuconfig</div>
<div class="line">  meta-ambaapp ---&gt;</div>
<div class="line">    recipes-upgrade-partition ---&gt;</div>
<div class="line">      [*] upgrade-partition (meta-ambaapp/recipes-upgrade-partition/upgrade-partition)</div>
</div><!-- fragment --> The user can type the <code>upgrade_partition</code> in console to get the usages or refer to the upgrade examples <a class="el" href="../../dc/d8f/si_boot_upgrade.html#si_ab_flex_upgrade">3.4.5 AB Upgrade Example for Flexible Firmware Layout</a> and <a class="el" href="../../dc/d8f/si_boot_upgrade.html#si_ab_legacy_upgrade">3.4.7 AB Upgrade Example for Legacy Firmware Layout</a> <div class="fragment"><div class="line">board# upgrade_partition</div>
<div class="line">Usage:upgrade_partition [OPTION] MTD_DEVICE INPUTFILE</div>
<div class="line">Writes to the specified MTD device.</div>
<div class="line">......</div>
</div><!-- fragment --></li>
</ul>
<p ><b>Here are some examples for upgrade_partition.</b><br  />
</p><ul>
<li>For flexible firmware layout:<ul>
<li>Upgrade boot arguments. <div class="fragment"><div class="line"><span class="comment">// Assume NAND is used. &quot;mtd3&quot; is the ENV partition.</span></div>
<div class="line">board# upgrade_partition -e /dev/mtd3 -C <span class="stringliteral">&quot;console=ttyS0 ubi.mtd=rootfs root=ubi0:rootfs rw rootfstype=ubifs earlycon pci=nomsi&quot;</span></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd><ul>
<li>For flexible firmware layout, the user must update the <code>bootargs</code> with cautions:<ul>
<li>The <code>upgrade_partition</code> tool can change the "bootargs" stored in ENV partition, it can't change the "bootargs" stored in DTB partition.</li>
<li>If the "bootargs" in ENV partition is not NULL, this "bootargs" will replace the one in memory loaded from DTB during the amboot stage.</li>
<li>If the "bootargs" in ENV partition is NULL, AMboot will use the "bootargs" stored in DTB partition.</li>
</ul>
</li>
<li>If the user really wants to change the "bootargs" stored in DTB partition, the only way is to change it in amboot. <div class="fragment"><div class="line">amboot# fdt cmdline console=ttyS0 ubi.mtd=rootfs root=ubi0:rootfs rw rootfstype=ubifs earlycon pci=nomsi</div>
</div><!-- fragment --></li>
<li>The user can also change the "bootargs" stored in ENV partition through the AMBoot shell. <div class="fragment"><div class="line">amboot# setenv cmdline console=ttyS0 ubi.mtd=rootfs root=ubi0:rootfs rw rootfstype=ubifs earlycon pci=nomsi</div>
</div><!-- fragment --></li>
<li>If the "bootargs" stored in DTB partition is back to use, the user must clear the "bootargs" stored in ENV partition. <div class="fragment"><div class="line">board# upgrade_partition -e /dev/mtd3 -C <span class="stringliteral">&quot;&quot;</span></div>
<div class="line"><span class="comment">// or in AMBoot shell</span></div>
<div class="line">amboot# setenv cmdline</div>
</div><!-- fragment --></li>
</ul>
</dd></dl>
</li>
<li>Upgrade <code>dtb2</code> partition and switch to it. <div class="fragment"><div class="line"><span class="comment">// Assume NAND is used. &quot;mtd3&quot; and &quot;mtd5&quot; are ENV and dtb2 partition.</span></div>
<div class="line">board# flash_erase /dev/mtd5 0 0</div>
<div class="line">board# upgrade_partition -p /dev/mtd5 /sdcard/upgrade/dtb.img</div>
<div class="line">board# upgrade_partition -e /dev/mtd3 -n -P dtb2</div>
</div><!-- fragment --></li>
<li>Upgrade <code>kernel2</code> partition and switch to it. <div class="fragment"><div class="line"><span class="comment">// Assume EMMC is used. &quot;mmcblk0p4&quot; and &quot;mmcblk0p5&quot; are ENV and kernel2 partition.</span></div>
<div class="line">board# upgrade_partition -p /dev/mmcblk0p5 /sdcard/upgrade/kernel.img</div>
<div class="line">board# upgrade_partition -e /dev/mmcblk0p4 -k -P kernel2</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>For legacy firmware layout:<ul>
<li>Upgrade DTB and update boot arguments in DTB. <div class="fragment"><div class="line"><span class="comment">// Assume NAND is used.</span></div>
<div class="line">board# upgrade_partition -d /sdcard/upgrade/&lt;board_name&gt;.dtb</div>
<div class="line">board# upgrade_partition -C <span class="stringliteral">&quot;console=ttyS0 ubi.mtd=rootfs root=ubi0:rootfs rw rootfstype=ubifs earlycon pci=nomsi&quot;</span></div>
</div><!-- fragment --></li>
<li>Upgrade <code>pba</code> partition (kernel) and switch to it. <div class="fragment"><div class="line"><span class="comment">// Assume NAND is used. &quot;mtd4&quot; is the pba partition.</span></div>
<div class="line">board# flash_erase /dev/mtd4 0 0</div>
<div class="line">board# upgrade_partition -p -Q /dev/mtd4 /sdcard/upgrade/Image</div>
<div class="line">board# upgrade_partition -S 2</div>
</div><!-- fragment --></li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>It is better to switch to a second rootfs / system to update the first rootfs / system, or it may cause a system crash.</dd></dl>
<h3><a class="anchor" id="si_image_upgrade_signature"></a>
3.4.4 Digital Signature (Optional)</h3>
<p >For the sake of safety, the digital signature check can be added into the image updating flow to ensure that only the correct and untampered firmware can be flashed to the board. The Ambrella SDK provides a digital signature tool and related APIs to do this. The security package is located at:<br  />
 For CV2x SDK 3.0: <code>ambarella/packages/security</code><br  />
 For Cooper SDK: <code>ambarella/security</code></p>
<ul>
<li><dl class="section user"><dt>Digital Signature Tool</dt><dd>This tool can generate key pairs, sign the firmwares, and verify signatures in the host Linux PC. The user can build this using the following command: <div class="fragment"><div class="line">build$ cd security/</div>
<div class="line">build$ make</div>
<div class="line">build$ cd key_tools/pkey_tool_native/</div>
<div class="line">build$ make</div>
</div><!-- fragment --> The tool <code>key_tool_ed25519</code> will be generated under <code>key_tools/pkey_tool_native/</code>. <div class="fragment"><div class="line"><span class="comment">// Generate the private and public keys, e.g. pri_ed25519.bin and pub_ed25519.bin</span></div>
<div class="line">build$ ./key_tool_ed25519 --genkey ed25519</div>
<div class="line"><span class="comment">// Generate the signature using the private key</span></div>
<div class="line">build$ ./key_tool_ed25519 --sign xxx_image.bin pri_ed25519.bin xxx_image.bin.signature</div>
<div class="line"><span class="comment">// Verify the signature using the public key</span></div>
<div class="line">build$ ./key_tool_ed25519 --verify xxx_image.bin pub_ed25519.bin xxx_image.bin.signature</div>
<div class="line">verify pass</div>
</div><!-- fragment --> The user can write the public key into the security OTP for succeeding signature verifications during firmware upgrading stage. The user must keep the generated private key in safe in order to sign the firmwares to be used in the subsequent upgrade operation. The used private and public keys must be a pair, which are generated together.</dd></dl>
</li>
<li><dl class="section user"><dt>Key Verification</dt><dd>The key verification APIs reside at <code>security/lw_cryptography/include/curve25519.h</code>. The user can read the public key from the OTP and call these APIs to verify the firmware signature in the upgrade application. The user can refer to the examples under <code>security/lw_cryptography/unit_test</code> on how to use these APIs.</dd></dl>
</li>
<li><dl class="section user"><dt>The Digital Signature Check Flow:</dt><dd><div class="image">
<img src="../../image_upgrading_digital_signature_check.png" alt=""/>
<div class="caption">
Figure 3-4. Digital Signature Check for Image Updating.</div></div>
</dd></dl>
</li>
</ul>
<h3><a class="anchor" id="si_ab_flex_upgrade"></a>
3.4.5 AB Upgrade Example for Flexible Firmware Layout</h3>
<p >For flexible firmware layout, two DTB partitions are used to do the switch between the system A and the system B.<br  />
 Take CV72_gage as an example, perform the following steps to setup AB upgrade for flexible firmware layout:</p><ol type="1">
<li>Allocate the "dtb2", "kernel2" and "rootfs2" partition size. <div class="fragment"><div class="line">vim ambarella/boards/cv72_gage/bsp/bsp.h</div>
<div class="line"><span class="preprocessor">#define AMBOOT_PARTITION_LAYOUT \</span></div>
<div class="line"><span class="preprocessor">              MEDIA_DEV \</span></div>
<div class="line"><span class="preprocessor">              &quot;128k(bst),1024k(bld),1024k(dtb),896k(dtb2),896k(env),128k(cfg),&quot;</span> \</div>
<div class="line">              &quot;16m@0x600000(kernel),16m(kernel2),108m(rootfs),108m(rootfs2),-(raw)&quot;</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd><ul>
<li>The generated root file system (rootfs) size may be larger than the partition size, the user can remove some unwanted configurations in menuconfig.</li>
<li>Ensure that the total size (6M(kernel offset) + 16M * 2 + 108M * 2 = 254M) is smaller than the NAND flash total size.</li>
<li>The space (6M) before the kernel is big enough for the bst, bld, dtb, dtb2, env and cfg in this example.</li>
<li>The partition allocation above is not suitable for embedded multi-media controller (eMMC). When eMMC is used, the user must allocate the partition according to the actual need, especially for the rootfs size.</li>
</ul>
</dd></dl>
</li>
<li>Create a <code>.dts</code> file and change the <code>bootargs</code> for the system B. <div class="fragment"><div class="line">build$ cp -rf ambarella/boards/cv72_gage/bsp/cv72_gage.dts ambarella/boards/cv72_gage/bsp/cv72_gage_ab_upgrade.dts</div>
<div class="line"><span class="comment">// change the command line for system B</span></div>
<div class="line">build$ vim ambarella/boards/cv72_gage/bsp/cv72_gage_ab_upgrade.dts</div>
<div class="line">bootargs = <span class="stringliteral">&quot;console=ttyS0 ubi.mtd=rootfs2 root=ubi0:rootfs rw rootfstype=ubifs earlycon pci=nomsi&quot;</span>;</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>When eMMC is used, the bootargs for system A and system B appear as follows if the partition layout in step 1 is used. For "root=/dev/mmcblk0pX", the <code>X</code> is the sequence number of the partitions counting from 1(bst). <div class="fragment"><div class="line"><span class="comment">// For system A</span></div>
<div class="line">bootargs = <span class="stringliteral">&quot;console=ttyS0 noinitrd root=/dev/mmcblk0p9 rw rootfstype=ext4 rootwait pci=nomsi pcie_aspm=off&quot;</span>;</div>
<div class="line"><span class="comment">// For system B</span></div>
<div class="line">bootargs = <span class="stringliteral">&quot;console=ttyS0 noinitrd root=/dev/mmcblk0p10 rw rootfstype=ext4 rootwait pci=nomsi pcie_aspm=off&quot;</span>;</div>
</div><!-- fragment --></dd></dl>
</li>
<li>Create a Makefile to build the <code>dtb2.bin</code> using the DTS file in step 2. <div class="fragment"><div class="line">build$ vim ambarella/boards/cv72_gage/bsp/upgrade_dtb2.mk</div>
<div class="line">CC  := $(ENV_BUILD_TOOL)gcc</div>
<div class="line">DTC := dtc</div>
<div class="line"> </div>
<div class="line">DTC_OPTIONS := -I dts -H epapr -q</div>
<div class="line">DTC_OPTIONS += -i $(KERNEL_SRC)/arch/arm64/boot/dts/ambarella</div>
<div class="line"> </div>
<div class="line">DTC_CFLAGS  := -E -nostdinc -D__DTS__ -U linux -<a class="code hl_variableRef" target="_blank" href="../../../driver/df/dc0/group__IAV.html#gaf80df1bdae91e5f76236e6ed1110825d">x</a> assembler-with-cpp</div>
<div class="line">DTC_CFLAGS  += -I . -I $(KERNEL_SRC)/include -I$(ENV_CFG_ROOT)</div>
<div class="line">DTC_CFLAGS  += -I$(KERNEL_SRC)/arch/arm64/boot/dts/ambarella</div>
<div class="line"> </div>
<div class="line">ifeq ($(CONFIG_BACKUP_CPIO), <a class="code hl_variableRef" target="_blank" href="../../../driver/df/dc0/group__IAV.html#ga11e444dd61d48abbdd34eed23186cb4b">y</a>)</div>
<div class="line">DTS_FILE := $(BSP_DIR)/cv72_gage_pba_upgrade.dts</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">DTS_FILE := $(BSP_DIR)/cv72_gage_ab_upgrade.dts</div>
<div class="line">endif</div>
<div class="line"> </div>
<div class="line">dtb2.bin: $(DTS_FILE)</div>
<div class="line">   @$(CC) $(DTC_CFLAGS) $&lt; | $(DTC) $(DTC_OPTIONS) -S 0x10000 -O dtb -o $@</div>
<div class="line"> </div>
<div class="line">.FORCE:</div>
<div class="ttc" id="agroup__IAV_html_ga11e444dd61d48abbdd34eed23186cb4b"><div class="ttname"><a href="../../../driver/df/dc0/group__IAV.html#ga11e444dd61d48abbdd34eed23186cb4b">y</a></div><div class="ttdeci">u32 y</div></div>
<div class="ttc" id="agroup__IAV_html_gaf80df1bdae91e5f76236e6ed1110825d"><div class="ttname"><a href="../../../driver/df/dc0/group__IAV.html#gaf80df1bdae91e5f76236e6ed1110825d">x</a></div><div class="ttdeci">u32 x</div></div>
</div><!-- fragment --></li>
<li>Create a profile for the firmware to be generated. <div class="fragment"><div class="line">build$ vim bsp/profile.ab_upgrade</div>
<div class="line">IMAGE_FWPROG    := $(BIN_DIR)/fwp.bin</div>
<div class="line"> </div>
<div class="line">IMAGE_0_NAME    := bst</div>
<div class="line">IMAGE_0_FILE    := $(BIN_DIR)/bst.bin</div>
<div class="line">IMAGE_0_ADDR    := -1</div>
<div class="line">IMAGE_0_FLAG    := force <a class="code hl_variableRef" target="_blank" href="../../../library/d1/d82/cJSON_8h.html#a788db922597cf2fb6389e278f822e59f">raw</a></div>
<div class="line"> </div>
<div class="line">IMAGE_1_NAME    := bld</div>
<div class="line">IMAGE_1_FILE    := $(BIN_DIR)/bld.bin</div>
<div class="line">IMAGE_1_ADDR    := -1</div>
<div class="line">IMAGE_1_FLAG    := force <a class="code hl_variableRef" target="_blank" href="../../../library/d1/d82/cJSON_8h.html#a788db922597cf2fb6389e278f822e59f">raw</a></div>
<div class="line"> </div>
<div class="line">IMAGE_2_NAME    := env</div>
<div class="line">IMAGE_2_FILE    := $(BIN_DIR)/env.bin</div>
<div class="line">IMAGE_2_ADDR    := -1</div>
<div class="line">IMAGE_2_FLAG    := force</div>
<div class="line"> </div>
<div class="line">IMAGE_3_NAME    := dtb</div>
<div class="line">IMAGE_3_FILE    := $(BIN_DIR)/dtb.bin</div>
<div class="line">IMAGE_3_ADDR    := -1</div>
<div class="line">IMAGE_3_FLAG    := force</div>
<div class="line"> </div>
<div class="line">IMAGE_4_NAME    := dtb2</div>
<div class="line">IMAGE_4_FILE    := dtb2.bin</div>
<div class="line">IMAGE_4_ADDR    := -1</div>
<div class="line">IMAGE_4_FLAG    := force</div>
<div class="line"> </div>
<div class="line">IMAGE_5_NAME    := kernel</div>
<div class="line">IMAGE_5_FILE    := $(BIN_DIR)/kernel.bin</div>
<div class="line">IMAGE_5_ADDR    := $(KERNEL_RAM_START)</div>
<div class="line">IMAGE_5_FLAG    := verify compressed</div>
<div class="line"> </div>
<div class="line">IMAGE_6_NAME    := kernel2</div>
<div class="line">IMAGE_6_FILE    := $(BIN_DIR)/kernel.bin</div>
<div class="line">IMAGE_6_ADDR    := $(KERNEL_RAM_START)</div>
<div class="line">IMAGE_6_FLAG    := verify compressed</div>
<div class="line"> </div>
<div class="line">IMAGE_7_NAME    := rootfs</div>
<div class="line">IMAGE_7_FILE    := $(BIN_DIR)/rootfs.bin</div>
<div class="line">IMAGE_7_ADDR    := -1</div>
<div class="line">IMAGE_7_FLAG    := <a class="code hl_variableRef" target="_blank" href="../../../library/d1/d82/cJSON_8h.html#a788db922597cf2fb6389e278f822e59f">raw</a></div>
<div class="line"> </div>
<div class="line">IMAGE_8_NAME    := rootfs2</div>
<div class="line">IMAGE_8_FILE    := $(BIN_DIR)/rootfs.bin</div>
<div class="line">IMAGE_8_ADDR    := -1</div>
<div class="line">IMAGE_8_FLAG    := <a class="code hl_variableRef" target="_blank" href="../../../library/d1/d82/cJSON_8h.html#a788db922597cf2fb6389e278f822e59f">raw</a></div>
<div class="line"> </div>
<div class="line">include $(BSP_DIR)/upgrade_dtb2.mk</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>It is better to keep the flags the same for doubled partitions in the profile above.</dd></dl>
</li>
<li>Create a new <code>.env</code> file for partition if needed, or use the default one located at <code>boot/amboot/src/bld/default.env</code>.<br  />
 This file can determine which dtb, kernel, and rootfs partions are used for booting up the EVK board. <div class="fragment"><div class="line">build$ vim ambarella/boards/cv72_gage/bsp/cv72_gage.env</div>
<div class="line">/dts-v1/;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;config.h&quot;</span></div>
<div class="line"> </div>
<div class="line">/ {</div>
<div class="line">    compatible = <span class="stringliteral">&quot;ambarella,environment&quot;</span>;</div>
<div class="line"><span class="preprocessor">    #address-cells = &lt;1&gt;;</span></div>
<div class="line"><span class="preprocessor">    #size-cells = &lt;1&gt;;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#if defined(AMBOOT_DEV_AUTO_BOOT)</span></div>
<div class="line">    auto_boot;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    serial_num = AMBOOT_DEFAULT_SN;</div>
<div class="line"> </div>
<div class="line">    bootcmd = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    bootargs = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    kernel_meta {</div>
<div class="line">        partition = <span class="stringliteral">&quot;kernel&quot;</span>;</div>
<div class="line">        binary_id = &lt;0&gt;;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    dtb_meta {</div>
<div class="line">        partition = <span class="stringliteral">&quot;dtb&quot;</span>;</div>
<div class="line">        binary_id = &lt;0&gt;;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    rootfs_meta {</div>
<div class="line">        partition = <span class="stringliteral">&quot;rootfs&quot;</span>;</div>
<div class="line">        binary_id = &lt;0&gt;;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    netdev_eth0 {</div>
<div class="line">        mac = <span class="stringliteral">&quot;00:00:00:00:00:00&quot;</span>;</div>
<div class="line">        mask = <span class="stringliteral">&quot;0.0.0.0&quot;</span>;</div>
<div class="line">        gw = <span class="stringliteral">&quot;0.0.0.0&quot;</span>;</div>
<div class="line">        ip = <span class="stringliteral">&quot;0.0.0.0&quot;</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    tftpd {</div>
<div class="line">        server,ip = <span class="stringliteral">&quot;0.0.0.0&quot;</span>;</div>
<div class="line">        kernel,file = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">        kernel,addr = &lt;0x00000000&gt;;</div>
<div class="line">        ramdisk,file = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">        ramdisk,addr = &lt;0x00000000&gt;;</div>
<div class="line">    };</div>
<div class="line">};</div>
</div><!-- fragment --></li>
<li>Configure the AB system in menuconfig. <dl class="section user"><dt>For Cooper Amba Build:</dt><dd><div class="fragment"><div class="line">build$ make ipcam_lp5_config</div>
<div class="line">build$ make menuconfig</div>
<div class="line">boot  ---&gt;</div>
<div class="line">  [*] ambfw (boot/ambamk)  ---&gt;</div>
<div class="line">    AMBFW Configuration  ---&gt;</div>
<div class="line">      [*] Build AMBFW</div>
<div class="line">      (profile.ab_upgrade) Firmware Profile</div>
<div class="line">  [*] amboot (boot/ambamk)  ---&gt;</div>
<div class="line">    Ambarella Bootloader Configuration  ---&gt;</div>
<div class="line">      Firmware Options  ---&gt;</div>
<div class="line">        Firmware Layout Style (Flexible Firmware Layout)  ---&gt;</div>
<div class="line">          (X) Flexible Firmware Layout</div>
<div class="line">      <span class="comment">// If secure boot is used, &quot;Reload DTB&quot; should be selected.</span></div>
<div class="line">      AMBoot Options  ---&gt;</div>
<div class="line">        [*] Boot with TrustZone  ---&gt;</div>
<div class="line">          [*]   Secure DTB with Signature (SOC Firmware Config)</div>
<div class="line">            [*]     Reload DTB in PTB partiton</div>
<div class="line">app  ---&gt;</div>
<div class="line">  utility  ---&gt;</div>
<div class="line">    upgrade_partition  ---&gt;</div>
<div class="line">      [*] upgrade-partition (app/utility/upgrade_partition/app)</div>
<div class="line">      -*- libfdt (app/utility/upgrade_partition/libfdt)</div>
<div class="line">rootfs  ---&gt;</div>
<div class="line">  [ ] backup-cpio (rootfs/backup-cpio)  ----  <span class="comment">// unselect</span></div>
<div class="line"><span class="comment">// For NAND flash, add the mtd utils</span></div>
<div class="line">prebuild  ---&gt;</div>
<div class="line">  oss  ---&gt;</div>
<div class="line">    [*] prebuild-mtd-utils (prebuild/oss/armv8-a/mtd-utils)</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>For Cooper Yocto Build:</dt><dd><div class="fragment"><div class="line">build$ make ipcam_lp5_config</div>
<div class="line">build$ make menuconfig</div>
<div class="line">meta-ambabsp  ---&gt;</div>
<div class="line">  recipes-bsp  ---&gt;</div>
<div class="line">    [*] ambfw (meta-ambabsp/recipes-bsp/boot)  ---&gt;</div>
<div class="line">      AMBFW Configuration  ---&gt;</div>
<div class="line">        [*] Build AMBFW</div>
<div class="line">        (profile.ab_upgrade) Firmware Profile</div>
<div class="line">    [*] amboot (meta-ambabsp/recipes-bsp/boot)  ---&gt;</div>
<div class="line">      Ambarella Bootloader Configuration  ---&gt;</div>
<div class="line">        Firmware Options  ---&gt;</div>
<div class="line">          Firmware Layout Style (Flexible Firmware Layout)  ---&gt;</div>
<div class="line">            (X) Flexible Firmware Layout</div>
<div class="line">        <span class="comment">// If secure boot is used, &quot;Reload DTB&quot; should be selected.</span></div>
<div class="line">        AMBoot Options  ---&gt;</div>
<div class="line">          [*] Boot with TrustZone  ---&gt;</div>
<div class="line">            [*]   Secure DTB with Signature (SOC Firmware Config)</div>
<div class="line">              [*]     Reload DTB in PTB partiton</div>
<div class="line">meta-ambaapp  ---&gt;</div>
<div class="line">  recipes-upgrade-partition  ---&gt;</div>
<div class="line">    [*] upgrade-partition (meta-ambaapp/recipes-upgrade-partition/upgrade-partition)</div>
<div class="line">meta-ambalib  ---&gt;</div>
<div class="line">  recipes-upgrade-partition  ---&gt;</div>
<div class="line">    [*] libfdt (meta-ambalib/recipes-upgrade-partition/libfdt)</div>
<div class="line"><span class="comment">// For NAND flash, add the mtd utils</span></div>
<div class="line">meta  ---&gt;</div>
<div class="line">  recipes-devtools  ---&gt;</div>
<div class="line">    [*] mtd-utils (meta/recipes-devtools/mtd)</div>
</div><!-- fragment --></dd></dl>
</li>
<li>Build the firmware and program it to the EVK board. <div class="fragment"><div class="line">build$ make</div>
</div><!-- fragment --> The generated firmware: <code>ambarella/out/amba_out/cv72_gage/bst_bld_env_dtb_dtb2_kernel_kernel2_rootfs_rootfs2.elf</code><br  />
 <div class="fragment"><div class="line">------ Report ------</div>
<div class="line">bst:    success</div>
<div class="line">bld:    success</div>
<div class="line">env:    success</div>
<div class="line">dtb:    success</div>
<div class="line">dtb2:   success</div>
<div class="line">kernel: success</div>
<div class="line">kernel2:    success</div>
<div class="line">rootfs: success</div>
<div class="line">rootfs2:    success</div>
</div><!-- fragment --></li>
<li>Prepare the images for AB upgrade used by the <code>upgrade_partition</code> tool.<br  />
 For the images to be used, the user can refer to <a class="el" href="../../dc/d8f/si_boot_upgrade.html#si_images_for_upgrading">3.4.2 Images for Upgrading</a> and copy them to a SD card, such as under a <code>upgrade</code> folder.</li>
<li>Get the allocated partitions.<ul>
<li>For NAND: <div class="fragment"><div class="line">board# cat /proc/mtd</div>
<div class="line">dev:    size   erasesize  <a class="code hl_variableRef" target="_blank" href="../../../library/d1/d82/cJSON_8h.html#a25d22ecc7e656d2c59332072684e8766">name</a></div>
<div class="line">mtd0: 00020000 00020000 <span class="stringliteral">&quot;bst&quot;</span></div>
<div class="line">mtd1: 00100000 00020000 <span class="stringliteral">&quot;bld&quot;</span></div>
<div class="line">mtd2: 00100000 00020000 <span class="stringliteral">&quot;dtb&quot;</span></div>
<div class="line">mtd3: 000e0000 00020000 <span class="stringliteral">&quot;dtb2&quot;</span></div>
<div class="line">mtd4: 000e0000 00020000 <span class="stringliteral">&quot;env&quot;</span></div>
<div class="line">mtd5: 00020000 00020000 <span class="stringliteral">&quot;cfg&quot;</span></div>
<div class="line">mtd6: 01000000 00020000 <span class="stringliteral">&quot;kernel&quot;</span></div>
<div class="line">mtd7: 01000000 00020000 <span class="stringliteral">&quot;kernel2&quot;</span></div>
<div class="line">mtd8: 06c00000 00020000 <span class="stringliteral">&quot;rootfs&quot;</span></div>
<div class="line">mtd9: 06c00000 00020000 <span class="stringliteral">&quot;rootfs2&quot;</span></div>
<div class="line">mtd10: 00180000 00020000 <span class="stringliteral">&quot;raw&quot;</span></div>
</div><!-- fragment --></li>
<li>For eMMC:<br  />
 Here is not an eMMC partition allocation example for AB upgrade, just for showing the eMMC partitions. <div class="fragment"><div class="line">board# cat /proc/partitions</div>
<div class="line">major minor  #blocks  <a class="code hl_variableRef" target="_blank" href="../../../library/d1/d82/cJSON_8h.html#a25d22ecc7e656d2c59332072684e8766">name</a></div>
<div class="line"> </div>
<div class="line">   1        0      65536 ram0</div>
<div class="line">  31        0     262144 mtdblock0</div>
<div class="line"> 179        0   31080448 mmcblk0</div>
<div class="line"> 179        1        128 mmcblk0p1</div>
<div class="line"> 179        2       1024 mmcblk0p2</div>
<div class="line"> 179        3        896 mmcblk0p3</div>
<div class="line"> 179        4        896 mmcblk0p4</div>
<div class="line"> 179        5      65536 mmcblk0p5</div>
<div class="line"> 179        6     524288 mmcblk0p6</div>
<div class="line"> 179        7   30471168 mmcblk0p7</div>
</div><!-- fragment --> The partition name can be obtained from device-tree information. <div class="fragment"><div class="line">board# cat /proc/device-tree/sdmmc0@fff2000000/partitions/partition@1/label</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>Insert the SD card and upgrade the system B partitions's image.<br  />
 Assume the SD card will be auto-mounted to <code>/sdcard/mmcblk1p1/</code>. <div class="fragment"><div class="line">For NAND:</div>
<div class="line"><span class="comment">// upgrade bld</span></div>
<div class="line">board# flash_erase /dev/mtd1 0 0</div>
<div class="line">board# upgrade_partition -p /dev/mtd1 /sdcard/mmcblk1p1/upgrade/bld.bin</div>
<div class="line"><span class="comment">// upgrade dtb2</span></div>
<div class="line">board# flash_erase /dev/mtd3 0 0</div>
<div class="line">board# upgrade_partition -p /dev/mtd3 /sdcard/mmcblk1p1/upgrade/dtb.img</div>
<div class="line"><span class="comment">// upgrade kernel2</span></div>
<div class="line">board# flash_erase /dev/mtd7 0 0</div>
<div class="line">board# upgrade_partition -p /dev/mtd7 /sdcard/mmcblk1p1/upgrade/kernel.img</div>
<div class="line"><span class="comment">// upgrade rootfs2</span></div>
<div class="line">board# flash_erase /dev/mtd9 0 0</div>
<div class="line">board# upgrade_partition -p /dev/mtd9 /sdcard/mmcblk1p1/upgrade/rootfs.bin</div>
<div class="line"> </div>
<div class="line">For eMMC:</div>
<div class="line"><span class="comment">// upgrade kernel2</span></div>
<div class="line">board# upgrade_partition -p /dev/mmcblk0p8 /sdcard/mmcblk1p1/upgrade/kernel.img</div>
<div class="line"><span class="comment">// upgrade rootfs2</span></div>
<div class="line">board# upgrade_partition -p /dev/mmcblk0p10 /sdcard/mmcblk1p1/upgrade/rootfs.bin</div>
<div class="line"> </div>
<div class="line">board# sync</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd><ul>
<li>If eMMC is used, the user can clean the data first and then upgrade the partition image. <div class="fragment"><div class="line">board# dd <span class="keywordflow">if</span>=/dev/zero of=/dev/mmcblk0pX</div>
</div><!-- fragment --></li>
<li>If eMMC boot partition is used as BST partition, the user must get the written permission first and then upgrade it. <div class="fragment"><div class="line">board# echo 0 &gt; /sys/block/mmcblk0boot0/force_ro</div>
<div class="line">board# upgrade_partition -p /dev/mmcblk0boot0 /sdcard/upgrade/bst.bin</div>
</div><!-- fragment --></li>
</ul>
</dd></dl>
</li>
<li>Switch to system B. <div class="fragment"><div class="line"><span class="comment">// &quot;/dev/mtd4&quot; is the ENV partition.</span></div>
<div class="line">board# upgrade_partition -e /dev/mtd4 -r -P rootfs2</div>
<div class="line">board# upgrade_partition -e /dev/mtd4 -k -P kernel2</div>
<div class="line">board# upgrade_partition -e /dev/mtd4 -n -P dtb2</div>
<div class="line"> </div>
<div class="line"><span class="comment">// If EMMC is used, &quot;/dev/mmcblk0p5&quot; is the ENV partition.</span></div>
<div class="line">board# upgrade_partition -e /dev/mmcblk0p5 -r -P rootfs2</div>
<div class="line">board# upgrade_partition -e /dev/mmcblk0p5 -k -P kernel2</div>
<div class="line">board# upgrade_partition -e /dev/mmcblk0p5 -n -P dtb2</div>
<div class="line"> </div>
<div class="line">board# sync &amp;&amp; reboot</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>For debugging purpose, the user can switch to system B in AMBoot. <div class="fragment"><div class="line">amboot# setenv bootmeta rootfs rootfs2</div>
<div class="line">amboot# setenv bootmeta kernel kernel2</div>
<div class="line">amboot# setenv bootmeta dtb dtb2</div>
<div class="line">amboot# reboot</div>
</div><!-- fragment --></dd></dl>
</li>
</ol>
<h3><a class="anchor" id="si_pba_flex_upgrade"></a>
3.4.6 PBA Upgrade Example for Flexible Firmware Layout</h3>
<p >PBA upgrade is only supported by the Amba build. For flexible firmware layout, two DTB partitions are used to do the switch between the main system and the PBA system.<br  />
 Take CV72_gage as an example, perform the following steps to setup PBA upgrade for flexible firmware layout:</p><ol type="1">
<li>Allocate the "pba" and "dtb2" partition size. <div class="fragment"><div class="line">build$ vim ambarella/boards/cv72_gage/bsp/bsp.h</div>
<div class="line"><span class="preprocessor">#define AMBOOT_PARTITION_LAYOUT \</span></div>
<div class="line"><span class="preprocessor">              MEDIA_DEV \</span></div>
<div class="line"><span class="preprocessor">              &quot;128k(bst),1024k(bld),1024k(dtb),896k(dtb2),896k(env),128k(cfg),&quot;</span> \</div>
<div class="line">              &quot;32m@0x600000(kernel),176m(rootfs),20m(pba),-(raw)&quot;</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd><ul>
<li>Ensure that the total size (6M(kernel offset) + 32M + 176M + 32M = 246M) is smaller than the NAND flash total size.</li>
<li>The space (6M) before the kernel is big enough for the bst, bld, dtb, dtb2, env and cfg in this example.</li>
<li>The partition allocation above is not suitable for eMMC. When eMMC is used, the user must allocate the partition according to the actual need, especially for the rootfs size.</li>
</ul>
</dd></dl>
</li>
<li>Create a <code>.dts</code> file and change the <code>bootargs</code> for the PBA system. <div class="fragment"><div class="line">build$ cp -rf ambarella/boards/cv72_gage/bsp/cv72_gage.dts ambarella/boards/cv72_gage/bsp/cv72_gage_pba_upgrade.dts</div>
<div class="line"><span class="comment">// change the command line for PBA system</span></div>
<div class="line">build$ vim ambarella/boards/cv72_gage/bsp/cv72_gage_pba_upgrade.dts</div>
<div class="line">bootargs = <span class="stringliteral">&quot;console=ttyS0 rootfs=ramfs root=/dev/ram rw rdinit=/linuxrc earlycon pci=nomsi&quot;</span>;</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>When eMMC is used, the boot arguments for the main system and PBA system appear as follows if the partition layout in step 1 is used. For "root=/dev/mmcblk0pX", the <code>X</code> is the sequence number of the partitions counting from 1(bst). <div class="fragment"><div class="line"><span class="comment">// For main system</span></div>
<div class="line">bootargs = <span class="stringliteral">&quot;console=ttyS0 noinitrd root=/dev/mmcblk0p8 rw rootfstype=ext4 rootwait pci=nomsi pcie_aspm=off&quot;</span>;</div>
<div class="line"><span class="comment">// For PBA system</span></div>
<div class="line">bootargs = <span class="stringliteral">&quot;console=ttyS0 rootfs=ramfs root=/dev/ram rw rdinit=/linuxrc earlycon pci=nomsi pcie_aspm=off&quot;</span>;</div>
</div><!-- fragment --></dd></dl>
</li>
<li>Create a Makefile to build the <code>dtb2.bin</code> using the DTS file in step 2. <div class="fragment"><div class="line">build$ vim ambarella/boards/cv72_gage/bsp/upgrade_dtb2.mk</div>
<div class="line">CC  := $(ENV_BUILD_TOOL)gcc</div>
<div class="line">DTC := dtc</div>
<div class="line"> </div>
<div class="line">DTC_OPTIONS := -I dts -H epapr -q</div>
<div class="line">DTC_OPTIONS += -i $(KERNEL_SRC)/arch/arm64/boot/dts/ambarella</div>
<div class="line"> </div>
<div class="line">DTC_CFLAGS  := -E -nostdinc -D__DTS__ -U linux -<a class="code hl_variableRef" target="_blank" href="../../../driver/df/dc0/group__IAV.html#gaf80df1bdae91e5f76236e6ed1110825d">x</a> assembler-with-cpp</div>
<div class="line">DTC_CFLAGS  += -I . -I $(KERNEL_SRC)/include -I$(ENV_CFG_ROOT)</div>
<div class="line">DTC_CFLAGS  += -I$(KERNEL_SRC)/arch/arm64/boot/dts/ambarella</div>
<div class="line"> </div>
<div class="line">ifeq ($(CONFIG_BACKUP_CPIO), <a class="code hl_variableRef" target="_blank" href="../../../driver/df/dc0/group__IAV.html#ga11e444dd61d48abbdd34eed23186cb4b">y</a>)</div>
<div class="line">DTS_FILE := $(BSP_DIR)/cv72_gage_pba_upgrade.dts</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">DTS_FILE := $(BSP_DIR)/cv72_gage_ab_upgrade.dts</div>
<div class="line">endif</div>
<div class="line"> </div>
<div class="line">dtb2.bin: $(DTS_FILE)</div>
<div class="line">   @$(CC) $(DTC_CFLAGS) $&lt; | $(DTC) $(DTC_OPTIONS) -S 0x10000 -O dtb -o $@</div>
<div class="line"> </div>
<div class="line">.FORCE:</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The leading indentation before @ must be generated by "tab" key.</dd></dl>
</li>
<li>Create a profile for the firmware to be generated. <div class="fragment"><div class="line">build$ vim bsp/profile.pba_upgrade</div>
<div class="line">IMAGE_FWPROG    := $(BIN_DIR)/fwp.bin</div>
<div class="line"> </div>
<div class="line">IMAGE_0_NAME    := bst</div>
<div class="line">IMAGE_0_FILE    := $(BIN_DIR)/bst.bin</div>
<div class="line">IMAGE_0_ADDR    := -1</div>
<div class="line">IMAGE_0_FLAG    := force <a class="code hl_variableRef" target="_blank" href="../../../library/d1/d82/cJSON_8h.html#a788db922597cf2fb6389e278f822e59f">raw</a></div>
<div class="line"> </div>
<div class="line">IMAGE_1_NAME    := bld</div>
<div class="line">IMAGE_1_FILE    := $(BIN_DIR)/bld.bin</div>
<div class="line">IMAGE_1_ADDR    := -1</div>
<div class="line">IMAGE_1_FLAG    := force <a class="code hl_variableRef" target="_blank" href="../../../library/d1/d82/cJSON_8h.html#a788db922597cf2fb6389e278f822e59f">raw</a></div>
<div class="line"> </div>
<div class="line">IMAGE_2_NAME    := env</div>
<div class="line">IMAGE_2_FILE    := $(BIN_DIR)/env.bin</div>
<div class="line">IMAGE_2_ADDR    := -1</div>
<div class="line">IMAGE_2_FLAG    := force</div>
<div class="line"> </div>
<div class="line">IMAGE_3_NAME    := dtb</div>
<div class="line">IMAGE_3_FILE    := $(BIN_DIR)/dtb.bin</div>
<div class="line">IMAGE_3_ADDR    := -1</div>
<div class="line">IMAGE_3_FLAG    := force</div>
<div class="line"> </div>
<div class="line">IMAGE_4_NAME    := dtb2</div>
<div class="line">IMAGE_4_FILE    := dtb2.bin</div>
<div class="line">IMAGE_4_ADDR    := -1</div>
<div class="line">IMAGE_4_FLAG    := force</div>
<div class="line"> </div>
<div class="line">IMAGE_5_NAME    := kernel</div>
<div class="line">IMAGE_5_FILE    := $(BIN_DIR)/kernel.bin</div>
<div class="line">IMAGE_5_ADDR    := $(KERNEL_RAM_START)</div>
<div class="line">IMAGE_5_FLAG    := verify compressed</div>
<div class="line"> </div>
<div class="line">IMAGE_6_NAME    := pba</div>
<div class="line">IMAGE_6_FILE    := $(BIN_DIR)/pba.bin</div>
<div class="line">IMAGE_6_ADDR    := $(KERNEL_RAM_START)</div>
<div class="line">IMAGE_6_FLAG    := verify</div>
<div class="line"> </div>
<div class="line">IMAGE_7_NAME    := rootfs</div>
<div class="line">IMAGE_7_FILE    := $(BIN_DIR)/rootfs.bin</div>
<div class="line">IMAGE_7_ADDR    := -1</div>
<div class="line">IMAGE_7_FLAG    := <a class="code hl_variableRef" target="_blank" href="../../../library/d1/d82/cJSON_8h.html#a788db922597cf2fb6389e278f822e59f">raw</a></div>
<div class="line"> </div>
<div class="line">include $(BSP_DIR)/upgrade_dtb2.mk</div>
</div><!-- fragment --></li>
<li>Create a new <code>.env</code> file for partition if needed, or use the default one located at <code>boot/amboot/src/bld/default.env</code>.<br  />
 This file can determine which DTB, kernel and rootfs partions are used for booting up the EVK board. <div class="fragment"><div class="line">build$ vim ambarella/boards/cv72_gage/bsp/cv72_gage.env</div>
<div class="line">/dts-v1/;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;config.h&quot;</span></div>
<div class="line"> </div>
<div class="line">/ {</div>
<div class="line">    compatible = <span class="stringliteral">&quot;ambarella,environment&quot;</span>;</div>
<div class="line"><span class="preprocessor">    #address-cells = &lt;1&gt;;</span></div>
<div class="line"><span class="preprocessor">    #size-cells = &lt;1&gt;;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#if defined(AMBOOT_DEV_AUTO_BOOT)</span></div>
<div class="line">    auto_boot;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    serial_num = AMBOOT_DEFAULT_SN;</div>
<div class="line"> </div>
<div class="line">    bootcmd = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    bootargs = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    kernel_meta {</div>
<div class="line">        partition = <span class="stringliteral">&quot;kernel&quot;</span>;</div>
<div class="line">        binary_id = &lt;0&gt;;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    dtb_meta {</div>
<div class="line">        partition = <span class="stringliteral">&quot;dtb&quot;</span>;</div>
<div class="line">        binary_id = &lt;0&gt;;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    rootfs_meta {</div>
<div class="line">        partition = <span class="stringliteral">&quot;rootfs&quot;</span>;</div>
<div class="line">        binary_id = &lt;0&gt;;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    netdev_eth0 {</div>
<div class="line">        mac = <span class="stringliteral">&quot;00:00:00:00:00:00&quot;</span>;</div>
<div class="line">        mask = <span class="stringliteral">&quot;0.0.0.0&quot;</span>;</div>
<div class="line">        gw = <span class="stringliteral">&quot;0.0.0.0&quot;</span>;</div>
<div class="line">        ip = <span class="stringliteral">&quot;0.0.0.0&quot;</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    tftpd {</div>
<div class="line">        server,ip = <span class="stringliteral">&quot;0.0.0.0&quot;</span>;</div>
<div class="line">        kernel,file = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">        kernel,addr = &lt;0x00000000&gt;;</div>
<div class="line">        ramdisk,file = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">        ramdisk,addr = &lt;0x00000000&gt;;</div>
<div class="line">    };</div>
<div class="line">};</div>
</div><!-- fragment --></li>
<li>Enable PBA function in menuconfig. <div class="fragment"><div class="line">build$ make ipcam_lp5_config</div>
<div class="line">build$ make menuconfig</div>
<div class="line">boot  ---&gt;</div>
<div class="line">  [*] ambfw (boot/ambamk)  ---&gt;</div>
<div class="line">    AMBFW Configuration  ---&gt;</div>
<div class="line">      [*] Build AMBFW</div>
<div class="line">      (profile.pba_upgrade) Firmware Profile</div>
<div class="line">  [*] amboot (boot/ambamk)  ---&gt;</div>
<div class="line">    Ambarella Bootloader Configuration  ---&gt;</div>
<div class="line">      Firmware Options  ---&gt;</div>
<div class="line">        Firmware Layout Style (Flexible Firmware Layout)  ---&gt;</div>
<div class="line">          (X) Flexible Firmware Layout</div>
<div class="line"><span class="comment">// If secure is used, &quot;Reload DTB&quot; should be selected.</span></div>
<div class="line">      AMBoot Options  ---&gt;</div>
<div class="line">        [*] Boot with TrustZone  ---&gt;</div>
<div class="line">          [*]   Secure DTB with Signature (SOC Firmware Config)</div>
<div class="line">            [*]     Reload DTB in PTB partiton</div>
<div class="line">app  ---&gt;</div>
<div class="line">  utility  ---&gt;</div>
<div class="line">    upgrade_partition  ---&gt;</div>
<div class="line">      [*] upgrade-partition (app/utility/upgrade_partition/app)</div>
<div class="line">      -*- libfdt (app/utility/upgrade_partition/libfdt)</div>
<div class="line">rootfs  ---&gt;</div>
<div class="line">  [*] backup-cpio (rootfs/backup-cpio)  ---&gt;</div>
<div class="line">    [*]   pba system support sdcard</div>
<div class="line"><span class="comment">// For NAND flash, add the mtd utils</span></div>
<div class="line">prebuild  ---&gt;</div>
<div class="line">  oss  ---&gt;</div>
<div class="line">    [*] prebuild-mtd-utils (prebuild/oss/armv8-a/mtd-utils)</div>
</div><!-- fragment --></li>
<li>Build the firmware and program it to the EVK board. <div class="fragment"><div class="line">build$ make</div>
</div><!-- fragment --> The generated firmware: <code>ambarella/out/amba_out/cv72_gage/bst_bld_env_dtb_dtb2_kernel_pba_rootfs.elf</code><br  />
 <div class="fragment"><div class="line">------ Report ------</div>
<div class="line">bst:    success</div>
<div class="line">bld:    success</div>
<div class="line">env:    success</div>
<div class="line">dtb:    success</div>
<div class="line">dtb2:   success</div>
<div class="line">kernel: success</div>
<div class="line">pba:    success</div>
<div class="line">rootfs: success</div>
</div><!-- fragment --></li>
<li>Prepare the images for PBA upgrade used by the <code>upgrade_partition</code> tool.<br  />
 For the images to be used, the user can refer to <a class="el" href="../../dc/d8f/si_boot_upgrade.html#si_images_for_upgrading">3.4.2 Images for Upgrading</a> and copy them to a SD card, such as under a <code>upgrade</code> folder.</li>
<li>Enter PBA. <div class="fragment"><div class="line"><span class="comment">// &quot;/dev/mtd4&quot; is the ENV partition.</span></div>
<div class="line">board# upgrade_partition -e /dev/mtd4 -k -P pba</div>
<div class="line">board# upgrade_partition -e /dev/mtd4 -n -P dtb2</div>
<div class="line"> </div>
<div class="line"><span class="comment">// If EMMC is used.</span></div>
<div class="line">board# upgrade_partition -e /dev/mmcblk0p4 -k -P pba</div>
<div class="line">board# upgrade_partition -e /dev/mmcblk0p4 -n -P dtb2</div>
<div class="line"> </div>
<div class="line">board# sync &amp;&amp; reboot</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>For debugging purpose, the user can switch to PBA system in AMBoot. <div class="fragment"><div class="line">amboot# setenv bootmeta kernel pba</div>
<div class="line">amboot# setenv bootmeta dtb dtb2</div>
<div class="line">amboot# reboot</div>
</div><!-- fragment --></dd></dl>
</li>
<li>Get the allocated partitions.<ul>
<li>For NAND: <div class="fragment"><div class="line">board# cat /proc/mtd</div>
<div class="line">dev:    size   erasesize  <a class="code hl_variableRef" target="_blank" href="../../../library/d1/d82/cJSON_8h.html#a25d22ecc7e656d2c59332072684e8766">name</a></div>
<div class="line">mtd0: 00020000 00020000 <span class="stringliteral">&quot;bst&quot;</span></div>
<div class="line">mtd1: 00100000 00020000 <span class="stringliteral">&quot;bld&quot;</span></div>
<div class="line">mtd2: 00100000 00020000 <span class="stringliteral">&quot;dtb&quot;</span></div>
<div class="line">mtd3: 000e0000 00020000 <span class="stringliteral">&quot;dtb2&quot;</span></div>
<div class="line">mtd4: 000e0000 00020000 <span class="stringliteral">&quot;env&quot;</span></div>
<div class="line">mtd5: 00020000 00020000 <span class="stringliteral">&quot;cfg&quot;</span></div>
<div class="line">mtd6: 02000000 00020000 <span class="stringliteral">&quot;kernel&quot;</span></div>
<div class="line">mtd7: 0ac00000 00020000 <span class="stringliteral">&quot;rootfs&quot;</span></div>
<div class="line">mtd8: 01400000 00020000 <span class="stringliteral">&quot;pba&quot;</span></div>
<div class="line">mtd9: 00c80000 00020000 <span class="stringliteral">&quot;raw&quot;</span></div>
</div><!-- fragment --></li>
<li>For eMMC:<br  />
 Here is not a partition allocation example for PBA upgrade, just for showing the eMMC partitions. <div class="fragment"><div class="line">board# cat /proc/partitions</div>
<div class="line">major minor  #blocks  <a class="code hl_variableRef" target="_blank" href="../../../library/d1/d82/cJSON_8h.html#a25d22ecc7e656d2c59332072684e8766">name</a></div>
<div class="line"> </div>
<div class="line">   1        0      65536 ram0</div>
<div class="line">  31        0     262144 mtdblock0</div>
<div class="line"> 179        0   31080448 mmcblk0</div>
<div class="line"> 179        1        128 mmcblk0p1</div>
<div class="line"> 179        2       1024 mmcblk0p2</div>
<div class="line"> 179        3        896 mmcblk0p3</div>
<div class="line"> 179        4        896 mmcblk0p4</div>
<div class="line"> 179        5      65536 mmcblk0p5</div>
<div class="line"> 179        6     524288 mmcblk0p6</div>
<div class="line"> 179        7   30471168 mmcblk0p7</div>
</div><!-- fragment --> The partition name can be obtained from device-tree information. <div class="fragment"><div class="line">board# cat /proc/device-tree/sdmmc0@fff2000000/partitions/partition@1/label</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>Insert the SD card and upgrade the main system partitions' image. <div class="fragment"><div class="line">board# mkdir /sdcard</div>
<div class="line">board# mount -t vfat /dev/mmcblk1p1 /sdcard</div>
<div class="line">For NAND:</div>
<div class="line"><span class="comment">// upgrade bld</span></div>
<div class="line">board# flash_erase /dev/mtd1 0 0</div>
<div class="line">board# upgrade_partition -p /dev/mtd1 /sdcard/upgrade/bld.bin</div>
<div class="line"><span class="comment">// upgrade dtb</span></div>
<div class="line">board# flash_erase /dev/mtd2 0 0</div>
<div class="line">board# upgrade_partition -p /dev/mtd2 /sdcard/upgrade/dtb.img</div>
<div class="line"><span class="comment">// upgrade kernel</span></div>
<div class="line">board# flash_erase /dev/mtd6 0 0</div>
<div class="line">board# upgrade_partition -p /dev/mtd6 /sdcard/upgrade/kernel.img</div>
<div class="line"><span class="comment">// upgrade rootfs</span></div>
<div class="line">board# flash_erase /dev/mtd7 0 0</div>
<div class="line">board# upgrade_partition -p /dev/mtd7 /sdcard/upgrade/rootfs.bin</div>
<div class="line">board# sync</div>
<div class="line">For EMMC:</div>
<div class="line"><span class="comment">// upgrade kernel</span></div>
<div class="line">board# upgrade_partition -p /dev/mmcblk0p7 /sdcard/upgrade/kernel.img</div>
<div class="line"><span class="comment">// upgrade rootfs</span></div>
<div class="line">board# upgrade_partition -p /dev/mmcblk0p8 /sdcard/upgrade/rootfs.bin</div>
<div class="line">board# sync</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>If eMMC boot partition is used as BST partition, the user must get the written permission first and then upgrade it. <div class="fragment"><div class="line">board# echo 0 &gt; /sys/block/mmcblk0boot0/force_ro</div>
<div class="line">board# upgrade_partition -p /dev/mmcblk0boot0 /sdcard/upgrade/bst.bin</div>
</div><!-- fragment --></dd></dl>
</li>
<li>Switch back to the main system. <div class="fragment"><div class="line"><span class="comment">// &quot;/dev/mtd4&quot; is the ENV partition.</span></div>
<div class="line">board# upgrade_partition -e /dev/mtd4 -k -P kernel</div>
<div class="line">board# upgrade_partition -e /dev/mtd4 -n -P dtb</div>
<div class="line"> </div>
<div class="line"><span class="comment">// If EMMC is used, &quot;/dev/mmcblk0p5&quot; is the ENV partition.</span></div>
<div class="line">board# upgrade_partition -e /dev/mmcblk0p5 -k -P kernel</div>
<div class="line">board# upgrade_partition -e /dev/mmcblk0p5 -n -P dtb</div>
<div class="line"> </div>
<div class="line">board# sync &amp;&amp; reboot</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>For debugging purpose, the user can switch to PBA system in AMBoot. <div class="fragment"><div class="line">amboot# setenv bootmeta kernel pba</div>
<div class="line">amboot# setenv bootmeta dtb dtb2</div>
<div class="line">amboot# reboot</div>
</div><!-- fragment --></dd></dl>
</li>
</ol>
<h3><a class="anchor" id="si_ab_legacy_upgrade"></a>
3.4.7 AB Upgrade Example for Legacy Firmware Layout</h3>
<p >For legacy firmware layout, a boot flag is used to do the switch between the system A and the system B.<br  />
 Take CV22_gage as an example, perform the following steps to setup AB upgrade for legacy firmware layout:</p><ol type="1">
<li>Allocate the "kernel2"(pba) and "rootfs2"(rom) partition size. <div class="fragment"><div class="line"><span class="preprocessor">#define AMBOOT_BST_SIZE     (AMBOOT_BST_FIXED_SIZE)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_BLD_SIZE     (AMBOOT_MIN_PART_SIZE * 8)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_PTB_SIZE     (AMBOOT_MIN_PART_SIZE * 7)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_ATF_SIZE     (AMBOOT_MIN_PART_SIZE * 8)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_PBA_SIZE     (16  * 1024 * 1024)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_PRI_SIZE     (16  * 1024 * 1024)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_ROM_SIZE     (108  * 1024 * 1024)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_LNX_SIZE     (108  * 1024 * 1024)</span></div>
<div class="line">...</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The partition allocation above is not suitable for eMMC. When eMMC is used, the user must allocate the partition according to the actual need, especially for the rootfs size.</dd></dl>
</li>
<li>Modify the <code>bootargs</code> for booting up the system A. <div class="fragment"><div class="line">build$ vim ambarella/boards/cv22_walnut/bsp/cv22_walnut.dts</div>
<div class="line">bootargs = <span class="stringliteral">&quot;console=ttyS0 ubi.mtd=lnx root=ubi0:rootfs rw rootfstype=ubifs&quot;</span>;</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd><ul>
<li>Although the boot arguments (bootargs) can be set in the menuconfig, it is sugguested to keep the same as the one set in DTS file. Because the bootargs set in menuconfig will not be compiled into the DTB image. It takes effect only in the programming stage.</li>
<li>When eMMC is used, the bootargs for the main system and PBA system appear as follows if the partition layout in step 1 is used. For "root=/dev/mmcblk0pX", the <code>X</code> is the sequence number of the partitions counting from 1(bst). <div class="fragment"><div class="line"><span class="comment">// For system A</span></div>
<div class="line">bootargs = <span class="stringliteral">&quot;console=ttyS0 noinitrd root=/dev/mmcblk0p8 rw rootfstype=ext4 rootwait&quot;</span>;</div>
<div class="line"><span class="comment">// For system B</span></div>
<div class="line">bootargs = <span class="stringliteral">&quot;console=ttyS0 noinitrd root=/dev/mmcblk0p7 rw rootfstype=ext4 rootwait&quot;</span>;</div>
</div><!-- fragment --></li>
</ul>
</dd></dl>
</li>
<li>Modify the <code>ambarella/boards/&lt;board_name&gt;/bsp/bsp.c</code>.<br  />
 The bootloader must obtain the boot flag (boot_opt) to determine which bootargs to be used and from which partition to load the kernel: PRI or PBA. <div class="fragment"><div class="line"><span class="keywordtype">int</span> amboot_bsp_entry(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">char</span> *cmdline = CONFIG_AMBOOT_SWAP_CMDLINE;</div>
<div class="line">  <a class="code hl_typedefRef" target="_blank" href="../../../driver/d0/dfa/group__iav-typedef.html#ga10e94b422ef0c20dcdec20d31a1f5049">u32</a> boot_opt = 0;</div>
<div class="line">  <span class="keywordtype">int</span> retval = 0;</div>
<div class="line"> </div>
<div class="line">  retval = env_get_boot_opt(&amp;boot_opt);</div>
<div class="line">  <span class="keywordflow">if</span> (retval &lt; 0)</div>
<div class="line">    <span class="keywordflow">return</span> retval;</div>
<div class="line">  <span class="keywordflow">if</span> (boot_opt &gt; 0) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Find BIOS boot flag\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (cmdline) {</div>
<div class="line">      retval = env_set_cmdline(cmdline);</div>
<div class="line">        <span class="keywordflow">if</span> (retval &lt; 0)</div>
<div class="line">          <span class="keywordflow">return</span> retval;</div>
<div class="line">    }</div>
<div class="line">    retval = 2;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> retval;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__iav-typedef_html_ga10e94b422ef0c20dcdec20d31a1f5049"><div class="ttname"><a href="../../../driver/d0/dfa/group__iav-typedef.html#ga10e94b422ef0c20dcdec20d31a1f5049">u32</a></div><div class="ttdeci">unsigned int u32</div></div>
</div><!-- fragment --></li>
<li>Configure the AB system in menuconfig. <dl class="section user"><dt>For CV2x SDK 3.0 Amba build:</dt><dd><div class="fragment"><div class="line">build$ make cv22_ipcam_config</div>
<div class="line">build$ make menuconfig</div>
<div class="line">Ambarella Bootloader Configuration  ---&gt;</div>
<div class="line">  AMBoot Options  ---&gt;</div>
<div class="line">    Common Boot Options  ---&gt;</div>
<div class="line">      (console=ttyS0 ubi.mtd=lnx root=ubi0:rootfs rw rootfstype=ubifs) Booting cmdline  <span class="comment">//If rootfs type is UBIFS.</span></div>
<div class="line">      (console=ttyS0 ubi.mtd=rom root=ubi0:rootfs rw rootfstype=ubifs) Booting cmdline <span class="keywordflow">for</span> swap upgrade</div>
<div class="line">     Firmware Options  ---&gt;</div>
<div class="line">       Persistent BIOS App Partition  ---&gt;</div>
<div class="line">         ($(AMB_BOARD_OUT)/kernel/Image) PBA</div>
<div class="line">         ($(AMB_TOPDIR)/amboot/vif/kernel.info) PBA Version File</div>
<div class="line">       ROMFS Partition  ---&gt;</div>
<div class="line">         ($(AMB_BOARD_OUT)/rootfs/ubifs) Romfs image</div>
<div class="line">         ($(AMB_TOPDIR)/amboot/vif/ubifs.info) ROMFS Version File</div>
<div class="line">[*] Ambarella File System Configuration  ---&gt;</div>
<div class="line">  Linux Root File System (UBIFS)  ---&gt;</div>
<div class="line">    (X) UBIFS</div>
<div class="line">  Open Source Software (OSS)  ---&gt;</div>
<div class="line">    Filesystem Tools  ---&gt;</div>
<div class="line">      [*] Add mtd utils into root_fs</div>
<div class="line">[*] Ambarella Application Configuration  ---&gt;</div>
<div class="line">  [*]   Build Utilities  ---&gt;</div>
<div class="line">    [*]   Build Ambarella upgrade partition</div>
<div class="line">      Upgrade partition tool (Build <span class="keywordflow">for</span> Kernel 4.X and 5.X)  ---&gt;</div>
<div class="line">        (X) Build <span class="keywordflow">for</span> Kernel 4.X and 5.X</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>For Cooper Amba build:</dt><dd><div class="fragment"><div class="line">build$ make ipcam_config</div>
<div class="line">build$ make menuconfig</div>
<div class="line">boot  ---&gt;</div>
<div class="line">  [ ] ambfw (boot/ambamk)  ----</div>
<div class="line">  [*] amboot (boot/ambamk)  ---&gt;</div>
<div class="line">    Ambarella Bootloader Configuration  ---&gt;</div>
<div class="line">      Firmware Options  ---&gt;</div>
<div class="line">        Firmware Layout Style (Legacy Firmware Layout)  ---&gt;</div>
<div class="line">          (X) Legacy Firmware Layout</div>
<div class="line">      Persistent BIOS App Partition  ---&gt;</div>
<div class="line">        ($(ENV_IMG_ROOT)/kernel.bin)  PBA</div>
<div class="line">        ($(AMBOOT_TOPDIR)/vif/kernel.info)  PBA Version File</div>
<div class="line">      ROMFS Partition  ---&gt;</div>
<div class="line">        ($(ENV_IMG_ROOT)/rootfs.bin) Romfs image</div>
<div class="line">        ($(AMBOOT_TOPDIR)/vif/ubifs.info) ROMFS Version File</div>
<div class="line">      AMBoot Options  ---&gt;</div>
<div class="line">        Common Boot Options  ---&gt;</div>
<div class="line">          (console=ttyS0 ubi.mtd=lnx root=ubi0:rootfs rw rootfstype=ubifs) Booting cmdline  <span class="comment">//If rootfs type is UBIFS.</span></div>
<div class="line">          (console=ttyS0 ubi.mtd=rom root=ubi0:rootfs rw rootfstype=ubifs) Booting cmdline <span class="keywordflow">for</span> swap upgrade</div>
<div class="line">rootfs  ---&gt;</div>
<div class="line">  [ ] backup-cpio (rootfs/backup-cpio)  ----</div>
<div class="line">  [*]   rootfs (rootfs/system)  ---&gt;</div>
<div class="line">    Linux Root File System (UBIFS)  ---&gt;</div>
<div class="line">      (X) UBIFS</div>
<div class="line">app  ---&gt;</div>
<div class="line">  utility  ---&gt;</div>
<div class="line">    upgrade_partition  ---&gt;</div>
<div class="line">      [*] upgrade-partition (app/utility/upgrade_partition/app)</div>
<div class="line">      -*- libfdt (app/utility/upgrade_partition/libfdt)</div>
<div class="line"><span class="comment">// For NAND flash, add the mtd utils</span></div>
<div class="line">prebuild  ---&gt;</div>
<div class="line">  oss  ---&gt;</div>
<div class="line">    [*] prebuild-mtd-utils (prebuild/oss/armv8-a/mtd-utils)</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>For Cooper Yocto build:</dt><dd><div class="fragment"><div class="line">build$ make ipcam_config</div>
<div class="line">build$ make menuconfig</div>
<div class="line">meta-ambabsp  ---&gt;</div>
<div class="line">  recipes-bsp  ---&gt;</div>
<div class="line">    [ ] ambfw (meta-ambabsp/recipes-bsp/boot)  ---</div>
<div class="line">    [*] amboot (meta-ambabsp/recipes-bsp/boot)  ---&gt;</div>
<div class="line">      Ambarella Bootloader Configuration  ---&gt;</div>
<div class="line">        Firmware Options  ---&gt;</div>
<div class="line">          Firmware Layout Style (Legacy Firmware Layout)  ---&gt;</div>
<div class="line">            (X) Legacy Firmware Layout</div>
<div class="line">          Persistent BIOS App Partition  ---&gt;</div>
<div class="line">            ($(ENV_IMG_ROOT)/kernel.bin)  PBA</div>
<div class="line">            ($(AMBOOT_TOPDIR)/vif/kernel.info)  PBA Version File</div>
<div class="line">          ROMFS Partition  ---&gt;</div>
<div class="line">            ($(ENV_IMG_ROOT)/rootfs.bin)  Romfs image</div>
<div class="line">            ($(AMBOOT_TOPDIR)/vif/ubifs.info) ROMFS Version File</div>
<div class="line">        AMBoot Options  ---&gt;</div>
<div class="line">          Common Boot Options  ---&gt;</div>
<div class="line">            (console=ttyS0 ubi.mtd=lnx root=ubi0:rootfs rw rootfstype=ubifs) Booting cmdline  <span class="comment">//If rootfs type is UBIFS.</span></div>
<div class="line">            (console=ttyS0 ubi.mtd=rom root=ubi0:rootfs rw rootfstype=ubifs) Booting cmdline <span class="keywordflow">for</span> swap upgrade</div>
<div class="line">    [*] amrootfs (meta-ambabsp/recipes-bsp/amrootfs)  ---&gt;</div>
<div class="line">      Linux Root File System (UBIFS)  ---&gt;</div>
<div class="line">        (X) UBIFS</div>
<div class="line">meta-ambaapp  ---&gt;</div>
<div class="line">  recipes-upgrade-partition  ---&gt;</div>
<div class="line">    [*] upgrade-partition (meta-ambaapp/recipes-upgrade-partition/upgrade-partition)</div>
<div class="line">meta-ambalib  ---&gt;</div>
<div class="line">  recipes-upgrade-partition  ---&gt;</div>
<div class="line">    [*] libfdt (meta-ambalib/recipes-upgrade-partition/libfdt)</div>
<div class="line"><span class="comment">// For NAND flash, add the mtd utils</span></div>
<div class="line">meta  ---&gt;</div>
<div class="line">  recipes-devtools  ---&gt;</div>
<div class="line">    [*] mtd-utils (meta/recipes-devtools/mtd)</div>
</div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The generated rootfs size may be larger than the partition size allocated in step 1, the user can remove some unwanted configurations in menuconfig to reduce the size.</li>
</ul>
</dd></dl>
</li>
<li>Build the firmware and program it to the EVK board. <dl class="section user"><dt>For SDK 3.0 Amba Build:</dt><dd><div class="fragment"><div class="line">build$ make -j8</div>
</div><!-- fragment --> The generated firmware path: <code>ambarella/out/cv22_walnut/images/bst_bld_pba_kernel_romfs_lnx_release.elf</code>. </dd></dl>
<dl class="section user"><dt>For Cooper SDK:</dt><dd><div class="fragment"><div class="line">build$ make</div>
</div><!-- fragment --> The generated firmware path: <code>ambarella/out/&lt;amba|yocto&gt;_out/cv22_walnut/images/bst_bld_pba_kernel_romfs_lnx_release.elf</code>.<br  />
 The firmware program log: <div class="fragment"><div class="line">------ Report ------</div>
<div class="line">bst:    success</div>
<div class="line">bld:    success</div>
<div class="line">pba:    success</div>
<div class="line">pri:    success</div>
<div class="line">rom:    success</div>
<div class="line">lnx:    success</div>
</div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Usually, when programming the firmware into the flash in AMBoot through the AmbaUSB tool, the available dynamic random access memory (DRAM) size must be large enough to store the whole firmware. Because before the firmware is programmed into the flash, it will be loaded into the DRAM first. If the user's hardware DRAM resources are strained, there are two ways for the user to handle this situation:<ul>
<li>Program these partitions respectively through the AmbaUSB tool.</li>
<li>Build a normal firmware and program the extra partitions respectively via the <code>upgrade_partition</code> tool, the same as the image upgrade operations.</li>
</ul>
</dd></dl>
</li>
<li>Prepare the images for AB upgrade used by the <code>upgrade_partition</code> tool.<br  />
 For the images to be used, the user can refer to <a class="el" href="../../dc/d8f/si_boot_upgrade.html#si_images_for_upgrading">3.4.2 Images for Upgrading</a> and copy them to a SD card, such as under a <code>upgrade</code> folder.</li>
<li>Verify the partition after booting up the board.<br  />
<ul>
<li><p class="startli">Verify the partitions. For NAND: </p><div class="fragment"><div class="line">board # cat /proc/mtd</div>
<div class="line">dev:    size   erasesize  <a class="code hl_variableRef" target="_blank" href="../../../library/d1/d82/cJSON_8h.html#a25d22ecc7e656d2c59332072684e8766">name</a></div>
<div class="line">mtd0: 00020000 00020000 <span class="stringliteral">&quot;bst&quot;</span></div>
<div class="line">mtd1: 00100000 00020000 <span class="stringliteral">&quot;bld&quot;</span></div>
<div class="line">mtd2: 000e0000 00020000 <span class="stringliteral">&quot;ptb&quot;</span></div>
<div class="line">mtd3: 00100000 00020000 <span class="stringliteral">&quot;atf&quot;</span></div>
<div class="line">mtd4: 01000000 00020000 <span class="stringliteral">&quot;pba&quot;</span></div>
<div class="line">mtd5: 01000000 00020000 <span class="stringliteral">&quot;pri&quot;</span></div>
<div class="line">mtd6: 06000000 00020000 <span class="stringliteral">&quot;rom&quot;</span></div>
<div class="line">mtd7: 06000000 00020000 <span class="stringliteral">&quot;lnx&quot;</span></div>
<div class="line">mtd8: 00c00000 00020000 <span class="stringliteral">&quot;add&quot;</span></div>
<div class="line">mtd9: 01080000 00020000 <span class="stringliteral">&quot;raw&quot;</span></div>
<div class="line"> </div>
<div class="line">board # cat /proc/cmdline</div>
<div class="line">console=ttyS0 ubi.mtd=lnx root=ubi0:rootfs rw rootfstype=ubifs init=/linuxrc</div>
</div><!-- fragment --><p class="startli">For eMMC:<br  />
 Here is not a partition allocation example for AB upgrade, just for showing the eMMC partitions. </p><div class="fragment"><div class="line">board# cat /proc/partitions</div>
<div class="line">major minor  #blocks  <a class="code hl_variableRef" target="_blank" href="../../../library/d1/d82/cJSON_8h.html#a25d22ecc7e656d2c59332072684e8766">name</a></div>
<div class="line"> </div>
<div class="line">   1        0      65536 ram0</div>
<div class="line">  31        0     262144 mtdblock0</div>
<div class="line"> 179        0   31080448 mmcblk0</div>
<div class="line"> 179        1        128 mmcblk0p1</div>
<div class="line"> 179        2       1024 mmcblk0p2</div>
<div class="line"> 179        3        896 mmcblk0p3</div>
<div class="line"> 179        4        896 mmcblk0p4</div>
<div class="line"> 179        5      65536 mmcblk0p5</div>
<div class="line"> 179        6     524288 mmcblk0p6</div>
<div class="line"> 179        7   30471168 mmcblk0p7</div>
<div class="line"> </div>
<div class="line">board # cat /proc/cmdline</div>
<div class="line">console=ttyS0 noinitrd root=/dev/mmcblk0p6 rw rootfstype=ext4 rootwait</div>
</div><!-- fragment --><p> The partition name can be got from device-tree info. </p><div class="fragment"><div class="line">board# cat /proc/device-tree/sdmmc0@fff2000000/partitions/partition@1/label</div>
</div><!-- fragment --></li>
<li>Switch to the system B. <div class="fragment"><div class="line">board # upgrade_partition -S 2</div>
<div class="line">board # reboot</div>
</div><!-- fragment --></li>
<li>Switch back to the system A. <div class="fragment"><div class="line">board # upgrade_partition -S 0</div>
<div class="line">board # reboot</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>Insert the SD card and upgrade the system B partitions' image.<br  />
 Assume the SD card will be auto-mounted to <code>/sdcard/mmcblk1p1/</code>. <div class="fragment"><div class="line">For NAND:</div>
<div class="line"><span class="comment">// upgrade bst</span></div>
<div class="line">board# flash_erase /dev/mtd0 0 0</div>
<div class="line">board# upgrade_partition -p /dev/mtd0 /sdcard/mmcblk1p1/upgrade/bst.bin</div>
<div class="line"><span class="comment">// upgrade bld</span></div>
<div class="line">board# flash_erase /dev/mtd1 0 0</div>
<div class="line">board# upgrade_partition -p -G /dev/mtd1 /sdcard/mmcblk1p1/upgrade/bld.bin</div>
<div class="line"><span class="comment">// upgrade dtb</span></div>
<div class="line">board# upgrade_partition -d /sdcard/mmcblk1p1/upgrade/dtb.bin</div>
<div class="line"><span class="comment">// upgrade kernel2(pba)</span></div>
<div class="line">board# flash_erase /dev/mtd4 0 0</div>
<div class="line">board# upgrade_partition -p -Q /dev/mtd4 /sdcard/mmcblk1p1/upgrade/pba.bin</div>
<div class="line"><span class="comment">// upgrade rootfs2(rom)</span></div>
<div class="line">board# flash_erase /dev/mtd6 0 0</div>
<div class="line">board# upgrade_partition -p -R /dev/mtd6 /sdcard/mmcblk1p1/upgrade/rootfs.bin</div>
<div class="line"> </div>
<div class="line">For EMMC:</div>
<div class="line"><span class="comment">// upgrade kernel2(pba)</span></div>
<div class="line">board# upgrade_partition -p /dev/mmcblk0p5 /sdcard/mmcblk1p1/upgrade/kernel.bin</div>
<div class="line"><span class="comment">// upgrade rootfs2(rom)</span></div>
<div class="line">board# upgrade_partition -p /dev/mmcblk0p7 /sdcard/mmcblk1p1/upgrade/rootfs.bin</div>
<div class="line"> </div>
<div class="line">board# sync</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd><ul>
<li>If eMMC is used, the user can clean the data first and then upgrade the partition image. <div class="fragment"><div class="line">board# umount /dev/mmcblk0pX</div>
<div class="line">board# dd <span class="keywordflow">if</span>=/dev/zero of=/dev/mmcblk0pX</div>
</div><!-- fragment --></li>
<li>If eMMC boot partition is used as BST partition, the user must get the written permission first and then upgrade it. <div class="fragment"><div class="line">board# echo 0 &gt; /sys/block/mmcblk0boot0/force_ro</div>
<div class="line">board# upgrade_partition -p /dev/mmcblk0boot0 /sdcard/mmcblk1p1/upgrade/bst.bin</div>
</div><!-- fragment --></li>
</ul>
</dd></dl>
</li>
<li>Switch to the system B. <div class="fragment"><div class="line">board# upgrade_partition -S 2</div>
<div class="line">board# sync &amp;&amp; reboot</div>
</div><!-- fragment --></li>
</ol>
<h3><a class="anchor" id="si_pba_legacy_upgrade"></a>
3.4.8 PBA Upgrade Example for Legacy Firmware Layout</h3>
<p >For legacy firmware layout, a boot flag is used to do the switch between the main system and the PBA system.<br  />
 Take CV22_gage as an example, perform the following steps to setup PBA upgrade for legacy firmware layout:</p><ol type="1">
<li>Alloc the <code>PBA</code> partition size. <div class="fragment"><div class="line"><span class="preprocessor">#define AMBOOT_BST_SIZE     (AMBOOT_BST_FIXED_SIZE)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_BLD_SIZE     (AMBOOT_MIN_PART_SIZE * 8)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_PTB_SIZE     (AMBOOT_MIN_PART_SIZE * 7)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_ATF_SIZE     (AMBOOT_MIN_PART_SIZE * 8)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_PBA_SIZE     (20  * 1024 * 1024)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_PRI_SIZE     (16  * 1024 * 1024)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_ROM_SIZE     (0  * 1024 * 1024)</span></div>
<div class="line"><span class="preprocessor">#define AMBOOT_LNX_SIZE     (208  * 1024 * 1024)</span></div>
<div class="line">...</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The partition allocation above is not suitable for eMMC. When eMMC is used, the user must allocate the partition according to the actual need, especially for the rootfs size.</dd></dl>
</li>
<li>Modify the <code>bootargs</code> for booting up the main system. <div class="fragment"><div class="line">build$ vim ambarella/boards/cv22_walnut/bsp/cv22_walnut.dts</div>
<div class="line">bootargs = <span class="stringliteral">&quot;console=ttyS0 ubi.mtd=lnx root=ubi0:rootfs rw rootfstype=ubifs&quot;</span>;</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd><ul>
<li>Although the bootargs can be set in the menuconfig, it is sugguested to keep the same as the one set in DTS file. Because the bootargs set in menuconfig will not be compiled into the DTB image. It takes effect only in the programming stage. For "root=/dev/mmcblk0pX", the <code>X</code> is the sequence number of the partitions counting from 1(bst).</li>
<li>When eMMC is used, the bootargs for the main system appear as follows if the partition layout in step 1 is used. <div class="fragment"><div class="line"><span class="comment">// For main system</span></div>
<div class="line">bootargs = <span class="stringliteral">&quot;console=ttyS0 noinitrd root=/dev/mmcblk0p7 rw rootfstype=ext4 rootwait&quot;</span>;</div>
</div><!-- fragment --></li>
</ul>
</dd></dl>
</li>
<li>Modify the <code>ambarella/boards/&lt;board_name&gt;/bsp/bsp.c</code>.<br  />
 The bootloader must obtain the boot flag (boot_opt) to determine which bootargs to be used and from which partition to load the kernel: PRI or PBA. <div class="fragment"><div class="line"><span class="keywordtype">int</span> amboot_bsp_entry(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">char</span> *cmdline = CONFIG_AMBOOT_SWAP_CMDLINE;</div>
<div class="line">  <a class="code hl_typedefRef" target="_blank" href="../../../driver/d0/dfa/group__iav-typedef.html#ga10e94b422ef0c20dcdec20d31a1f5049">u32</a> boot_opt = 0;</div>
<div class="line">  <span class="keywordtype">int</span> retval = 0;</div>
<div class="line"> </div>
<div class="line">  retval = env_get_boot_opt(&amp;boot_opt);</div>
<div class="line">  <span class="keywordflow">if</span> (retval &lt; 0)</div>
<div class="line">    <span class="keywordflow">return</span> retval;</div>
<div class="line">  <span class="keywordflow">if</span> (boot_opt &gt; 0) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Find BIOS boot flag\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (cmdline) {</div>
<div class="line">      retval = env_set_cmdline(cmdline);</div>
<div class="line">        <span class="keywordflow">if</span> (retval &lt; 0)</div>
<div class="line">          <span class="keywordflow">return</span> retval;</div>
<div class="line">    }</div>
<div class="line">    retval = 2;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> retval;</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>Configure the PBA system in menuconfig. <dl class="section user"><dt>For CV2x SDK 3.0 Amba build:</dt><dd><div class="fragment"><div class="line">build$ make cv22_ipcam_config</div>
<div class="line">build$ make menuconfig</div>
<div class="line">Ambarella Bootloader Configuration  ---&gt;</div>
<div class="line">  AMBoot Options  ---&gt;</div>
<div class="line">    Common Boot Options  ---&gt;</div>
<div class="line">      (console=ttyS0 ubi.mtd=lnx root=ubi0:rootfs rw rootfstype=ubifs) Booting cmdline  <span class="comment">//If rootfs type is UBIFS.</span></div>
<div class="line">      (console=ttyS0 rootfs=ramfs root=/dev/ram rw rdinit=/linuxrc) Booting cmdline <span class="keywordflow">for</span> swap upgrade</div>
<div class="line">     Firmware Options  ---&gt;</div>
<div class="line">       Persistent BIOS App Partition  ---&gt;</div>
<div class="line">         ($(AMB_BOARD_OUT)/kernel/pba_zImage) PBA</div>
<div class="line">         ($(AMB_TOPDIR)/amboot/vif/pba.info) PBA Version File</div>
<div class="line">[*] Ambarella File System Configuration  ---&gt;</div>
<div class="line">  Linux Root File System (UBIFS)  ---&gt;</div>
<div class="line">    (X) UBIFS</div>
<div class="line">  Open Source Software (OSS)  ---&gt;</div>
<div class="line">    Filesystem Tools  ---&gt;</div>
<div class="line">      [*] Add mtd utils into root_fs</div>
<div class="line">[*] Ambarella Application Configuration  ---&gt;</div>
<div class="line">  [*]   Build Utilities  ---&gt;</div>
<div class="line">    [*]   Build Ambarella upgrade partition</div>
<div class="line">      Upgrade partition tool (Build <span class="keywordflow">for</span> Kernel 4.X and 5.X)  ---&gt;</div>
<div class="line">        (X) Build <span class="keywordflow">for</span> Kernel 4.X and 5.X</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>For Cooper Amba build:</dt><dd><div class="fragment"><div class="line">build$ make ipcam_config</div>
<div class="line">build$ make menuconfig</div>
<div class="line">boot  ---&gt;</div>
<div class="line">  [ ] ambfw (boot/ambamk)  ----</div>
<div class="line">  [*] amboot (boot/ambamk)  ---&gt;</div>
<div class="line">    Ambarella Bootloader Configuration  ---&gt;</div>
<div class="line">      Firmware Options  ---&gt;</div>
<div class="line">        Firmware Layout Style (Legacy Firmware Layout)  ---&gt;</div>
<div class="line">          (X) Legacy Firmware Layout</div>
<div class="line">      Persistent BIOS App Partition  ---&gt;</div>
<div class="line">        ($(ENV_IMG_ROOT)/pba.bin)  PBA</div>
<div class="line">        ($(AMBOOT_TOPDIR)/vif/pba.info)  PBA Version File</div>
<div class="line">      AMBoot Options  ---&gt;</div>
<div class="line">        Common Boot Options  ---&gt;</div>
<div class="line">          (console=ttyS0 ubi.mtd=lnx root=ubi0:rootfs rw rootfstype=ubifs) Booting cmdline  <span class="comment">//If rootfs type is UBIFS.</span></div>
<div class="line">          (console=ttyS0 rootfs=ramfs root=/dev/ram rw rdinit=/linuxrc) Booting cmdline <span class="keywordflow">for</span> swap upgrade</div>
<div class="line">rootfs  ---&gt;</div>
<div class="line">  [ ] backup-cpio (rootfs/backup-cpio)  ----</div>
<div class="line">  [*]   rootfs (rootfs/system)  ---&gt;</div>
<div class="line">    Linux Root File System (UBIFS)  ---&gt;</div>
<div class="line">      (X) UBIFS</div>
<div class="line">app  ---&gt;</div>
<div class="line">  utility  ---&gt;</div>
<div class="line">    upgrade_partition  ---&gt;</div>
<div class="line">      [*] upgrade-partition (app/utility/upgrade_partition/app)</div>
<div class="line">      -*- libfdt (app/utility/upgrade_partition/libfdt)</div>
<div class="line"><span class="comment">// For NAND flash, add the mtd utils</span></div>
<div class="line">prebuild  ---&gt;</div>
<div class="line">  oss  ---&gt;</div>
<div class="line">    [*] prebuild-mtd-utils (prebuild/oss/armv8-a/mtd-utils)</div>
</div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>To save the storage size, the user can remove some unwanted kernel and rootfs configurations in menuconfig to reduce the firmware size.</li>
</ul>
</dd></dl>
</li>
<li>Build the firmware and program it to the EVK board. <dl class="section user"><dt>For SDK 3.0 Amba Build:</dt><dd><div class="fragment"><div class="line">build$ make -j8</div>
</div><!-- fragment --> The generated firmware path: <code>ambarella/out/cv22_walnut/images/bst_bld_pba_kernel_lnx_release.elf</code>. </dd></dl>
<dl class="section user"><dt>For Cooper SDK:</dt><dd><div class="fragment"><div class="line">build$ make</div>
</div><!-- fragment --> The generated firmware path: <code>ambarella/out/&lt;amba|yocto&gt;_out/cv22_walnut/firmware/bst_bld_pba_kernel_lnx_release.elf</code>.<br  />
 The firmware program log: <div class="fragment"><div class="line">------ Report ------</div>
<div class="line">bst:    success</div>
<div class="line">bld:    success</div>
<div class="line">pba:    success</div>
<div class="line">pri:    success</div>
<div class="line">lnx:    success</div>
</div><!-- fragment --></dd></dl>
</li>
<li>Prepare the images for PBA upgrade used by the <code>upgrade_partition</code> tool.<br  />
 For the images to be used, the user can refer to <a class="el" href="../../dc/d8f/si_boot_upgrade.html#si_images_for_upgrading">3.4.2 Images for Upgrading</a> and copy them to a SD card, such as under a <code>upgrade</code> folder.</li>
<li>Verify the partition after booting up the board.<br  />
<ul>
<li><p class="startli">Verify the partitions. For NAND: </p><div class="fragment"><div class="line">board # cat /proc/mtd</div>
<div class="line">dev:    size   erasesize  <a class="code hl_variableRef" target="_blank" href="../../../library/d1/d82/cJSON_8h.html#a25d22ecc7e656d2c59332072684e8766">name</a></div>
<div class="line">mtd0: 00020000 00020000 <span class="stringliteral">&quot;bst&quot;</span></div>
<div class="line">mtd1: 00100000 00020000 <span class="stringliteral">&quot;bld&quot;</span></div>
<div class="line">mtd2: 000e0000 00020000 <span class="stringliteral">&quot;ptb&quot;</span></div>
<div class="line">mtd3: 00100000 00020000 <span class="stringliteral">&quot;atf&quot;</span></div>
<div class="line">mtd4: 01400000 00020000 <span class="stringliteral">&quot;pba&quot;</span></div>
<div class="line">mtd5: 01000000 00020000 <span class="stringliteral">&quot;pri&quot;</span></div>
<div class="line">mtd6: 0D000000 00020000 <span class="stringliteral">&quot;lnx&quot;</span></div>
<div class="line">mtd7: 00880000 00020000 <span class="stringliteral">&quot;raw&quot;</span></div>
<div class="line"> </div>
<div class="line">board # cat /proc/cmdline</div>
<div class="line">console=ttyS0 ubi.mtd=lnx root=ubi0:rootfs rw rootfstype=ubifs init=/linuxrc</div>
</div><!-- fragment --><p class="startli">For eMMC:<br  />
 Here is not a partition allocation example for PBA upgrade, just for showing the eMMC partitions. </p><div class="fragment"><div class="line">board# cat /proc/partitions</div>
<div class="line">major minor  #blocks  <a class="code hl_variableRef" target="_blank" href="../../../library/d1/d82/cJSON_8h.html#a25d22ecc7e656d2c59332072684e8766">name</a></div>
<div class="line"> </div>
<div class="line">   1        0      65536 ram0</div>
<div class="line">  31        0     262144 mtdblock0</div>
<div class="line"> 179        0   31080448 mmcblk0</div>
<div class="line"> 179        1        128 mmcblk0p1</div>
<div class="line"> 179        2       1024 mmcblk0p2</div>
<div class="line"> 179        3        896 mmcblk0p3</div>
<div class="line"> 179        4        896 mmcblk0p4</div>
<div class="line"> 179        5      65536 mmcblk0p5</div>
<div class="line"> 179        6     524288 mmcblk0p6</div>
<div class="line"> 179        7   30471168 mmcblk0p7</div>
<div class="line"> </div>
<div class="line">board # cat /proc/cmdline</div>
<div class="line">console=ttyS0 noinitrd root=/dev/mmcblk0p6 rw rootfstype=ext4 rootwait</div>
</div><!-- fragment --><p> The partition name can be obtained from device-tree information. </p><div class="fragment"><div class="line">board# cat /proc/device-tree/sdmmc0@fff2000000/partitions/partition@1/label</div>
</div><!-- fragment --></li>
<li>Switch to the PBA system. <div class="fragment"><div class="line">board # upgrade_partition -S 2</div>
<div class="line">board # reboot</div>
</div><!-- fragment --></li>
<li>Switch back to the main system. <div class="fragment"><div class="line">board # upgrade_partition -S 0</div>
<div class="line">board # reboot</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>Insert the SD card and upgrade the main system partitions' image.<br  />
 The SD card might not be auto-mounted. The user can use the following command to mount the SD card. <div class="fragment"><div class="line">mknod /dev/mmcblk1p1 <a class="code hl_variableRef" target="_blank" href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a> 179 1  <span class="comment">// If mmcblk device is not created automatically</span></div>
<div class="line">mkdir -p /sdcard</div>
<div class="line">mount -t vfat /dev/mmcblk1p1 /sdcard  <span class="comment">// Assume SD card filesystem is vfat.</span></div>
<div class="ttc" id="acJSON_8h_html_a1a175e87536301df98c805ac0636ad7c"><div class="ttname"><a href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a></div><div class="ttdeci">const cJSON *const b</div></div>
</div><!-- fragment --> Then, perform the upgrade opertations. <div class="fragment"><div class="line">For NAND:</div>
<div class="line"><span class="comment">// upgrade bst</span></div>
<div class="line">board# flash_erase /dev/mtd0 0 0</div>
<div class="line">board# upgrade_partition -p /dev/mtd0 /sdcard/upgrade/bst.bin</div>
<div class="line"><span class="comment">// upgrade bld</span></div>
<div class="line">board# flash_erase /dev/mtd1 0 0</div>
<div class="line">board# upgrade_partition -p -G /dev/mtd1 /sdcard/upgrade/bld.bin</div>
<div class="line"><span class="comment">// upgrade dtb</span></div>
<div class="line">board# upgrade_partition -d /sdcard/upgrade/dtb.bin</div>
<div class="line"><span class="comment">// upgrade kernel</span></div>
<div class="line">board# flash_erase /dev/mtd5 0 0</div>
<div class="line">board# upgrade_partition -p -K /dev/mtd5 /sdcard/upgrade/kernel.bin</div>
<div class="line"><span class="comment">// upgrade rootfs</span></div>
<div class="line">board# flash_erase /dev/mtd6 0 0</div>
<div class="line">board# upgrade_partition -p -R /dev/mtd6 /sdcard/upgrade/rootfs.bin</div>
<div class="line"> </div>
<div class="line">For EMMC:</div>
<div class="line"><span class="comment">// upgrade kernel</span></div>
<div class="line">board# upgrade_partition -p /dev/mmcblk0p6 /sdcard/upgrade/kernel.bin</div>
<div class="line"><span class="comment">// upgrade rootfs</span></div>
<div class="line">board# upgrade_partition -p /dev/mmcblk0p7 /sdcard/upgrade/rootfs.bin</div>
<div class="line"> </div>
<div class="line">board# sync</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd><ul>
<li>If eMMC is used, the user can clean the data first and then upgrade the partition image. <div class="fragment"><div class="line">board# umount /dev/mmcblk0pX</div>
<div class="line">board# dd <span class="keywordflow">if</span>=/dev/zero of=/dev/mmcblk0pX</div>
</div><!-- fragment --></li>
<li>If eMMC boot partition is used as BST partition, the user must get the written permission first and then upgrade it. <div class="fragment"><div class="line">board# echo 0 &gt; /sys/block/mmcblk0boot0/force_ro</div>
<div class="line">board# upgrade_partition -p /dev/mmcblk0boot0 /sdcard/upgrade/bst.bin</div>
</div><!-- fragment --></li>
</ul>
</dd></dl>
</li>
<li>Switch to the main system. <div class="fragment"><div class="line">board# upgrade_partition -S 0</div>
<div class="line">board# sync &amp;&amp; reboot</div>
</div><!-- fragment --></li>
</ol>
<hr  />
<h1><a class="anchor" id="si_partition_auto_recovery"></a>
4. Partition Auto Recovery</h1>
<p >Sometimes, the system on chip (SoC) cannot start normally after the system is upgraded; The reasons for this may include an issue with the upgraded firmware itself or bad blocks appearing in the firmware storage medium, among others. To handle this abnormal situation, the software development kit (SDK) provides an automatic recovery solution. This chapter contains the following sections:</p><ul>
<li>Section <a class="el" href="../../dc/d8f/si_boot_upgrade.html#si_partition_auto_recovery_introduction">4.1 Partition Auto-Recovery Introduction</a></li>
<li>Section <a class="el" href="../../dc/d8f/si_boot_upgrade.html#si_build_recovery_image_example">4.2 Example: Build the Recovery Image</a></li>
<li>Section <a class="el" href="../../dc/d8f/si_boot_upgrade.html#si_partition_auto_recovery_test">4.3 Example: Partition Auto-Recovery Test</a></li>
<li>Section <a class="el" href="../../dc/d8f/si_boot_upgrade.html#si_mcu_communication_protocol_introduction">4.4 MCU Communication Protocol Introduction</a></li>
</ul>
<h2><a class="anchor" id="si_partition_auto_recovery_introduction"></a>
4.1 Partition Auto-Recovery Introduction</h2>
<p >This section introduces the partition auto-recovery mechanism. The recovery mechanism requires the assistance of the microcontroller unit (MCU), because after the system fails to start, the SoC may not be able to pull up the recovery pin to enter recovery mode by itself. After the MCU pulls up the designated recovery pin, the SoC will enter into recovery mode and execute the bootloader stored in the BAK partition to perform the recovery operation.</p>
<div class="image">
<img src="../../partition_auto_recovery_flow.png" alt=""/>
<div class="caption">
Figure 4-1. Partition Auto-Recovery Flow.</div></div>
<p >After the system boots up successfully in one partition, the SoC will send this partition boot success report to the MCU through the universal asynchronous receiver / transmitter (UART), and the MCU will record the partition state. If the MCU does not receive a boot success report within the timeout when the system boots in a certain partition, the MCU restarts the SoC. After restarting N times, if the corresponding boot success report is still not received, the MCU will pull up the recovery pin of the SoC, and then restart the SoC to let the SoC enter recovery mode. After entering recovery mode, the SoC will query the failed partitions from the MCU, and then perform the recovery operation for the corresponding partitions. After the partitions are restored successfully, the SoC notifies the MCU that the recovery was successful. Then, the MCU pulls low the recovery pin and restarts the SoC.</p>
<h3><a class="anchor" id="si_build_recovery_image_example"></a>
4.2 Example: Build the Recovery Image</h3>
<p >The following example describes how to enable the partition auto-recovery function.</p>
<ol type="1">
<li>Enable the recovery function and select the UART interface to communicate between the SoC and the MCU. UART1 is used as an example here.<br  />
 After enabling the recovery function, the BST, BLD, and ATF images will be packed into the BAK image.<br  />
 <dl class="section user"><dt>For CV2x SDK 3.0 Amba build</dt><dd><div class="fragment"><div class="line">build $ make menuconfig</div>
<div class="line">        Ambarella Bootloader Configuration  ---&gt;</div>
<div class="line">          AMBoot Options  ---&gt;</div>
<div class="line">            [*] Build Recovery Firmware Images  ---&gt;</div>
<div class="line">                Recovery Interface (Uart)  ---&gt;</div>
<div class="line">                (1)   Recovery Uart Port</div>
<div class="line">                [ ] Build Compressed Recovery Firmware Images</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>For Cooper Amba build:</dt><dd><div class="fragment"><div class="line">build $ make menuconfig</div>
<div class="line">        [*] boot (boot) ---&gt;</div>
<div class="line">          Bootloader ---&gt;</div>
<div class="line">            Ambarella Bootloader Configuration  ---&gt;</div>
<div class="line">              AMBoot Options  ---&gt;</div>
<div class="line">                [*] Build Recovery Firmware Images  ---&gt;</div>
<div class="line">                  Recovery Interface (Uart)  ---&gt;</div>
<div class="line">                    (1)   Recovery Uart Port</div>
<div class="line">                    [ ] Build Compressed Recovery Firmware Images</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>For Cooper Yocto build:</dt><dd><div class="fragment"><div class="line">build $ make menuconfig</div>
<div class="line">        meta-ambabsp ---&gt;</div>
<div class="line">          recipes-bsp ---&gt;</div>
<div class="line">            [*] boot (meta-ambabsp/recipes-bsp/boot) ---&gt;</div>
<div class="line">              Bootloader ---&gt;</div>
<div class="line">                Ambarella Bootloader Configuration  ---&gt;</div>
<div class="line">                  AMBoot Options  ---&gt;</div>
<div class="line">                    [*] Build Recovery Firmware Images  ---&gt;</div>
<div class="line">                      Recovery Interface (Uart)  ---&gt;</div>
<div class="line">                        (1)   Recovery Uart Port</div>
<div class="line">                        [ ] Build Compressed Recovery Firmware Images</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The <code>[ ] Build Compressed Recovery Firmware Images</code> can be selected to save the size of the BAK partition.</li>
<li>The baudrate used by UART is set to 115200 by default in the BLD.</li>
<li>A simple communication protocol is used between the SoC and the MCU <a class="el" href="../../dc/d8f/si_boot_upgrade.html#si_mcu_communication_protocol_introduction">4.4 Communication Protocol Introduction</a>.</li>
<li>Though BST is packed into the BAK image, if BST is corrupted in current running system, the recovery mechanism will not run. Because the recovery mechanism is based on a working BST.</li>
</ul>
</dd></dl>
</li>
<li>Add the kernel image to the BAK image.<br  />
 <dl class="section user"><dt>For CV2x SDK 3.0 Amba build:</dt><dd><div class="fragment"><div class="line">build $ make menuconfig</div>
<div class="line">        Ambarella Bootloader Configuration  ---&gt;</div>
<div class="line">          Firmware Options  ---&gt;</div>
<div class="line">            Primary Partition  ---&gt;</div>
<div class="line">              [*] Build Kernel to Recovery Image</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>For Cooper SDK Amba build:</dt><dd><div class="fragment"><div class="line">build $ make menuconfig</div>
<div class="line">        [*] boot (boot) ---&gt;</div>
<div class="line">          Bootloader ---&gt;</div>
<div class="line">            Ambarella Bootloader Configuration  ---&gt;</div>
<div class="line">              Firmware Options  ---&gt;</div>
<div class="line">                Primary Partition  ---&gt;</div>
<div class="line">                  [*] Build Kernel to Recovery Image</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>For Cooper SDK Yocto build:</dt><dd><div class="fragment"><div class="line">build $ make menuconfig</div>
<div class="line">        meta-ambabsp ---&gt;</div>
<div class="line">          recipes-bsp ---&gt;</div>
<div class="line">            [*] boot (meta-ambabsp/recipes-bsp/boot) ---&gt;</div>
<div class="line">              Bootloader ---&gt;</div>
<div class="line">                Ambarella Bootloader Configuration  ---&gt;</div>
<div class="line">                  Firmware Options  ---&gt;</div>
<div class="line">                    Primary Partition  ---&gt;</div>
<div class="line">                      [*] Build Kernel to Recovery Image</div>
</div><!-- fragment --></dd></dl>
</li>
<li>Add the fs image to the BAK image.<br  />
 <dl class="section user"><dt>For CV2x SDK 3.0 Amba build:</dt><dd><div class="fragment"><div class="line">build $ make menuconfig</div>
<div class="line">        Ambarella Bootloader Configuration  ---&gt;</div>
<div class="line">          Firmware Options  ---&gt;</div>
<div class="line">            Linux Partition  ---&gt;</div>
<div class="line">              [*] Build Linux FS to Recovery Image</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>For Cooper SDK Amba build:</dt><dd><div class="fragment"><div class="line">build $ make menuconfig</div>
<div class="line">        [*] boot (boot) ---&gt;</div>
<div class="line">          Bootloader ---&gt;</div>
<div class="line">            Ambarella Bootloader Configuration  ---&gt;</div>
<div class="line">              Firmware Options  ---&gt;</div>
<div class="line">                Linux Partition  ---&gt;</div>
<div class="line">                  [*] Build Linux FS to Recovery Image</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>For Cooper SDK Yocto build:</dt><dd><div class="fragment"><div class="line">build $ make menuconfig</div>
<div class="line">        meta-ambabsp ---&gt;</div>
<div class="line">          recipes-bsp ---&gt;</div>
<div class="line">            [*] boot (meta-ambabsp/recipes-bsp/boot) ---&gt;</div>
<div class="line">              Bootloader ---&gt;</div>
<div class="line">                Ambarella Bootloader Configuration  ---&gt;</div>
<div class="line">                  Firmware Options  ---&gt;</div>
<div class="line">                    Linux Partition  ---&gt;</div>
<div class="line">                      [*] Build Linux FS to Recovery Image</div>
</div><!-- fragment --></dd></dl>
</li>
<li>Allocate the BAK partition in <code>ambarella/boards/&lt;board_name&gt;/bsp/bsp.h</code>.<br  />
 The BAK partition must be large enough to accommodate the sum of the images selected above. <div class="fragment"><div class="line"><span class="preprocessor">#define AMBOOT_BAK_SIZE     (250  * 1024 * 1024)</span></div>
</div><!-- fragment --></li>
<li>Configure the recovery pin in <code>ambarella/boards/&lt;board_name&gt;/bsp/xxx.ini</code>.<br  />
 The general purpose input / output (GPIO) 106 is used as an example here. <div class="fragment"><div class="line">&lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span> encoding=<span class="stringliteral">&quot;utf-8&quot;</span>?&gt;</div>
<div class="line">  ......</div>
<div class="line">  &lt;PARAM_RECOVERY_GPIO value=<span class="stringliteral">&quot;106&quot;</span>/&gt;</div>
<div class="line">&lt;/BSTConfig&gt;</div>
</div><!-- fragment --></li>
<li>Configure the UART1 mentioned above, which can be used to report the Linux boot state in the file system.. <div class="fragment"><div class="line">n_ahb@e0000000 {</div>
<div class="line">  ........</div>
<div class="line">  uart1: uart@e00XX000 {</div>
<div class="line">    status = <span class="stringliteral">&quot;ok&quot;</span>;</div>
<div class="line">  };</div>
<div class="line">  ........</div>
<div class="line">};</div>
</div><!-- fragment --></li>
<li>Build and burn the firmware <code>ambarella/out/cvx_board/images/bst_bld_atf_pba_kernel_backup_lnx_release.elf</code> on CV2x SDK 3.0 or <code>ambarella/[amba|yocto]_out/cvx_board/firmware/bst_bld_atf_pba_kernel_backup_lnx_release.elf</code> on Cooper SDK to the board. <div class="fragment"><div class="line">build $ make -j8</div>
</div><!-- fragment --></li>
</ol>
<h3><a class="anchor" id="si_partition_auto_recovery_test"></a>
4.3 Example: Partition Auto-Recovery Test</h3>
<p >This example is tested on an eMMC boot device.</p>
<ol type="1">
<li>Verify the partition after booting up the board.<br  />
 If the boot media is an eMMC device, use the following command to check the specified partition instead of <code>cat /proc/mtd</code>, which is used for the memory technology device (MTD), such as NAND. <div class="fragment"><div class="line"><span class="preprocessor"># cat /proc/device-tree/n_ahb@e0000000/sdmmc0@e0004000/partitions/partition@7/label</span></div>
<div class="line">bak</div>
</div><!-- fragment --></li>
<li>Upgrade the BLD using a corrupted image, or erase the BLD. <div class="fragment"><div class="line">board # upgrade_partition -p -G /dev/mmcblk0p2 /tmp/bld_release.bin (or /tmp/fip.bin in the secure boot.)</div>
</div><!-- fragment --> or <div class="fragment"><div class="line">amboot&gt; erase bld</div>
</div><!-- fragment --></li>
<li>Inform the MCU to restart the SoC through UART1 in the file system or power cycle the whole device.</li>
<li>Wait for the auto recovery operation; the logs from the SoC are as shown below. <div class="image">
<img src="../../partition_auto_recovery_log.png" alt=""/>
<div class="caption">
Figure 4-2. Partition Auto Recovery Log.</div></div>
</li>
<li>After recovery, the SoC will be restarted by the MCU and then boot normally.</li>
</ol>
<h3><a class="anchor" id="si_mcu_communication_protocol_introduction"></a>
4.4 MCU Communication Protocol Introduction</h3>
<p >This communication protocol is used between the SoC and the MCU. Its fields are defined as follows.<br  />
</p>
<div class="image">
<img src="../../mcu_communication_protocol.png" alt=""/>
<div class="caption">
Figure 4-3. Communication Protocol.</div></div>
<dl class="section note"><dt>Note</dt><dd>The protocol implementation can be found under <code>ambarella/amboot/src/bld/recovery</code>. </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
