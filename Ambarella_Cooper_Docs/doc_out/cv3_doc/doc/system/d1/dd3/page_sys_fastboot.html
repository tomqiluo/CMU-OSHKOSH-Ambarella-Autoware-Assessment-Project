<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>System: DESIGN - Fast Boot</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<link rel="search" href="../../search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="System"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-ambarella.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../Ambarella.png"/></td>
  <td id="projectalign">
   <div id="projectname">System<span id="projectnumber">&#160;Cooper_1.6.0 (CV72 &amp; CV3) @ 2024.07.10 14:12:44</span>
   </div>
   <div id="projectbrief">placeholder</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d1/dd3/page_sys_fastboot.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">DESIGN - Fast Boot </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="fastboot_history"></a>
0. Revision History</h1>
<a class="anchor" id="fastboot_rev_history"></a>
<table class="doxtable">
<caption></caption>
<tr>
<th>SDK Version </th><th>Updated Date </th><th>Modification </th></tr>
<tr>
<td>cooper 1.5 </td><td>20231122 </td><td>Added Page Design - Fast Boot </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>The SDK versions listed in the table reflect the current SDK version (x.x) or patch release (x.x.x).<br  />
 A patch number that is not sequential indicates that the previous patch release did not apply to this document.</dd></dl>
<hr  />
<h1><a class="anchor" id="sys_fb_intro"></a>
1. Introduction</h1>
<p >This document describes the fastboot method used to quickly start the system. The following list compares the advantages and disadvantages to these methods.</p><ul>
<li>Cold boot:<br  />
 Fast cold boot is a fastboot option that requires the least amount of modification to the existing system among all two fastboot methods. It retains the normal boot-up mechanism, and accelerates the boot-up process by optimizing boot scripts, utilizing clean boot, and speeding up peripheral loading.</li>
<li>Dynamic random-access memory (DRAM) self-refresh:<br  />
 DRAM self-refresh is a fastboot option that relies on DRAM running in the background. It saves the system context to DRAM on shutdown and restores the system from DRAM on bootup. <br  />
 However, the DRAM self-refresh method requires an external microcontroller unit (MCU) to manage system on chip (SoC) power and DRAM. Further, its standby power additionally includes the DRAM power consumption.</li>
</ul>
<p >The following tables provide the key specifications of each fastboot option: </p><a class="anchor" id="cleanboot_table"></a>
<table class="doxtable">
<caption>Table 1-1. Comparison of Fastboot Methods.</caption>
<tr>
<th align="center"></th><th align="center" width="300px">Cold Boot </th><th align="center" width="300px">DRAM Self-refrsh </th></tr>
<tr>
<th>Resume Timestamp </th><td align="center">Load kernel image: 171 mSec<br  />
 Jump to kernel: 305 mSec<br  />
 Enter Linux: 663 mSec<br  />
 Probe digital signal processor (DSP): 697 mSec<br  />
 Cavalry done: 736 mSec<br  />
 Load firmware: 770 mSec<br  />
 Probe video input (VIN) done: 821 mSec<br  />
 </td><td align="center">Resume from idle: 64 mSec </td></tr>
<tr>
<th>First frame capture </th><td align="center">1050 mSec </td><td align="center">442 mSec </td></tr>
<tr>
<th>Enter encode </th><td align="center">1322 mSec </td><td align="center">624 mSec </td></tr>
<tr>
<th>Note </th><td align="center">With eMMC boot; SD read speed: 73333 KB/s </td><td align="center">An external MCU for power management is required </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Limited driver modules are probed for optimization, as shown below. <div class="fragment"><div class="line">Module                  Size  Used by</div>
<div class="line">os08a10                32768  0</div>
<div class="line">iav                   995328  5 os08a10</div>
<div class="line">cavalry               126976  2</div>
<div class="line">amba_otp               40960  0</div>
<div class="line">dsp                   114688  3 iav</div>
<div class="line">imgproc               307200  1 iav</div>
<div class="line">ambcma                 61440  3 imgproc,dsp,iav</div>
<div class="line">ambnl                 176128  3 imgproc,dsp,iav</div>
<div class="line">hwtimer                20480  3 imgproc,ambnl,iav</div>
</div><!-- fragment --></dd></dl>
<hr  />
<h1><a class="anchor" id="sys_fb_cold_boot"></a>
2. Cold Boot</h1>
<h2><a class="anchor" id="clean_boot_outline"></a>
2.1 Outline</h2>
<p >This guide demonstrates how to cold start the system to record videos as soon as possible by (1) optimizing the system startup script and (2) clipping the system. The system startup time refers to the time from cold startup to the acquisition of the first frame.<br  />
</p><ul>
<li><a class="el" href="../../d1/dd3/page_sys_fastboot.html#clean_boot_script">Section 2.2</a> describes how to prepare the system startup script to load drivers in parallel, which is the most important step and can reduce time by about two seconds<br  />
</li>
<li><a class="el" href="../../d1/dd3/page_sys_fastboot.html#clean_boot_system">Section 2.3</a> describes how to slim the system in order to achieve a faster start-up speed, which can reduce the time by hundreds of milliseconds<br  />
</li>
<li><a class="el" href="../../d1/dd3/page_sys_fastboot.html#clean_boot_others">Section 2.4</a> introduces other hardware-related optimization methods<br  />
</li>
<li><a class="el" href="../../d1/dd3/page_sys_fastboot.html#clean_boot_test">Section 2.5</a> describes how to measure the boot-up time<br  />
</li>
<li><a class="el" href="../../d1/dd3/page_sys_fastboot.html#clean_boot_example">Section 2.6</a> shows an example of running cold boot optimization<br  />
</li>
</ul>
<h2><a class="anchor" id="clean_boot_script"></a>
2.2 System Startup Script Optimization Method</h2>
<h3><a class="anchor" id="script_optimization_parallel"></a>
2.2.1 Load Necessary Module Drivers in Parallel</h3>
<div class="fragment"><div class="line">S10syscfg       S13load-<span class="keyword">private</span>-driver</div>
<div class="line">S11init         rcS</div>
<div class="line">S12udev</div>
</div><!-- fragment --><p >After the system restarts, <code>rcS</code> will be executed. <code>rcS</code> executes the Sxx script to load the module drivers, such as audio, secure digital (SD), USB, udev, network, and more. The system waits until all drivers are loaded. In order for the camera to function normally, only image audio video (IAV), audio, SD, and udev, among other drivers, are required. Therefore, the system must load these drivers when starting. In order to further accelerate the loading process, the parallel loading method (running in the background) can be adopted. First, modify <code>rootfs/system-init/busybox-sysvinit/sysroot/etc/init.d/rcS</code> to execute only one optimization script, as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#!/bin/sh</span></div>
<div class="line">/etc/init.d/S01optinit</div>
<div class="line">exit</div>
</div><!-- fragment --><p >Then, write <code>S01optinit</code> to load the necessary drivers in parallel. Refer to the following: </p><div class="fragment"><div class="line"><span class="preprocessor">#!/bin/sh</span></div>
<div class="line">export PATH=/bin:/sbin:/usr/sbin:/usr/bin:/usr/local/bin</div>
<div class="line">__calc_time() {</div>
<div class="line">timer8_val=`devmem 0xffe4004074`</div>
<div class="line">    let timer8_val=-$timer8_val+0xffffffff</div>
<div class="line">    let t_ms=$timer8_val/156000</div>
<div class="line">    echo <span class="stringliteral">&quot;$1: $t_ms&quot;</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">__probe_vin_os08a10() {</div>
<div class="line">       modprobe os08a10 vinc_id=8</div>
<div class="line">       __calc_time <span class="stringliteral">&quot;Probe VIN Done&quot;</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">__probe_cavalry() {</div>
<div class="line">       modprobe amba_otp &amp;</div>
<div class="line">       modprobe cavalry</div>
<div class="line">       cavalry_load -r</div>
<div class="line">       __calc_time <span class="stringliteral">&quot;Cavalry Done&quot;</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">__calc_time <span class="stringliteral">&quot;/etc/init.d/rcS&quot;</span></div>
<div class="line"> </div>
<div class="line">__load_ucode_fw() {</div>
<div class="line">       load_ucode -f /lib/firmware &gt; /dev/null</div>
<div class="line">       __calc_time <span class="stringliteral">&quot;Load Firmware&quot;</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">__probe_dsp_drv() {</div>
<div class="line">       modprobe ambnl</div>
<div class="line">       modprobe ambcma ama_enable=1</div>
<div class="line">       modprobe imgproc</div>
<div class="line">       modprobe dsp ## ucode_preload=1</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">       __calc_time <span class="stringliteral">&quot;Probe DSP&quot;</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">__probe_iav_vin() {</div>
<div class="line">   modprobe iav</div>
<div class="line">       echo 0x0 &gt; /proc/ambarella/dsp_print &amp;</div>
<div class="line">    echo 0x0 &gt; /proc/ambarella/iav_cmd_print &amp;</div>
<div class="line"> </div>
<div class="line">       __probe_vin_os08a10</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor"># __probe_vin run in background</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">######################################</span></div>
<div class="line"> </div>
<div class="line">__probe_dsp_drv</div>
<div class="line"> </div>
<div class="line">__probe_iav_vin &amp;</div>
<div class="line">__probe_cavalry &amp;</div>
<div class="line">__load_ucode_fw</div>
<div class="line"> </div>
<div class="line">dsp_monitor_service &amp;</div>
<div class="line"> </div>
<div class="line">__calc_time <span class="stringliteral">&quot;Done&quot;</span></div>
</div><!-- fragment --><h3><a class="anchor" id="script_optimization_compile"></a>
2.2.2 Compile Optimized Scripts in the SDK</h3>
<p >For the optimizations described in <a class="el" href="../../d1/dd3/page_sys_fastboot.html#script_optimization_parallel">Section 2.1</a> to take effect at the compilation stage, add the above files to <code>rootfs/system-init/busybox-sysvinit/sysroot/etc/init.d</code> in the software development kit (SDK).<br  />
</p>
<p >Then, check the <code>CONFIG_BUSYBOX_SYSVINIT</code> option in menuconfig, as follows:<br  />
 </p><div class="fragment"><div class="line">build $ make menuconfig</div>
<div class="line">        rootfs ---&gt;</div>
<div class="line">          system-init@<span class="keyword">virtual</span> (rootfs/system-init) (busybox-sysvinit) ---&gt;</div>
</div><!-- fragment --><p><br  />
</p>
<p >After the system boots up, the optimized startup scripts will be under the directory <code>/etc/init.d</code>.<br  />
</p>
<h2><a class="anchor" id="clean_boot_system"></a>
2.3 System Tailoring</h2>
<h3><a class="anchor" id="file_system_size"></a>
2.3.1 Reduce File System Size</h3>
<p >To reduce the size of the root file system (rootfs) image, users can reduce the size of the rootfs partition by removing unwanted packages, pre-builds, third-party software / libraries, unit test applications, and so on.<br  />
 Note that the cutdown should be based on the customer's real use case.<br  />
 After simplification, check the compiled image size in the out directory <code>ls -h images/rootfs.ubifs</code>, then modify the rootfs partition size.<br  />
 The <code>AMBOOT_PARTITION_LAYOUT</code> partition size is defined in the board support package (BSP) / bsp.h: </p><div class="fragment"><div class="line"><span class="preprocessor">#define AMBOOT_PARTITION_LAYOUT \</span></div>
<div class="line"><span class="preprocessor">             MEDIA_DEV \</span></div>
<div class="line"><span class="preprocessor">             &quot;128k(bst),128k(bl2),2048k(fip),896k(dtb),896k(env),128k(cfg),&quot;</span> \</div>
<div class="line">             &quot;32m@0x1300000(kernel),192m(rootfs),-(raw)&quot;</div>
</div><!-- fragment --><h3><a class="anchor" id="kernel_size"></a>
2.3.2 Reduce Linux Kernel Size</h3>
<p >The purpose of streamlining the kernel is to manage modules that are not required in the boot phase. Users can choose not to directly build them into the kernel, but into separated module drivers (change from 'Y' to 'M'). Then, load them dynamically after system boots up. This can reduce the time required to load the kernels. Users can change other file system support to another type other than rootfs (such as network file systems) to dynamically load. It is also possible to pursue a faster startup without compiling other drivers that are not required. Users can refer to <code>ipcam_cleanboot_kernel_emmc_lp4/5_config</code>.</p>
<h3><a class="anchor" id="squashfs_select"></a>
2.3.3 Select SquashFS as Rootfs</h3>
<p >Using SquashFS as the rootfs will further reduce the system boot time, as compared to the Unsorted Block Image File System (UBIFS). In some cases, when using NAND, SquashFS can reduce the time by around 500 ms.</p>
<h3><a class="anchor" id="console_log"></a>
2.3.4 Reduce System Startup Serial Port Printing</h3>
<p >Add the parameter "quiet" to the command line; for example:<br  />
 <code>console=ttyS0 noinitrd root=/dev/mmcblk0p6 rw rootfstype=ext4 rw rootfstype=ext4 rootwait pci=nomsi pcie_aspm=off quiet</code>.<br  />
 This will greatly reduce the time required to print information through the serial port when the system starts.<br  />
 Users can add it in <code>CONFIG_AMBOOT_BD_CMDLINE</code> in menuconfig, as follows:</p>
<p >Or, modify it in <code>bsp/xxx.dts</code>, as follows: </p><div class="fragment"><div class="line"> chosen {</div>
<div class="line"><span class="preprocessor">#if defined(CONFIG_BOOT_MEDIA_SPINOR)</span></div>
<div class="line">    bootargs = <span class="stringliteral">&quot;console=ttyS0 root=/dev/mtdblock5 rw rootfstype=jffs2&quot;</span>;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    bootargs = <span class="stringliteral">&quot;console=ttyS0 noinitrd root=/dev/mmcblk0p6 rw rootfstype=ext4 rw rootfstype=ext4 rootwait pci=nomsi pcie_aspm=off quiet&quot;</span>;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    };</div>
<div class="line">........</div>
</div><!-- fragment --><h2><a class="anchor" id="clean_boot_others"></a>
2.4 Other Optimization Measures</h2>
<h3><a class="anchor" id="others_reduce_delay"></a>
2.4.1 Reduce Delay of Peripheral Driver Loading</h3>
<p >Some peripheral drivers have software delays (calling <code>sleep()</code> or <code>delay()</code>) when loading. For example, the SD card driver can be delayed by hundreds of milliseconds upon power-up, which can be appropriately reduced according to actual requirements and after assessing risks.</p>
<h3><a class="anchor" id="others_increase_i2c_clock"></a>
2.4.2 Increase I2C Clock Frequency</h3>
<p >To increase the speed of I2C communication for some peripherals, such as the sensor, users can also modify the I2C clock frequency (modify <code>ambarella-xxx.dtsi</code>). Currently, the CV72 platform can support up to a 1-MHz clock.</p>
<h3><a class="anchor" id="others_nand_timing"></a>
2.4.3 Adjust NAND Timing</h3>
<p >Adjust NAND timing by modifying <code>bsp/xxx.ini</code>.</p>
<h3><a class="anchor" id="others_emmc_boot"></a>
2.4.4 Adjust eMMC Power-On Configuration as HS200 8-bit Mode</h3>
<p >Adjust the embedded multi-media controller (eMMC) power-on configuration (POC) as HS200 8-bit mode to boot up. Select HS 8-bit mode for the bootloader (BLD) in menuconfig. </p><dl class="section user"><dt>For Cooper SDK Amba Build:</dt><dd><div class="fragment"><div class="line">build $ make menuconfig</div>
<div class="line">        boot ---&gt;</div>
<div class="line">            Ambarella Bootloader Configuration ---&gt;</div>
<div class="line">                Hardware Options ---&gt;</div>
<div class="line">                    [*] Support SD Driver ---&gt;</div>
<div class="line">                        EMMC Bus Mode (HS200) ---&gt;</div>
<div class="line">                        EMMC Bus Width (8) ---&gt;</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>For Cooper SDK Yocto Build:</dt><dd><div class="fragment"><div class="line">build $ make menuconfig</div>
<div class="line">        meta-ambabsp ---&gt;</div>
<div class="line">          recipes-bsp ---&gt;</div>
<div class="line">            amboot (meta-ambabsp/recipes-bsp/boot) ---&gt;</div>
<div class="line">              Ambarella Bootloader Configuration ---&gt;</div>
<div class="line">                  Hardware Options ---&gt;</div>
<div class="line">                    [*] Support SD Driver ---&gt;</div>
<div class="line">                      EMMC Bus Mode (HS200)</div>
<div class="line">                      EMMC Bus Width (8)</div>
</div><!-- fragment --></dd></dl>
<h2><a class="anchor" id="clean_boot_test"></a>
2.5 Testing Process</h2>
<p >Ambarella recommends measuring the time difference between the general purpose input / output (GPIO) pin level flip through the oscilloscope. When the first <code>dsp_encode_irq</code> arrives, a high level is generated through a test pin, and the time difference between it and the reset high level is measured; that is, it measures the accurate time from system start-up to plot.</p>
<h2><a class="anchor" id="clean_boot_example"></a>
2.6 Example</h2>
<div class="fragment"><div class="line">build $ make ipcam_cleanboot_kernel_emmc_lp4/5_config</div>
</div><!-- fragment --><p> On the CV72 evaluation kit (EVK), the boot-up time from system power-up to the first <code>dsp_encode_irq</code> has been measured to be about 1.3 seconds (<code>cortex_clock</code>: 1608 MHz, <code>core_clock</code>: 624 MHz, sensor: OS08A10).</p>
<hr  />
<h1><a class="anchor" id="sys_fb_dram_refresh"></a>
3. DRAM Self-Refresh</h1>
<p >When the DRAM self-refresh feature is enabled, the system operates in low-power mode. During suspension, all hardware (except DRAM) is powered off. This feature is supported in CV72. DRAM self-refresh functions with both the normal boot flow and the secure boot / Arm® TrustZone® flow.</p>
<h2><a class="anchor" id="sys_pm_dram_flow"></a>
3.1 Self-Refresh Workflow</h2>
<h3><a class="anchor" id="sys_pm_dram_resume_flow"></a>
3.1.1 Self-Refresh Resume Workflow</h3>
<p >Starting from the bootstrapper (BST), normal self-refresh and secure self-refresh share many of the same resume-flow components. </p><div class="image">
<img src="../../normal_boot_self_refresh_flow.png" alt=""/>
<div class="caption">
Figure 3-1. Normal Boot DRAM Self-Refresh Resume Workflow for the SoC.</div></div>
<p> For a detailed overview of the secure boot flow, refer to the <em>Ambarella DG Flexible Linux SDK Security Overview</em> document. </p><div class="image">
<img src="../../secure_boot_dram_selrefresh_flow.png" alt=""/>
<div class="caption">
Figure 3-2. Secure Boot DRAM Self-Refresh Resume Workflow for the SoC.</div></div>
<p> The following figure shows the MCU workflow on DRAM self-refresh resume: </p><div class="image">
<img src="../../self_refresh_resume_mcu_workflow.png" alt=""/>
<div class="caption">
Figure 3-3. DRAM Self-Refresh Resume Workflow for the MCU.</div></div>
<h3><a class="anchor" id="sys_pm_dram_suspend_flow"></a>
3.1.2 Self-Refresh Suspend Workflow</h3>
<p >The following figure shows the SoC workflow on DRAM self-refresh suspend: </p><div class="image">
<img src="../../self_refresh_suspend_soc_workflow.png" alt=""/>
<div class="caption">
Figure 3-4. DRAM Self-Refresh Suspend Workflow for the SoC.</div></div>
<p> The following figure shows the MCU workflow on DRAM self-refresh suspend: </p><div class="image">
<img src="../../self_refresh_suspend_mcu_workflow.png" alt=""/>
<div class="caption">
Figure 3-5. DRAM Self-Refresh Suspend Workflow for the MCU.</div></div>
<h2><a class="anchor" id="sys_pm_hw_config"></a>
3.2 Hardware Configuration</h2>
<h3><a class="anchor" id="sys_pm_hw_powctl"></a>
3.2.1 Power Control</h3>
<p >Self-refresh must function with power control (PWC). PWC can be used in two ways:</p><ul>
<li>Internal PWC (not all SoCs include an internal PWC)</li>
<li>External PWC (an external MCU must be used when the SoC does not have an internal PWC)</li>
</ul>
<p >If the board design uses an external MCU for the power sequence control, the SoC must communicate with the MCU through a GPIO.</p>
<p >The protocol is as follows:</p><ul>
<li>The SoC generates a rising signal to notify the MCU that the SoC will enter into self-refresh.</li>
<li>The MCU then notifies the SoC of the state after being powered on:<ul>
<li>If from a cold boot, MCU keeps the GPIO high</li>
<li>If resumed from self-refresh, MCU keeps the GPIO low</li>
</ul>
</li>
</ul>
<p >Different board designs may use different GPIOs. Both the BST and kernel must know which GPIO is used in order to communicate with the external MCU.</p><ul>
<li>For BST, the GPIO is defined in the .ini file by <code>PARAM_SOC_NOTIFY_MCU_GPIO</code>. For more details, users can refer to <a class="el" href="../../d1/dd3/page_sys_fastboot.html#sys_pm_hw_ini">Section 3.2.2 INI File</a> below</li>
</ul>
<h3><a class="anchor" id="sys_pm_hw_ini"></a>
3.2.2 INI File</h3>
<p >In the .ini file, there are two fields related to self-refresh: the <code>PARAM_SOC_NOTIFY_MCU_GPIO</code> value and the <code>PARAM_MCU_NOTIFY_SOC_GPIO</code> value. For different boards, the GPIO setup will be different:</p>
<ol type="1">
<li>For the <b>CV72</b> Gage board: <div class="fragment"><div class="line">&lt;PARAM_SOC_NOTIFY_MCU_GPIO value=<span class="stringliteral">&quot;16&quot;</span>/&gt;</div>
<div class="line">&lt;PARAM_MCU_NOTIFY_SOC_GPIO value=<span class="stringliteral">&quot;15&quot;</span>/&gt;</div>
</div><!-- fragment --></li>
</ol>
<h2><a class="anchor" id="sys_pm_preimg"></a>
3.3 Prepare the Image</h2>
<p >The DRAM self-refresh function is supported on the CV72 board. To enable this function, users must have the corresponding MCU code and the CV72 firmware binary. Before compiling, ensure that the peripheral component interconnect (PCI) and Cadence USB are disabled. </p><div class="fragment"><div class="line">build $ make linux_menuconfig</div>
<div class="line">        Device Drivers ---&gt;</div>
<div class="line">            [ ] PCI support ---</div>
<div class="line">            [*] USB support ---&gt;</div>
<div class="line">                &lt; &gt; Cadence USB Support</div>
</div><!-- fragment --><p >Use the following commands to compile the firmware that supports normal DRAM self-refresh: </p><div class="fragment"><div class="line">build $ make ipcam_lp4/5_srs_config</div>
<div class="line">build $ make</div>
</div><!-- fragment --><h2><a class="anchor" id="sys_pm_run_dram"></a>
3.4 Running DRAM Self-Refresh</h2>
<h3><a class="anchor" id="sys_pm_run_dram_prehw"></a>
3.4.1 Preparing the Hardware</h3>
<p >Users should ensure that the external MCU is flashed with code that supports the DRAM self-refresh functionality. Meanwhile, the power selection jumper should be shorted in order to enable power management from the MCU.<br  />
 For the <b>CV72</b> Gage board, connect the <b>J80</b> pins.</p>
<h3><a class="anchor" id="sys_pm_run_dram_entersr"></a>
3.4.2 Enter Into Self-Refresh</h3>
<p >Power on the system using the [PS-ON] button, and then enter the following commands: </p><div class="fragment"><div class="line">board # init.sh --na</div>
<div class="line">board # modpeobe os08a10 vinc_id=8</div>
<div class="line">board # test_aaa_service -a &amp;</div>
<div class="line">board # test_encode --idle --nopreview</div>
<div class="line">board # echo mem &gt; /sys/power/state</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>DRAM self-refresh does not support resume-from-preview mode; use <code>test_encode</code> to enter preview after resuming from idle mode.</dd></dl>
<p>The sequence of commands listed above is used to perform the suspend operation, in which all device modules will save the current scenario information (with the exception of the information inside the DRAM). This information includes hardware configurations, states, and other scenario- specific information.</p>
<h3><a class="anchor" id="sys_pm_run_dram_resume"></a>
3.4.3 Resume from Self-Refresh</h3>
<p >The resume operation is executed by pressing the <b>MCU PWRON</b> button on the EVK board. This operation restores the hardware registers and states, in addition to recovering the state of the camera.</p>
<hr  />
<h1><a class="anchor" id="fastboot_license"></a>
4. License</h1>
<p >Copyright (c) 2024 Ambarella International LP.</p>
<p >This file and its contents ("Software") are protected by intellectual property rights including, without limitation, U.S. and/or foreign copyrights. This Software is also the confidential and proprietary information of Ambarella International LP and its licensors. You may not use, reproduce, disclose, distribute, modify, or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates. In the absence of such an agreement, you agree to promptly notify and return this Software to Ambarella International LP.</p>
<p >THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
