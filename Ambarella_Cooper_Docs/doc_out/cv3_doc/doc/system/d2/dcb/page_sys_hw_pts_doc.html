<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>System: DESIGN - Timer &amp; PTS</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<link rel="search" href="../../search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="System"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-ambarella.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../Ambarella.png"/></td>
  <td id="projectalign">
   <div id="projectname">System<span id="projectnumber">&#160;Cooper_1.6.0 (CV72 &amp; CV3) @ 2024.07.10 14:12:44</span>
   </div>
   <div id="projectbrief">placeholder</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d2/dcb/page_sys_hw_pts_doc.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">DESIGN - Timer &amp; PTS </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="hw_pts_history"></a>
0. Revision History</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Updated Date   </th><th class="markdownTableHeadLeft">Modification    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">20211021   </td><td class="markdownTableBodyLeft">Initial draft    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">20220613   </td><td class="markdownTableBodyLeft">Update the document to explain in more details    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">20230726   </td><td class="markdownTableBodyLeft">Updated Section 2, added details for sync timer and source    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">20230828   </td><td class="markdownTableBodyLeft">Updated Section 2.3 for sync timer usage   </td></tr>
</table>
<hr  />
<h1><a class="anchor" id="hw_pts_overview"></a>
1. Overview</h1>
<p >In order to synchronize video and audio data for the CV5x platform, a global timer is required to generate video and audio timestamp. The requirements for this global timer are listed as follows:</p><ol type="1">
<li>The global timer should be able to generate a 64-bit timestamp instead of a 32-bit timestamp. A 32-bit timestamp can be wrapped around in a short time. For instance, if the timer jiffies are 1000000, the generated timestamp will be wrapped around after 4295 seconds. However, if the width is 64 bits, the generated timestamp will last long enough to avoid wrap around.</li>
<li>This global timer should be independent enough and cannot be affected by any other sources. Only this can ensure that the generated timestamp is precise enough and then can be used for synchronization between audio and video.</li>
</ol>
<p >Previously, Ambarella adopted the system timer as a reference clock source. Since the system timer ticks can be accessed directly by calling the related API, video and audio applications can directly access it to get the timestamp for any timer. However, this method has the following drawbacks:</p><ol type="1">
<li>The system clock may be synchronized with the NTP time. Thus, the timestamp around the synchronization point can be drifted forward or back. But this cannot ensure that the timestamp is monotonic increasing, which is quite important for the PTS use case.</li>
<li>The system clock cannot be accessed by digital signal processor (DSP). So, the video PTS generation has to be delayed inside the VIN ISR. This will cause frame time-stamping delay depending on the time difference between DSP capturing a frame and ArmÂ® receiving VIN ISR.</li>
</ol>
<p >The solution used in CV5x SDK is listed as follows:</p><ol type="1">
<li>For CV5x, there is a 32-bit global timer (12.288 MHz) which can be accessed both from DSP and Arm side. Both audio and video can use this global timer to generate their timestamps as PTS.</li>
<li>One of the CV5x interval timers (TIMER 4 is used here) is used to check the global timer overflow cases periodically.</li>
<li>Arm generates 64-bit timer ticks based on the 32-bit global timer by incorporating overflow counters, and outputs timestamps with configured output frequencies.</li>
</ol>
<p >The global timer is independent, and not influenced by outer resources. So, there are no timer tick drift cases. The timestamp generated by the global timer is easy to be configured to be 64 bits to make sure no wraparound happens.</p>
<hr  />
<h1><a class="anchor" id="hw_pts_hw"></a>
2. Hardware Timer</h1>
<h2><a class="anchor" id="hw_pts_hw_implementation"></a>
2.1 Implementation</h2>
<p >In CV5x, the global timer is used to be implemented as a hardware timer. This is a 32-bit timer, not enough for 64-bit PTS usage. The frequency for this global timer is 12.288 MHz. So, the 64 bits counter is maintained with this 32-bit tick in the hardware timer driver. The driver is located in <code>"ambarella\drv_modules\private\video\dsp_v6\hw_timer"</code> </p>
<p >In this hardware timer driver, proc file <code>"/proc/ambarella/ambarella_hwtimer"</code> is created. All the applications can read the value from this proc file to get the current timestamp in 64 bits. Normally, Audio PTS is generated in this way. Video PTS is generated inside IAV. Hardware timer driver also provides interface to kernel modules (IAV) so that IAV can get the current timestamp for video directly.</p>
<p >Hardware timer driver supports changing the output frequency dynamically by writing a new output frequency counter into the process file /proc/ambarella/ambarella_hwtimer_outfreq. For example, users can change the output frequency to 1 MHz with the commands <code>"echo 1000000 &gt; /proc/ambarella/ambarella_hwtimer_outfreq"</code>.</p>
<p >It is recommended to keep the default 90 KHz output frequency. However, if a new output frequency is required, the IAV driver should be re-initialized again, so that the IAV driver is aware of the updated output frequency.</p>
<p >The hardware timer driver maintains a global 64-bit counter. The TIMER4 used by the hardware timer driver is used to watch the overflow counters periodically. So the 64-bit counter is listed as follows:<br  />
 <b>Timestamp_input = (Overflow_counter &lt;&lt; 32) + Global_timer_tick</b><br  />
 The output 64 bits timestamp is then generated from the input timestamp. The formula is as follows:<br  />
 <b>Timestamp_output = (Timestamp_input * OUT_FREQ + INP_FREQ / 2) / INP_FREQ</b><br  />
 <b>OUT_FREQ</b> and <b>INP_FREQ</b> are output frequency and input frequency respectively. The input frequency is fixed with 12288000.</p>
<h2><a class="anchor" id="hw_pts_timer_sync"></a>
2.2 Sychronized with System Timer</h2>
<p >For some use cases, hardware timer needs to be in sync with the global system timer. This is because some modules may need to use the system timer as the clock source. So when the events from these modules need to be synchronized with the video or audio presentation time stamp (PTS), users can configure the hardware timer to be in sync with system timer. Then the PTS from them would be in the same clock domain, and can be considered from the same clock source.</p>
<p >Firstly, the hardware timer must be in the same frequency as the system timer. It would be configured with 1 MHz, which means value 1 tick indicating 1/1000000 second. Secondly, the initial timer value should be initialized as the current system timer tick, to make sure that hardware timer and system timer start at the same time. Lastly, it is also needed to adjust the hardware timer values in a fixed frequency, according to the system timer ticks. The synchronization frequency is currently set once per second, to make sure the hardware timer is not drifted too much.</p>
<p >For the system timer source, Linux supports various sorts for different purposes. Currently, hardware timer can choose from the system timer sources below: (1) <b>CLOCK_MONOTONIC</b>: The system timer increases monotonically, but may be adjusted by adjtime and network time protocol (NTP). This matches user space API clock_gettime(<b>CLOCK_MONOTONIC</b>, xxx). (2) <b>CLOCK_MONOTONIC_RAW</b>: The system timer increases monotonically. It won'd be affected by adjtime or NTP. This is used as the default system clock source, when adjusting hardware timer. This matches user space API clock_gettime(<b>CLOCK_MONOTONIC_RAW</b>, xxx). (3) <b>CLOCK_REALTIME</b>: The realtime system clock, may be ajdusted by adjtime and NTP. This matches user space API clock_gettime(<b>CLOCK_REALTIME</b>, xxx). (4) <b>CLOCK_BOOTTIME</b>: It is similar as CLOCK_MONOTONIC. The difference is that CLOCK_BOOTTIME still counts time when system is suspended, while CLOCK_MONOTONIC doesn't. This matches user space API clock_gettime(<b>CLOCK_BOOTTIME</b>, xxx).</p>
<p >When the hardware timer is configured to synchronize with the system timer, the 64-bit video PTS can be directly used to compare with other system event timestamps captured from user space clock APIs mentioned above. For more details of the example about how to use hardware timer tick and user space clock API, please refer to the unit test <code>test_hwtimer</code>, which is located at ambarella\unit_test\private\iav_test\dsp_v6.</p>
<h2><a class="anchor" id="hw_pts_hw_usage"></a>
2.3 Usage</h2>
<p >Hardware timer module is located in ambarella\kernel\private\drivers. To enable this module to compile, enable <code>"Build Ambarella private hw_timer module"</code> in <code>menuconfig</code> as shown below: </p><div class="fragment"><div class="line">build $ make menuconfig</div>
<div class="line">    [*] Ambarella Linux Configuration ---&gt;</div>
<div class="line">      [*] Ambarella Private Drivers Configuration ---&gt;</div>
<div class="line">        [*] Build Ambarella <span class="keyword">private</span> hw_timer module</div>
</div><!-- fragment --><p> When hardware timer module is compiled, users can find two process files: <code>"/proc/ambarella/ambarella_hwtimer"</code> and <code>"/proc/ambarella/ambarella_hwtimer_outfreq"</code>. Users can open <code>"/proc/ambarella/ambarella_hwtimer"</code> and read the current 64-bit timestamp. <code>"/proc/ambarella/ambarella_hwtimer_outfreq"</code> stores the current hardware timer output frequency. Users can write values to it through <code>"echo value &gt; /proc/ambarella/ambarella_hwtimer_outfreq"</code>.</p>
<p >Example to configure the hardware timer output frequency to be 90 KHz. </p><div class="fragment"><div class="line"><span class="preprocessor">#echo 90000 &gt; /proc/ambarella/ambarella_hwtimer_outfreq</span></div>
</div><!-- fragment --><p >Example to write the initial 64-bit timestamps, when the system is booted. </p><div class="fragment"><div class="line"><span class="preprocessor">#echo 0 &gt; /proc/ambarella/ambarella_hwtimer</span></div>
</div><!-- fragment --><p >Example to read the current 64-bit timestamps. </p><div class="fragment"><div class="line"><span class="preprocessor">#cat /proc/ambarella/ambarella_hwtimer</span></div>
</div><!-- fragment --><p >There is a parameter "sync_timer" for hardware timer module, which is used as the flag to enable synchronization with system timer. Users can add below line into /etc/modprobe.d/ambarella.conf to enable the synchronization. </p><div class="fragment"><div class="line">options hw_timer sync_timer=1</div>
</div><!-- fragment --><p> Example to check whether sync_timer is enabled, after system boots up. </p><div class="fragment"><div class="line"><span class="preprocessor">#cat /proc/ambarella/ambarella_hwtimer_sync_timer</span></div>
</div><!-- fragment --><p >There is another parameter "timer_src" for hardware timer module, which is used as the option to select the timer source for system timer synchronization. This option must be used, when "sync_timer" is enabled. The values for the sync sources are as follows: 0 -&gt; CLOCK_MONOTONIC_RAW; 1 -&gt; CLOCK_MONOTONIC; 2 -&gt; CLOCK_REALTIME; 3 -&gt; CLOCK_BOOTTIME. Users can add the line below into /etc/modprobe.d/ambarella.conf to configure sync source to be SYNC_CLOCK_MONOTONIC. </p><div class="fragment"><div class="line">options hw_timer sync_timer=1 timer_src=1</div>
</div><!-- fragment --><p> Example to check the current system timer sync source, after system boot up. </p><div class="fragment"><div class="line"><span class="preprocessor">#cat /proc/ambarella/ambarella_hwtimer_sync_src</span></div>
</div><!-- fragment --><p >The parameter "sync_interval" is added for hardware timer module to configure the synchronization interval in milliseconds (ms). The default value is 1000, meaning to synchronize hardware timer and system timer every second. Users can add the line below into /etc/modprobe.d/ambarella.conf to configure sync source to be SYNC_CLOCK_MONOTONIC with synchronization interval 100 ms. </p><div class="fragment"><div class="line">options hw_timer sync_timer=1 timer_src=1 sync_interval=100</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="hw_pts_clock_source"></a>
3. Clock Sources</h1>
<p >There are possible three clock sources, which are used as PTS sources.</p>
<p >The first one is the I2S clock (audio clock) source from the global timer, with 12.288 MHz frequency. It is normally for the PTS information reported from DSP, because DSP can only access this timer. The global timer is started once DSP is booted, and the ticks and the frequency can't be configured.</p>
<p >The second one is the clock source from hardware timer. This clock is commonly used by user applications to synchronize different events, such as video frame PTS, audio sample PTS, and potentially others. The frequency is by default 90 KHz, and it is configurable for other values, such as 1 MHz.</p>
<p >The third one is from DSP software, and it is used to generate software PTS. The software PTS is increased from 0, and with fixed PTS interval. The frequency for this is 90 KHz. So if the frame rate is 30, the software PTS will be in the sequence of 0/3000/6000/9000/... The PTS will be reset to 0 for each time DSP is switched into preview state.</p>
<hr  />
<h1><a class="anchor" id="hw_pts_audio"></a>
4. Audio PTS</h1>
<h2><a class="anchor" id="hw_pts_audio_implementation"></a>
4.1 Implementation</h2>
<p >Audio PTS is generated in user space applications. It can be generated directly by reading the proc file <code>"/proc/ambaella/ambarella_hwtimer"</code>.</p>
<p >Once an audio packet needs an audio PTS, the only thing the application needs to do is to read the procs file. It is requested to stamp the audio PTS, when the audio sample is captured from the audio capture device. If the audio PTS is stamped after some processing, then there will be potential sychronization issues, such as audio / video synchronization issue.</p>
<hr  />
<h1><a class="anchor" id="hw_pts_video"></a>
5. Video PTS</h1>
<h2><a class="anchor" id="hw_pts_video_implementation"></a>
5.1 Implementation</h2>
<p >Video PTS generation is more complicated when compared to Audio PTS.</p>
<p >The video time-stamping operation is implemented inside DSP. This is the exact accurate timing generating timestamp that is generated when a full frame is captured. The presentation time stamp (PTS) has the same meaning as the capture time stamp. If the time-stamping operation is done on the Arm side, the time-stamping moment is delayed and inaccurate.</p>
<p >The PTS sent by DSP is generated from the global timer, with I2S clock 12.288 MHz. The hardware time driver will translate this PTS to the hardware timer PTS.</p>
<p >When DSP finishes encoding a frame of a stream, it will generate an encode interrupt to IAV. There will be several frames delay when one frame is encoded after this frame is captured. This is called encode pipeline delay here. Before issuing the encode interrupt, DSP will put the frame information to the frame information buffer shared between the DSP and IAV. IAV will get the DSP PTS (generated by the global timer) from the frame information buffer, and generate the hardware PTS based on the DSP PTS. Since the DSP PTS is just a few frames before the current global timer tick, the hardware PTS will be generated based on this information to avoid confusion for overflow cases.</p>
<h2><a class="anchor" id="pts_in_each_idsp_vdsp_domain"></a>
5.2 PTS for Output Data in Each Stage</h2>
<div class="image">
<img src="../../hw_timer_pts_in_each_idsp_domain.png" alt=""/>
<div class="caption">
PTS in Each IDSP/VDSP Domain</div></div>
<p> The image above shows the PTS for each output data in IDSP/VDSP stage.</p>
<p >The timing to stamp the PTS value is when the video frame is captured by DSP. In this way, the PTS for the frame data at different stages can be sychronized. Users can use the PTS value to know whether the frame information from different stages are from the same captured frame, and they can also know the capture time difference for the 2 frame data in different stages.</p>
<h2><a class="anchor" id="PTS_clock_source"></a>
5.3 PTS Clock Sources</h2>
<p >As <a class="el" href="../../d2/dcb/page_sys_hw_pts_doc.html#hw_pts_overview">Overview</a> and Hardware Timer described, the clock source of hardware PTS is audio clock, and the frequency of which is 12.288 MHz. However, the typical application domain frequency is 90 KHz, so Ambarella introduces software PTS, which is 90 KHz based.</p>
<h2><a class="anchor" id="different_PTS_categories"></a>
5.4 Different PTS Categories</h2>
<p >The table below shows the basic information of hardware PTS, software PTS, and monotonic PTS. these three types of PTS are all attached by IDSP/VDSP or Arm.<br  />
 In theory, the PTS value will be increased frame by frame, and the difference of PTS per frame is "The frequency of clock base / fps". </p><table class="doxtable">
<caption>Clock Souce of Different PTS</caption>
<tr>
<th>PTS variable</th><th>Bits</th><th>Clock Source</th><th>Calculation Method </th></tr>
<tr>
<td>hw_pts</td><td>32</td><td>Global Timer</td><td>Global Timer Ticks used by DSP, in 12.288 MHz </td></tr>
<tr>
<td>sw_pts</td><td>32</td><td>Software</td><td>Start from 0, adding fixed delta in 90 KHz for each frame. </td></tr>
<tr>
<td>mono_pts/arm_pts</td><td>64</td><td>Hardware Timer</td><td>Sychnorized with hardware timer, default 90 KHz </td></tr>
</table>
<p >In this section, Ambarella enumerates the PTS categories in each stages and lists tables below.<br  />
 (1) RAW &amp; IDSP<br  />
 </p><table class="doxtable">
<caption>RAW &amp; IDSP Stage PTS Varibles</caption>
<tr>
<th>PTS variable</th><th>Bits</th><th>Clock Source</th><th>Description </th></tr>
<tr>
<td>hw_pts</td><td>32</td><td>Global Timer</td><td>Raw/3A global timer PTS stamped by DSP </td></tr>
<tr>
<td>sw_pts</td><td>32</td><td>Software</td><td>Raw/3A software PTS stamped by DSP </td></tr>
<tr>
<td>mono_pts</td><td>64</td><td>Hardware Timer</td><td>Raw/3A monotonic PTS stamped by hardware timer </td></tr>
</table>
<p>(2) Canvas/Pyramid, YUV/me0/me1<br  />
 For "dsp_pts", users can specify the clock source of it according the flag "is_dsp_hw_pts" in user space. </p><table class="doxtable">
<caption>YUV Stage PTS Varibles</caption>
<tr>
<th>PTS variable</th><th>Bits</th><th>Clock Source</th><th>Description </th></tr>
<tr>
<td>hw_pts</td><td>32</td><td>Global Timer Clock</td><td>Raw/3A global timer PTS stamped by DSP </td></tr>
<tr>
<td>sw_pts</td><td>32</td><td>Software</td><td>Raw/3A software PTS stamped by DSP </td></tr>
<tr>
<td>mono_pts</td><td>64</td><td>Hardware Timer</td><td>Raw/3A monotonic PTS stamped by hardware timer </td></tr>
<tr>
<td>dsp_pts</td><td>32</td><td>Global Timer or Software&lt;</td><td>DSP sw_pts or hw_pts, decided by "is_dsp_hw_pts" </td></tr>
</table>
<p>(3) VDSP<br  />
 </p><table class="doxtable">
<caption>VDSP Stage PTS Varibles</caption>
<tr>
<th>PTS variable</th><th>Bits</th><th>Clock Source</th><th>Description </th></tr>
<tr>
<td>arm_pts</td><td>64</td><td>Hardware Timer</td><td>Raw capture done monotonic PTS stamped by Arm </td></tr>
<tr>
<td>enc_done_pts</td><td>64</td><td>Hardware Timer</td><td>Frame bitstream output monotonic PTS stamped by Arm </td></tr>
<tr>
<td>dsp_pts</td><td>64</td><td>Global Timer &amp; Software</td><td>Low 32 bit with sw_pts, high 32 bit with hw_pts </td></tr>
</table>
<h2><a class="anchor" id="PTS_for_different_sychronization_scenarios"></a>
5.5 PTS for Different Sychronization Scenarios</h2>
<p >Users can take different PTS for different stages and use them for different purposes, such as:<br  />
 (1) <a class="elRef" target="_blank" href="../../../video/d5/d14/fs_basic_codec.html#codec_fsync">Frame Sync</a> and Stream Sync<br  />
 For these user cases, both hardware PTS and software PTS can be used for synchronization.<br  />
 (2) Audio video sync<br  />
 Audio's PTS is obtained from hardware timer, which is the same clock base as video monotonic PTS. Hence, users can do audio and video synchronization combine either hardware PTS or monotonic PTS.</p>
<p >If user application would like to do synchronizations between Arm and DSP, then users may need to choose from hardware PTS (hw_pts) or software PTS (sw_pts). For example, synchronize warp related operations to the specified frame, or synchronize encoder related operations to the specified frames.</p>
<p >If user application needs to synchronize different sources at Arm side, then users may need to use the 64 bit monotonic Arm PTS (arm_pts or mono_pts). For example, synchronization between audio and video data, or synchronization between video and other sources (gyro data, ...)</p>
<hr  />
<h1><a class="anchor" id="hw_pts_use_scenario"></a>
6. Use Scenarios for PTS</h1>
<h2><a class="anchor" id="hw_pts_av_sync"></a>
6.1 Audio and Video Synchronization</h2>
<p >For audio, user applicaion should get the hardware time ticks, as soon as the audio samples is captured from audio capture device. For video, when user application calls IOCTL to query frame data, users will get the actual PTS from arm_pts in the struct <a class="elRef" target="_blank" href="../../../library/d9/d2b/structiav__framedesc.html">iav_framedesc</a>. This PTS is also stamped when the video RAW frame is captured by DSP. As long as the timing for both audio PTS and video PTS happens when the data is captured done, these audio samples and video frames can be automatically sychronized using the capture PTS.</p>
<h2><a class="anchor" id="hw_pts_frame_sync"></a>
6.2 Frame Synchronization Mechanism</h2>
<p >The typical working flow for frame synchronization mechanism is described below.</p><ol type="1">
<li>User application queries the canvas frame data, through IOCTL IAV_IOC_QUERY_DESC with IDSP IAV_DESC_CANVAS. In the struct <a class="elRef" target="_blank" href="../../../library/dc/d6a/structiav__yuv__cap.html">iav_yuv_cap</a>, there is dsp_pts used to synchronize with DSP.</li>
<li>User application does some analysis based on the canvas YUV data, and calculates some encode parameters for this dedicated frame.</li>
<li>User issues these encode parameter to IAV/DSP, through IOCTL IAV_IOC_APPLY_FRAME_SYNC_PROC. In the struct <a class="elRef" target="_blank" href="../../../library/d2/dde/structiav__apply__frame__sync.html">iav_apply_frame_sync</a>, there is also dsp_pts field, which needs to match the dsp_pts in the canvas YUV data. When this is matched, the encode parameters will be applied to this dedicated frame, when it goes into encoder. For this frame synchronization feature, the dsp_pts is actually software PTS (sw_pts described above), so the parameter is_dsp_hw_pts in struct <a class="elRef" target="_blank" href="../../../library/d5/dfb/structiav__canvasdesc.html">iav_canvasdesc</a> must be disabled in this case, when querying canvas YUV data. This PTS is from DSP, and also applied to DSP when performing frame synchronization.</li>
</ol>
<hr  />
<h1><a class="anchor" id="hw_pts_encode"></a>
7. Stream Encode Done PTS</h1>
<h2><a class="anchor" id="hw_pts_encode_info"></a>
7.1 Information</h2>
<p >The stream encode done time-stamping operation is implemented inside IAV driver. This is the timing when IAV driver gets the VDSP interrupt, and has collected the full frame data from VDSP. IAV driver will call hardware timer driver to get current ticker immediately when the full frame data are collected.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_structRef" target="_blank" href="../../../library/d9/d2b/structiav__framedesc.html">iav_framedesc</a> {</div>
<div class="line">     <a class="code hl_typedefRef" target="_blank" href="../../../driver/d0/dfa/group__iav-typedef.html#ga10e94b422ef0c20dcdec20d31a1f5049">u32</a> <a class="code hl_variableRef" target="_blank" href="../../../library/d9/d2b/structiav__framedesc.html#a76f8ba65ce8f902c0657233adee58698">id</a>;</div>
<div class="line">     <a class="code hl_typedefRef" target="_blank" href="../../../driver/d0/dfa/group__iav-typedef.html#ga10e94b422ef0c20dcdec20d31a1f5049">u32</a> <a class="code hl_variableRef" target="_blank" href="../../../library/d9/d2b/structiav__framedesc.html#a13f15ff96937a3c8c6c05f6a1c010843">time_ms</a>;</div>
<div class="line">     ............</div>
<div class="line">     <a class="code hl_typedefRef" target="_blank" href="../../../driver/d0/dfa/group__iav-typedef.html#gad758b7a5c3f18ed79d2fcd23d9f16357">u64</a> <a class="code hl_variableRef" target="_blank" href="../../../library/d9/d2b/structiav__framedesc.html#a6fcb833e69f93194b065f17833611869">enc_done_ts</a>;</div>
<div class="line">     ............</div>
<div class="line">};</div>
<div class="ttc" id="agroup__iav-typedef_html_ga10e94b422ef0c20dcdec20d31a1f5049"><div class="ttname"><a href="../../../driver/d0/dfa/group__iav-typedef.html#ga10e94b422ef0c20dcdec20d31a1f5049">u32</a></div><div class="ttdeci">unsigned int u32</div></div>
<div class="ttc" id="agroup__iav-typedef_html_gad758b7a5c3f18ed79d2fcd23d9f16357"><div class="ttname"><a href="../../../driver/d0/dfa/group__iav-typedef.html#gad758b7a5c3f18ed79d2fcd23d9f16357">u64</a></div><div class="ttdeci">unsigned long long u64</div></div>
<div class="ttc" id="astructiav__framedesc_html"><div class="ttname"><a href="../../../library/d9/d2b/structiav__framedesc.html">iav_framedesc</a></div></div>
<div class="ttc" id="astructiav__framedesc_html_a13f15ff96937a3c8c6c05f6a1c010843"><div class="ttname"><a href="../../../library/d9/d2b/structiav__framedesc.html#a13f15ff96937a3c8c6c05f6a1c010843">iav_framedesc::time_ms</a></div><div class="ttdeci">u32 time_ms</div></div>
<div class="ttc" id="astructiav__framedesc_html_a6fcb833e69f93194b065f17833611869"><div class="ttname"><a href="../../../library/d9/d2b/structiav__framedesc.html#a6fcb833e69f93194b065f17833611869">iav_framedesc::enc_done_ts</a></div><div class="ttdeci">u64 enc_done_ts</div></div>
<div class="ttc" id="astructiav__framedesc_html_a76f8ba65ce8f902c0657233adee58698"><div class="ttname"><a href="../../../library/d9/d2b/structiav__framedesc.html#a76f8ba65ce8f902c0657233adee58698">iav_framedesc::id</a></div><div class="ttdeci">u32 id</div></div>
</div><!-- fragment --><h2><a class="anchor" id="hw_pts_encode_usage"></a>
7.2 Usage</h2>
<p >The encode done PTS describes the timing when Arm receives the endoded frame data. By comparing this PTS with the RAW capture done PTS (mono_pts or arm_pts), users can understand the pipeline latency between RAW capture done and encode done, which includes the time of IDSP processing time as well as VDSP encoding time.</p>
<p >The encode done PTS is NOT suggested to be used as the actual PTS, which may be used to sychronize with other events, such as audio. The reasons are listed as follows:</p><ol type="1">
<li>The time stamp timing must be deterministic. The encode done timing is not deterministic, because it may be affected by the IDSP procession latency as well as the encode latency.</li>
<li>The time stamp timing must be stable. When stamping at Arm side, it may be affected by the DSP interrupt timing as well as the system loading. The timing may be fluctuated from time to time. And it may also be affected by different number of encode streams, because there is only one set of VDSP hardware to encode all the streams, and the frames from these streams must be encoded sequentially.</li>
<li>The frame encoding order may be different from frame capture order. When B frames are enabled, the PTS will not be in ascending order. So it is not applicable to use encode done timing as the PTS.</li>
</ol>
<hr  />
<h1><a class="anchor" id="hw_pts_license"></a>
8. License</h1>
<p >Copyright (c) 2024 Ambarella International LP</p>
<p >This file and its contents ( "Software" ) are protected by intellectual property rights including, without limitation, U.S. and/or foreign copyrights. This Software is also the confidential and proprietary information of Ambarella International LP and its licensors. You may not use, reproduce, disclose, distribute, modify, or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates. In the absence of such an agreement, you agree to promptly notify and return this Software to Ambarella International LP</p>
<p >THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
