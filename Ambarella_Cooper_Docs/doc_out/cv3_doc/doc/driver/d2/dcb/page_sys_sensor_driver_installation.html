<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Driver: Sensor &amp; SERDES Driver Installation</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<link rel="search" href="../../search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Driver"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-ambarella.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../Ambarella.png"/></td>
  <td id="projectalign">
   <div id="projectname">Driver<span id="projectnumber">&#160;Cooper_1.6.0 (CV72 &amp; CV3) @ 2024.07.10 14:12:44</span>
   </div>
   <div id="projectbrief">placeholder</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d2/dcb/page_sys_sensor_driver_installation.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Sensor &amp; SERDES Driver Installation </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Sensor_driver_installation_history"></a>
0. Revision History</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Library Version   </th><th class="markdownTableHeadLeft">Updated Date   </th><th class="markdownTableHeadLeft">Modification    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">1.0.0   </td><td class="markdownTableBodyLeft">20220110   </td><td class="markdownTableBodyLeft">Initial Version    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">1.0.1   </td><td class="markdownTableBodyLeft">20220119   </td><td class="markdownTableBodyLeft">Added sensor driver installation related chapters    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">1.0.2   </td><td class="markdownTableBodyLeft">20220328   </td><td class="markdownTableBodyLeft">Added Section <a class="el" href="../../d2/dcb/page_sys_sensor_driver_installation.html#CV52_Multi_VIN_Design">4.2 CV52 Multi-VIN Design</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">1.0.3   </td><td class="markdownTableBodyLeft">20220726   </td><td class="markdownTableBodyLeft">Correct Sensor &amp; SERDES driver installation error description    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">1.0.4   </td><td class="markdownTableBodyLeft">20230130   </td><td class="markdownTableBodyLeft">Added Section <a class="el" href="../../d2/dcb/page_sys_sensor_driver_installation.html#ambds_usage">3.1 Dummy Sensor Driver Usage</a>   </td></tr>
</table>
<hr  />
<h1><a class="anchor" id="sensor_driver_module_parameters"></a>
1. Sensor Driver Module Parameters</h1>
<p >Sensor driver module parameters table: <a class="el" href="../../d4/d64/page_drv_sensor.html#sensor_parm_table">2. Sensor Module Parameters Table</a>.</p>
<hr  />
<h1><a class="anchor" id="serdes_driver_module_parameters"></a>
2. SERDES Driver Module Parameters</h1>
<p >Bridge sensor parameters table: <a class="el" href="../../d4/d64/page_drv_sensor.html#brg_sensor_parm_table">3. Bridge Sensor Parameters Table</a>.</p>
<hr  />
<h1><a class="anchor" id="driver_installation_guide"></a>
3. Driver Installation Guide</h1>
<h2><a class="anchor" id="ambds_usage"></a>
3.1 Dummy Sensor Driver Usage</h2>
<p >In some special cases, a dummy sensor is needed to configure the video input (VIN), and thus enable the whole digital signal processor (DSP) pipeline.<br  />
 </p><div class="image">
<img src="../../dummy_sensor_driver_data_flow_overview.jpg" alt=""/>
<div class="caption">
Figure 3-1. Sensor Data Playback Flow for Dummy Sensor Driver.</div></div>
<p> The user can choose either of the two available dummy sensor drivers in SDK according to whether the serializer / deserializer (SERDES) is used:</p><ul>
<li><b>Dummy Sensor Driver</b><br  />
 This driver can support both YUV or RAW input which does not need real configurations. It provides 1080p, 720p, and 4K resolutions by default. If the other resolution is used, the user can load this dummy driver with the video format parameters to specify the resolution.<br  />
 There are two main use cases for this driver:<br  />
<ul>
<li>Virtual VIN mode used by the encode from RAW (EFR).<br  />
 The dummy sensor driver is <code>ambds</code> and the VIN PHY will not be initialized in this mode. For more usages, the user can refer to <a class="elRef" target="_blank" href="../../../video/d3/dff/fs_adv_efr.html#efr_exp">EFR Examples</a>.</li>
<li><p class="startli">Input RAW data through MIPI® interface to VIN PHY.<br  />
 To receive the RAW data through the MIPI / LVCOMS interface, the VIN PHY must be initialized in the dummy sensor driver <code>ambds</code>. The following examples show how the dummy driver is used for such a use case:<br  />
 <b>Example 1:</b> Below is an example on how the sensor raw data flow is handled by the dummy sensor drivers. For the dummy sensor driver part, if the input data is "IMX274 MIPI format (1280x960 10bits at 54fps)", the user can use the following commands to load the dummy driver: </p><div class="fragment"><div class="line">board# init.sh --na; modprobe ambds mipi=1 vinc_id=8 yuv_mode=0 yuv_pix_order=0 lane=4 w=1208 h=960 <a class="code hl_variableRef" target="_blank" href="../../../video/d4/daa/vin__init_8c.html#ad1e28a1a66a25529b0b61b9ca4e66d44">bits</a>=10 fps=9481481 sensor_id=0x3014</div>
<div class="line">board# test_aaa_service -a&amp;</div>
<div class="line">board# test_encode --resource-cfg vin0_1280x960_10bits_linear.lua --vout-cfg vout_hdmi.lua</div>
<div class="ttc" id="avin__init_8c_html_ad1e28a1a66a25529b0b61b9ca4e66d44"><div class="ttname"><a href="../../../video/d4/daa/vin__init_8c.html#ad1e28a1a66a25529b0b61b9ca4e66d44">bits</a></div><div class="ttdeci">int bits</div></div>
</div><!-- fragment --> <div class="image">
<img src="../../dummy_sensor_driver_usage_example.jpg" alt=""/>
<div class="caption">
Figure 3-2. Dummy Sensor Driver Usage Example.</div></div>
<p class="startli"><b>Example 2:</b> Below is a brief example on a 4-lane MIPI YUV input dummy sensor. </p><div class="fragment"><div class="line">board# modprobe ambds yuv_mode=1 mipi=1 lane=4 vinc_id=0</div>
</div><!-- fragment --><p class="startli"><b>Example 3:</b> VOUT Example 28 is an example of how to enable the VIN of the board-2 via the ambds driver. In this example, the "sensor" is a 4-lane MIPI YUV input module.<br  />
</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>VIN mode must be set to 0 (auto mode) in the lua script when the dummy driver is loaded with parameters <code>w</code> and <code>h</code> both specified.</li>
<li>The <code>w</code> and <code>h</code> are the width and height of the customized mode input.</li>
<li>The <code>lane</code> is the MIPI lane number.</li>
<li>The <code>sensor_id</code> is the sensor unique identifier. The unique identifier for IMX274 is 0x3014.</li>
<li>The <code>yuv_mode</code> is the VIN input data format, the <code>yuv_mode=0</code> indicates that it is a RGB data input.</li>
<li>For non-YUV input, the <code>yuv_pix_order</code> must be set to 0.</li>
<li>The module parameter <code>fps</code> is calculated by ( 512000000 / actual fps ). For 54 fps, it’s 512000000 / 54 = 9481481.</li>
<li>If multiple resolutions for dummy sensor driver are required, the user can modify the dummy sensor driver and add these resolutions into the video format table accordingly in <code>ambds_table.c</code></li>
<li>Other driver parameters can be found in <a class="el" href="../../d4/d64/page_drv_sensor.html#sensor_parm_table">Sensor Module Parameters Table</a></li>
</ul>
</dd></dl>
</li>
</ul>
</li>
<li><b>Dummy Sensor Driver for Bridge</b><br  />
 This driver is used with SERDES case together. The interface can be MIPI or LVCMOS for serializer to receive. It can support both YUV or RAW input which does not need real configurations.<br  />
 For example, if ds90ub954 bridge is used and the input data is "IMX274 MIPI format (1280x960 10bits at 54fps)", the user can also refer to the <b>Example 1</b> above for the dummy sensor driver for bridge part and use the following commands to load this dummy driver: <div class="fragment"><div class="line">board# modprobe ds90ub954 <span class="keywordtype">id</span>=0x1 vinc_id=8 mode=0</div>
<div class="line">board# modprobe ambds_brg mipi=1 yuv_mode=0 yuv_pix_order=0 lane=4 w=1280 h=960 <a class="code hl_variableRef" target="_blank" href="../../../video/d4/daa/vin__init_8c.html#ad1e28a1a66a25529b0b61b9ca4e66d44">bits</a>=10 fps=9481481 sensor_id=0x3014</div>
<div class="line">board# test_aaa_service -a&amp;</div>
<div class="line">board# test_encode --resource-cfg vin0_1280x960_10bits_linear.lua --vout-cfg vout_hdmi.lua</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd><ul>
<li>Some parameters' descriptions can be found in the section's note above.</li>
<li>Other driver parameters can be found in <a class="el" href="../../d4/d64/page_drv_sensor.html#brg_sensor_parm_table">Bridge Sensor Parameters Table</a></li>
</ul>
</dd></dl>
</li>
</ul>
<h2><a class="anchor" id="Multiple_Sensors_with_Different_Sensor_Types"></a>
3.2 Multiple Sensors with Different Sensor Types</h2>
<p >In this case, multiple sensor drivers are installed for the VIN controllers so that each sensor gets its own sensor driver. While installing each sensor driver, users must specify the VIN controller ID and I2C bus ID using the sensor driver module parameters "vinc_id" and "bus_id".<br  />
 Using imx274_mipi and imx290_mipi as examples, assume imx274_mipi is mounted on VIN8 and imx290_mipi on VIN0. Specify "vinc_id=8" and "bus_id=3" while installing the imx274_mipi sensor driver. Alternatively, "vinc_id=0" and "bus_id=5" are specified when the imx290_mipi sensor driver is installed.<br  />
</p>
<p >For CV72, there is no need to specify bus_id. This is because all VIN controllers share I2C bus ID 0. Since I2C bus ID 0 is the default value, so there is no need to speicfy this when performing sensor probe.</p>
<div class="fragment"><div class="line">board_cv5x# modprobe imx274_mipi vinc_id=8 bus_id=3</div>
<div class="line">board_cv5x# modprobe imx290_mipi vinc_id=0 bus_id=5</div>
<div class="line">board_cv72# modprobe imx274_mipi vinc_id=8</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><ul>
<li>The "bus_id=3" is the I2C bus ID specified for VIN controller 8 in the device tree. The "bus_id=5" is the I2C bus ID specified for VIN controller 0 in the device tree.</li>
<li>For CV5 Timn EVK, VIN controller 8 and I2C bus 3 are bound together, VIN controller 0 and I2C bus 5 are bound together.</li>
</ul>
</dd></dl>
<h2><a class="anchor" id="Multiple_Sensors_with_the_same_sensor_type"></a>
3.3 Multiple Sensors with the Same Sensor Type</h2>
<p >In this case, one sensor driver is installed for multiple sensors connected to one or more VIN controllers. Using imx274_mipi as an example, assume that there are quad imx274_mipi mounted on VIN8, VIN11, VIN0 and VIN4 for CV5x. Specify "vinc_id=0x40b8" when installing the sensor driver. In "vinc_id=0x40b8", "8", "b" "0" and "4" are VIN controller ID. "bus_id" does not require to be specified, as the sensor driver can query it from the device tree.<br  />
</p>
<div class="fragment"><div class="line">board_cv5x# modprobe imx274_mipi vinc_id=0x40b8</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><ul>
<li>In the first case, the same sensor driver cannot be installed twice.</li>
</ul>
</dd></dl>
<h2><a class="anchor" id="Sensors_with_SERDES_Bridge"></a>
3.4 Sensors with SERDES Bridge</h2>
<p >In this case, sensor drivers are installed for multiple sensors connected through one or more SERDES. To get this, users need to install Ambarella bridge driver, SERDES driver and sensor drivers (SERDES version) sequentially. When installing each SERDES driver, users must specify the bitmap of bridge ports where sensors are connected. VIN controller ID module paramater can be specified optionally as it can be specified in the device tree. When installing the sensor driver (SERDES version), users need to specify the bridge ID that it connects. The SERDES and sensor driver module parameters are listed below.<br  />
</p>
<p ><b>SERDES driver module parameters:</b><br  />
</p><ul>
<li>"id": the bitmap of sensor ports in the bridges of SERDES. Each 8-bit represents a SERDES bridge node "vinbrg(xxxx)" in DTS, and one bit is a SERDES port.</li>
<li>"vinc_id": VIN controller ID to which SERDES connects. SERDES driver will query it from the device tree (DTS) first, if not, users must specify it as a module parameter. "dts_addr": if it is set to 1, SERDES driver will query SERDES configurations from "bus-addr" in DTS. The bit definition of "bus-addr"is as below. If it is not set, SERDES driver will use default values pre-defined in its driver. For I2C bus ID, SERDES driver always queries it from bit[19:16] of "bus-addr"despite that "dts_addr"is set or not.<br  />
</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Bit Field   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">bit[7:0]   </td><td class="markdownTableBodyLeft">Deserializer address    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">bit[15:8]   </td><td class="markdownTableBodyLeft">Serializer address    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">bit[19:16]   </td><td class="markdownTableBodyLeft">I2C bus ID    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">bit[31:20]   </td><td class="markdownTableBodyLeft">Reserved for SERDES internal usage   </td></tr>
</table>
<ul>
<li>"brg_id": bitmap of bridge on SERDES. It represents which bridge are the sensors connected. Each bit corresponds to a bridge. For example, "brg_id=0x1/0x2/0x4" means bridge 0/1/2, "brg_id=0x3" means bridge 0 and bridge 1.</li>
<li>"slave" or "fsync": "slave/fsync=0" means the sensor runs at master mode. "slave=1" means the sensor runs at slave mode. "fsync=1"means the sensor runs at fsync mode.<br  />
</li>
</ul>
<p >The following diagram shows the topology among sensors, SERDES, and VINCs. </p><div class="image">
<img src="../../Sensors_Serdes_VINC_Topology.jpg" alt=""/>
<div class="caption">
Figure 3-1. Sensors-Serdes-VINC_Topology.</div></div>
<p> <b>Reference examples:</b><br  />
 </p>
<h3><a class="anchor" id="example_serdes_connect1"></a>
Example 1.  Single ar0233_mipi_brg connects to MAX9296.</h3>
<p >In this example, single ar0233_mipi_brg connects to MAX9296 bridge1's port0 for the board.</p>
<div class="fragment"><div class="line">board# modprobe ambrg</div>
<div class="line">board# modprobe max9296 <span class="keywordtype">id</span>=0x100 vinc_id=0xb</div>
<div class="line">board# modprobe ar0233_mipi_brg</div>
</div><!-- fragment --><p >Max9296 SERDES driver will find bridge node "vinbrg1" according to the module parameter: "id=0x100"(only port0 of bridge1 is specified) from "iav" node. "vinc_id=0xb" means it corresponds to VIN controller 11.<br  />
</p>
<h3><a class="anchor" id="example_serdes_connect2"></a>
Example 2 Dual ar0231_mipi_brg connects to ds90ub954.</h3>
<p >In this example, dual ar0231_mipi_brg connects to TIDS90UB954 bridge0's port0 and port1.</p>
<div class="fragment"><div class="line">board# modprobe ambrg</div>
<div class="line">board# modprobe ds90ub954 <span class="keywordtype">id</span>=0x3 vinc_id=8</div>
<div class="line">board# modprobe ar0231_mipi_brg slave=1</div>
</div><!-- fragment --><p >Ds90ub954 SERDES driver will find the bridge node "vinbrg0" according to the module parameter: "id=0x3"(port0 and port1 of bridge0 are specified) from "iav" node. "vinc_id=8" means it corresponds to VIN controller 8.<br  />
</p>
<h3><a class="anchor" id="example_serdes_connect3"></a>
Example 3 Dual ar0231_mipi_brg connects to dual ds90ub954.</h3>
<p >In this example, one ar0231_mipi_brg connects to one TIDS90UB954 bridge0's port0, another ar0231_mipi_brg connects to another TIDS90UB954 bridge1's port0 for the board.</p>
<div class="fragment"><div class="line">board# modprobe ambrg</div>
<div class="line">board# modprobe ds90ub954 <span class="keywordtype">id</span>=0x101 vinc_id=0xb8</div>
<div class="line">board# modprobe ar0231_mipi_brg</div>
</div><!-- fragment --><p >Ds90ub954 SERDES driver will find bridge nodes "vinbrg0" and "vinbrg1" according to the module parameter: "id=0x101" from "iav" node. "vinc_id=0xb8" means it corresponds to VIN controller 8 and 11 respectively.<br  />
</p>
<h3><a class="anchor" id="example_serdes_connect4"></a>
Example 4 Single ar0231_mipi_brg and ar0239_mipi_brg connect to dual ds90ub954.</h3>
<p >In this example, one ar0231_mipi_brg connects to TIDS90UB954 bridge0's port0. The other ar0239_mipi_brg connects to another TIDS90UB954 bridge1's port0 for the board.</p>
<div class="fragment"><div class="line">board# modprobe ambrg</div>
<div class="line">board# modprobe ds90ub954 <span class="keywordtype">id</span>=0x101 vinc_id=0xb8</div>
<div class="line">board# modprobe ar0231_mipi_brg brg_id=0x1 <span class="comment">// connect to bridge0 of ds90ub954</span></div>
<div class="line">board# modprobe ar0239_mipi_brg brg_id=0x2 <span class="comment">// connect to bridge1 of ds90ub954</span></div>
</div><!-- fragment --><p >Ds90ub954 SERDES driver will find bridge nodes "vinbrg0" and "vinbrg1" according to the module parameter: "id=0x101" from "iav" node. "vinc_id=0xb8" means it corresponds to VIN controller 8 and 11 respectively.<br  />
</p>
<h3><a class="anchor" id="example_serdes_connect5"></a>
Example 5 Single ar0231_mipi_brg and ar0239_mipi_brg connect to dual ds90ub954; ar0144_brg connects to max9288.</h3>
<p >In this example, one ar0231_mipi_brg connects to TIDS90UB954 bridge0's port0. The other ar0239_mipi_brg connects to another TIDS90UB954 bridge1's port0. Another ar0144_brg connects to MAX9288 bridge2's port0.</p>
<div class="fragment"><div class="line">board# modprobe ambrg</div>
<div class="line">board# modprobe ds90ub954 <span class="keywordtype">id</span>=0x101 vinc_id=0xb8</div>
<div class="line">board# modprobe max9288 <span class="keywordtype">id</span>=0x10000 vinc_id=0</div>
<div class="line">board# modprobe ar0231_mipi_brg brg_id=0x1 <span class="comment">// connect to bridge0 of ds90ub954</span></div>
<div class="line">board# modprobe ar0239_mipi_brg brg_id=0x2 <span class="comment">// connect to bridge1 of ds90ub954</span></div>
<div class="line">board# modprobe ar0144_brg brg_id=0x4 <span class="comment">// connect to bridge2 of max9288</span></div>
</div><!-- fragment --><p >Ds90ub954 SERDES driver will find bridge nodes "vinbrg0" and "vinbrg1" according to module parameter: "id=0x101" from "iav" node. "vinc_id=0xb8" means * it corresponds to VIN controller 8 and 11 respectively. Max9288 SERDES driver will find bridge node "vinbrg2" according to the module parameter: "id=0x10000" from "iav" node. "vinc_id=0" means it corresponds * to VIN controller 0.<br  />
</p>
<h3><a class="anchor" id="example_serdes_connect6"></a>
Example 6 Quad os08a10_mipi_brg connects to dual MAX9296.</h3>
<p >In this example, two MAX9296 SERDES are connected to VIN controller 8 and controller 11. Each SERDES has two ar0231_mipi_brg connected to its port0 and port1.</p>
<div class="fragment"><div class="line">board# modprobe ambrg</div>
<div class="line">board# modprobe max9296 <span class="keywordtype">id</span>=0x0303 vinc_id=0xb8</div>
<div class="line">board# modprobe os08a10_mipi_brg fsync=1</div>
</div><!-- fragment --><p >Max9296 SERDES driver will find bridge nodes "vinbrg0" and "vinbrg1" according to the module parameter: "id=0x0303" from "iav" node. As "vinc_id" is not specified in bridge nodes, users must specify "vinc_id=0xb8" through the module parameter.<br  />
 <b>DTS example configuration</b><br  />
</p>
<div class="fragment"><div class="line">iav {</div>
<div class="line">   ……</div>
<div class="line">   Vinbrg0 {</div>
<div class="line">      compatible = <span class="stringliteral">&quot;ambarella,vinbrg&quot;</span>;</div>
<div class="line">      ……</div>
<div class="line">      bus-addr = &lt;0x30000&gt;;</div>
<div class="line">   };</div>
<div class="line">   Vinbrg1 {</div>
<div class="line">      compatible = <span class="stringliteral">&quot;ambarella,vinbrg&quot;</span>;</div>
<div class="line">      ……</div>
<div class="line">      bus-addr = &lt;0x30001&gt;;</div>
<div class="line">    };</div>
<div class="line">    ……</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="example_serdes_connect7"></a>
Example 7 Set up dual sensors with different modes from MAX9296.</h3>
<p >This example shows how to set up dual sensor with different modes from MAX9296.</p>
<div class="fragment"><div class="line">board# modprobe max9296 <span class="keywordtype">id</span>=0x201 vc=1 dts_addr=1</div>
<div class="line">board# modprobe os08a10_mipi_brg brg_id=0x1</div>
<div class="line">board# modprobe imx290_mipi_brg brg_id=0x2 slave=1</div>
</div><!-- fragment --><h2><a class="anchor" id="Vsrc_id_recordering"></a>
3.5 Vsrc_id Reordering</h2>
<p >During the sensor driver installation, each sensor is enumerated as a VIN source (VSRC) device, and a unique vsrc_id is allocated for each VSRC device. Each sensor has a different vsrc_id.<br  />
 Vsrc_id starts at zero and keeps incrementally increasing after each newly enumerated VSRC device is added. Therefore, the vsrc_id value specified for each sensor depends on the installation order of the sensor driver.<br  />
 In the example provided in <a class="el" href="../../d2/dcb/page_sys_sensor_driver_installation.html#Multiple_Sensors_with_Different_Sensor_Types">1. Multiple Sensors with Different Sensor Types</a>, as the imx274_mipi sensor driver is installed before imx290_mipi, "vsrc_id=0" will be specified for imx274_mipi, "vsrc_id=1" for imx290_mipi.<br  />
</p>
<div class="fragment"><div class="line">board_cv5x# modprobe imx274_mipi vinc_id=8 bus_id=3 <span class="comment">// vsrc_id = 0</span></div>
<div class="line">board_cv5x# modprobe imx290_mipi vinc_id=0 bus_id=5 <span class="comment">// vsrc_id = 1</span></div>
</div><!-- fragment --><p >If the sensor driver imx290_mipi is installed before imx274_mipi, "vsrc_id=0" will be specified for imx290_mipi, "vsrc_id=1" for imx274_mipi.</p>
<div class="fragment"><div class="line">board_cv5x# modprobe imx290_mipi vinc_id=0 bus_id=5 <span class="comment">// vsrc_id = 0</span></div>
<div class="line">board_cv5x# modprobe imx274_mipi vinc_id=8 bus_id=3 <span class="comment">// vsrc_id = 1</span></div>
</div><!-- fragment --><p >Some use cases require the order of the sensor's vsrc_id to stay the same despite the installation order of their sensor drivers. In order to meet these requirements, the image audio video (IAV) driver supports the vsrc_id feature of reordering through the module parameter: "vsrc_id_reorder". When it is enabled, vsrc_id specifies that each sensor will follow the same order with the VIN controllers that they are mounted on. By default, this will disable vsrc_id reordering.<br  />
 In the example above, when vsrc_id reordering is enabled, no matter the order of the sensor driver installation of imx274_mipi and imx290_mipi is, "vsrc_id=0" will always be specified for imx274_mipi, "vsrc_id=1" for imx290_mipi, and so on.<br  />
</p>
<div class="fragment"><div class="line">board_cv5x# modprobe iav vsrc_id_reorder=1</div>
<div class="line">board_cv5x# modprobe imx274_mipi vinc_id=8 bus_id=3 <span class="comment">// vsrc_id = 1</span></div>
<div class="line">board_cv5x# modprobe imx290_mipi vinc_id=0 bus_id=5 <span class="comment">// vsrc_id = 0</span></div>
</div><!-- fragment --><h2><a class="anchor" id="keep_broken_vsrc_id"></a>
3.6 Keep Broken Vsrc_id</h2>
<p >Sensor driver installation will probe the corresponding physical sensor proactively through the I2C or SPI bus. By default, if the sensor is disconnected or broken and cannot be probed successfully, then the sensor drivers will not be installed.<br  />
 Some use cases with multiple sensors may require the sensor driver to be installed normally, even when the sensor is disconnected or broken. For most cases, users should keep the vsrc_id of the other sensors unchanged.<br  />
 In order to meet these requirements, the IAV driver supports the feature of keeping broken vsrc_id with the module parameter: "keep_broken_vsrc". When it is enabled, the sensor driver will always be installed no matter what the sensor status is. If the sensor cannot be probed, it will be marked as broken. By default, this is disabled.<br  />
</p>
<div class="fragment"><div class="line">board# modprobe iav keep_broken_vsrc=1</div>
</div><!-- fragment --><h2><a class="anchor" id="Specify_Target_Vsrc_num"></a>
3.7 Specify Target Vsrc_num</h2>
<p >The IAV driver supports specifying the target Vsrc number feature with the module parameter: "target_vsrc_num". When it is specified, the user application can only operate the sensor control after all of the sensor drivers are installed. This ensures that the sensor driver installation is finished before any sensor control operations. By default, the target Vsrc number is 0, which means that the IAV driver will not check, even if all of the sensor drivers are installed.<br  />
</p>
<div class="fragment"><div class="line">board# modprobe iav target_vsrc_num=2</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="cv5x_multi_vin_support"></a>
4. Cooper EVK with Multi-VIN support</h1>
<h2><a class="anchor" id="CV5_Multi_VIN_Design"></a>
4.1 CV5 Multi-VIN Design</h2>
<p >CV5x supports 4x native VIN controllers. Through MIPI virtual channel, it can be extended to 14x VIN controllers. It can support various VIN interfaces including MIPI D/C-PHY, SLVS-EC, and SLVS. MIPI and SLVS-EC interfaces can be up to 16 lanes. SLVS interface can be up to 8 lanes.</p>
<table class="doxtable">
<tr>
<th><div style="width:120px"></div>VIN Slot Mode</th><th><div style="width:120px"></div>I2C Bus ID </th><th><div style="width:120px"></div>VIN Controller ID</th><th><div style="width:120px"></div>Type  </th></tr>
<tr>
<td rowspan="7">SLVS + DPHY </td></tr>
<tr>
<td align="center">3/4</td><td align="center">8</td><td align="center">Real </td></tr>
<tr>
<td align="center"></td><td align="center">9</td><td align="center">Virtual </td></tr>
<tr>
<td align="center"></td><td align="center">10</td><td align="center">Virtual </td></tr>
<tr>
<td align="center"></td><td align="center">11</td><td align="center">Real </td></tr>
<tr>
<td align="center"></td><td align="center">12</td><td align="center">Virtual </td></tr>
<tr>
<td align="center"></td><td align="center">13</td><td align="center">Virtual  </td></tr>
<tr>
<td rowspan="5">SLVS-EC </td></tr>
<tr>
<td align="center">5</td><td align="center">0</td><td align="center">Real </td></tr>
<tr>
<td align="center"></td><td align="center">1</td><td align="center">Virtual </td></tr>
<tr>
<td align="center"></td><td align="center">2</td><td align="center">Virtual </td></tr>
<tr>
<td align="center"></td><td align="center">3</td><td align="center">Virtual  </td></tr>
<tr>
<td rowspan="5">DCPHY 0 </td></tr>
<tr>
<td align="center">5</td><td align="center">0</td><td align="center">Real </td></tr>
<tr>
<td align="center"></td><td align="center">1</td><td align="center">Virtual </td></tr>
<tr>
<td align="center"></td><td align="center">2</td><td align="center">Virtual </td></tr>
<tr>
<td align="center"></td><td align="center">3</td><td align="center">Virtual  </td></tr>
<tr>
<td rowspan="5">DCPHY 1 </td></tr>
<tr>
<td align="center">1</td><td align="center">4</td><td align="center">Real </td></tr>
<tr>
<td align="center"></td><td align="center">5</td><td align="center">Virtual </td></tr>
<tr>
<td align="center"></td><td align="center">6</td><td align="center">Virtual </td></tr>
<tr>
<td align="center"></td><td align="center">7</td><td align="center">Virtual  </td></tr>
</table>
<p >Currently, CV5 supports a 2~4 multiple-VIN design through SERDES with SLVS + DPHY VIN slot. The sensors must support a 4-lane interface through either MIPI or SLVS. The following figure shows the sensor boards inserted into the SLVS + DPHY VIN slot on the CV5 Timn board.</p>
<div class="image">
<img src="../../single_sensor_plug_into_CV5_Timn_Board.jpg" alt=""/>
<div class="caption">
Figure 4-1. Single Sensor Boards Plug in CV5 Timn Board.</div></div>
<hr  />
<h2><a class="anchor" id="CV52_Multi_VIN_Design"></a>
4.2 CV52 Multi-VIN Design</h2>
<p >CV52 supports 4x native VIN controllers. Through MIPI virtual channel, it can be extended to 14x VIN controllers. CV52 can support various VIN interfaces including MIPI D/C-PHY and SLVS. MIPI interfaces can be up to 16 lanes. SLVS interface can be up to 8 lanes.</p>
<table class="doxtable">
<tr>
<th><div style="width:120px"></div>VIN Slot Mode</th><th><div style="width:120px"></div>I2C Bus ID </th><th><div style="width:120px"></div>VIN Controller ID</th><th><div style="width:120px"></div>Type  </th></tr>
<tr>
<td rowspan="7">SLVS + DPHY </td></tr>
<tr>
<td align="center">3/4</td><td align="center">8</td><td align="center">Real </td></tr>
<tr>
<td align="center"></td><td align="center">9</td><td align="center">Virtual </td></tr>
<tr>
<td align="center"></td><td align="center">10</td><td align="center">Virtual </td></tr>
<tr>
<td align="center"></td><td align="center">11</td><td align="center">Real </td></tr>
<tr>
<td align="center"></td><td align="center">12</td><td align="center">Virtual </td></tr>
<tr>
<td align="center"></td><td align="center">13</td><td align="center">Virtual  </td></tr>
<tr>
<td rowspan="5">DCPHY 0 </td></tr>
<tr>
<td align="center">5</td><td align="center">0</td><td align="center">Real </td></tr>
<tr>
<td align="center"></td><td align="center">1</td><td align="center">Virtual </td></tr>
<tr>
<td align="center"></td><td align="center">2</td><td align="center">Virtual </td></tr>
<tr>
<td align="center"></td><td align="center">3</td><td align="center">Virtual  </td></tr>
<tr>
<td rowspan="5">DCPHY 1 </td></tr>
<tr>
<td align="center">1</td><td align="center">4</td><td align="center">Real </td></tr>
<tr>
<td align="center"></td><td align="center">5</td><td align="center">Virtual </td></tr>
<tr>
<td align="center"></td><td align="center">6</td><td align="center">Virtual </td></tr>
<tr>
<td align="center"></td><td align="center">7</td><td align="center">Virtual  </td></tr>
</table>
<p >Currently, CV52 supports a 2~4 multiple-VIN design through SERDES with SLVS + DPHY VIN slot. The sensors must support a 4-lane interface through either MIPI or SLVS. The following figure shows the sensor boards inserted into the SLVS + DPHY VIN slot on the CV52 Zircon board. Compared with CV5, CV52 does not support SLVS-EC VIN interface.</p>
<div class="image">
<img src="../../single_sensor_plug_into_CV52_Zircon_Board.jpg" alt=""/>
<div class="caption">
Figure 4-2. Single Sensor Boards Plug in CV52 Zircon Board.</div></div>
<hr  />
<h2><a class="anchor" id="CV72_Multi_VIN_Design"></a>
4.3 CV72 Multi-VIN Design</h2>
<p >CV72 supports 3x native VIN controllers. Through MIPI virtual channel, it can be extended to 10x VIN controllers. CV72 can support various VIN interfaces including MIPI D/C-PHY and SLVS. MIPI interfaces can be up to 16 lanes. SLVS interface can be up to 8 lanes.</p>
<table class="doxtable">
<tr>
<th><div style="width:120px"></div>VIN Slot Mode</th><th><div style="width:120px"></div>I2C Bus ID </th><th><div style="width:120px"></div>VIN Controller ID</th><th><div style="width:120px"></div>Type  </th></tr>
<tr>
<td rowspan="7">SLVS + DPHY </td></tr>
<tr>
<td align="center">0</td><td align="center">8</td><td align="center">Real </td></tr>
<tr>
<td align="center"></td><td align="center">9</td><td align="center">Virtual </td></tr>
<tr>
<td align="center"></td><td align="center">10</td><td align="center">Virtual </td></tr>
<tr>
<td align="center"></td><td align="center">11</td><td align="center">Real </td></tr>
<tr>
<td align="center"></td><td align="center">12</td><td align="center">Virtual </td></tr>
<tr>
<td align="center"></td><td align="center">13</td><td align="center">Virtual  </td></tr>
<tr>
<td rowspan="5">DCPHY 0 </td></tr>
<tr>
<td align="center">0</td><td align="center">0</td><td align="center">Real </td></tr>
<tr>
<td align="center"></td><td align="center">1</td><td align="center">Virtual </td></tr>
<tr>
<td align="center"></td><td align="center">2</td><td align="center">Virtual </td></tr>
<tr>
<td align="center"></td><td align="center">3</td><td align="center">Virtual  </td></tr>
</table>
<p >Currently, CV72 supports a 2~3 multiple-VIN design through SERDES with SLVS + DPHY VIN slot. The sensors must support a 4-lane interface through either MIPI or SLVS. The following figure shows the sensor boards inserted into the SLVS + DPHY VIN slot on the CV72 Ga board. Compared with CV5, CV72 does not support SLVS-EC VIN interface, and CV72 removes DCPHY 1.</p>
<div class="image">
<img src="../../single_sensor_plug_into_CV72_Ga_Board.jpg" alt=""/>
<div class="caption">
Figure 4-3. Single Sensor Boards Plug in CV72 Ga Board.</div></div>
<hr  />
 </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
