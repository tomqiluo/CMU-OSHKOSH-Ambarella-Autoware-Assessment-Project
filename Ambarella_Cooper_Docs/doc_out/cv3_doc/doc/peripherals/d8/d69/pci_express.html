<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Peripherals: PCI Express</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<link rel="search" href="../../search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Peripherals"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-ambarella.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../Ambarella.png"/></td>
  <td id="projectalign">
   <div id="projectname">Peripherals<span id="projectnumber">&#160;Cooper_1.6.0 (CV72 &amp; CV3) @ 2024.07.10 14:12:44</span>
   </div>
   <div id="projectbrief">placeholder</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d8/d69/pci_express.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">PCI Express </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >Ambarella systems on chip (SoCs) CV5 and CV72 include one Gen3x4 dual-mode controller, and CV3 includes three Gen3x4 dual-mode controllers. CV3 includes one Gen5x4 dual-mode controller and two Gen5x1 dual-mode controllers.</p>
<p >Devices such as Ethernet cards and non-volatile memory express (NVMe) disks can be connected to the system via peripheral component interconnect express (PCIe) ports. <img src="../../pci_express_nvme_ssd_port.png" alt="" class="inline" title="NVMe example"/>    The CV5 Timn evaluation kit (EVK) has a dedicated NVMe solid-state drive (SSD) slot for SSD disks. Other general PCIe devices can be connected to the system using the general PCIe ports on the top side of the EVK board. All of Ambarella's PCIe controllers can function as either a root complex (RC) or an endpoint (EP), but only one mode can be active at a time, and cannot be switched during runtime. For more details on the endpoint function (EPF), refer to the <code>Documentation/arm/ambarella/</code> directory within the Linux kernel source tree.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Regular Endpoint Devices</h1>
<h2><a class="anchor" id="autotoc_md4"></a>
nvme_ssd NVMe SSD</h2>
<p >Some drivers for PCIe Ethernet are already in the kernel. The two drivers below are selected by default. </p><pre class="fragment">build $ make cv5_ipcam_config
build $ make menuconfig
        Ambarella Boot Configuration  ---&gt;
          Amboot Configuration  ---&gt;
            Hardware Options  ---&gt;
              [*] Support PCIE Driver  ---&gt;
                PCIE Mode (RC)
build $ make defconfig_public_linux
build $ make menuconfig_public_linux
        Device Drivers  ---&gt;
          NVMe support  ---&gt;
            &lt;M&gt; NVM Express block device
</pre><p> If NVMe SSD is not automatically loaded, users can enable it using the command below. </p><pre class="fragment">board # modprobe nvme
</pre><p> The following is the performance of NVMe SSD on the CV5 EVK:</p><ul>
<li>Read: 3432.9 MB/s</li>
<li>Write: 2754.5 MB/s</li>
</ul>
<hr  />
<h3><a class="anchor" id="autotoc_md5"></a>
Throughput Result</h3>
<p >Test command:</p><ul>
<li>fio -direct=1 -iodepth=128 -rw=write -ioengine=libaio -bs=128k -numjobs=1 -time_based=1 -runtime=10 -group_reporting -filename=/dev/nvme0n1 -name=test</li>
<li>fio -direct=1 -iodepth=128 -rw=write -ioengine=libaio -bs=128k -numjobs=1 -time_based=1 -runtime=10 -group_reporting -filename=/dev/nvme0n1 -name=test</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Read Throughput   </th><th class="markdownTableHeadNone">Write Throughput   </th><th class="markdownTableHeadNone">DDR Frequency   </th><th class="markdownTableHeadNone">Lane Number   </th><th class="markdownTableHeadNone">NVMe Model   </th><th class="markdownTableHeadNone">SoC / Board    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">3261 MB/s   </td><td class="markdownTableBodyNone">2418 MB/s   </td><td class="markdownTableBodyNone">3.192 G   </td><td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">Samsung 980   </td><td class="markdownTableBodyNone">CV5    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3467 MB/s   </td><td class="markdownTableBodyNone">2416 MB/s   </td><td class="markdownTableBodyNone">3.192 G   </td><td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">Samsung 970   </td><td class="markdownTableBodyNone">CV5    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">844 MB/s   </td><td class="markdownTableBodyNone">793 MB/s   </td><td class="markdownTableBodyNone">3.192 G   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">Samsung 970   </td><td class="markdownTableBodyNone">CV72 (Gage)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">845 MB/s   </td><td class="markdownTableBodyNone">807 MB/s   </td><td class="markdownTableBodyNone">3.192 G   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">Samsung 970   </td><td class="markdownTableBodyNone">CV72 (Xiezhi)   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md6"></a>
GPU AMD ATI GPU</h2>
<p >At present, CV72 is the only platform capable of supporting PCIe graphics processing units (GPUs) due to its extensive advanced extensible interface (AXI) memory space for PCIe. This feature is crucial for most GPUs, as they typically require at least 256 MB of 64-bit prefetchable memory space.</p>
<p >Ambarella has tested AMD RV620 PRO [Radeon HD 3470] on CV72: </p><pre class="fragment">Graphics:
Device-1: AMD RV620 PRO [Radeon HD 3470] driver: radeon v: kernel
 Display: x11 server: X.org v: 1.20.14 with: Xwayland v: 22.1.9 driver: X: loaded: radeon
  unloaded: fbdev,modesetting dri: swrast gpu: radeon tty: 237x61 resolution: 1920x1080-60Hz
Application programming interface (API): OpenGL v: 4.5 Mesa 23.0.3 renderer: llvmpipe (LLVM 15.0.7 128 bits)
</pre><p> As shown above, the Radeon driver is employed in this case. However, if users possess other ATI cards that are compatible with amdgpu, Ambarella recommends using them instead. The amdgpu driver offers more advanced memory management features, such as GTT support.</p>
<h3><a class="anchor" id="autotoc_md7"></a>
Troubleshooting</h3>
<h4><a class="anchor" id="autotoc_md8"></a>
The video random-access memory (VRAM) is too large:</h4>
<p >The GPU may require a large amount of VRAM space, which is beyond the amount of Ambarella SoC PCIe AXI space that is supported:</p>
<div class="fragment"><div class="line">[   14.993326] pcieport 0000:00:00.0: BAR 15: no space <span class="keywordflow">for</span> [mem size 0x300000000 64bit pref]</div>
<div class="line">[   15.005583] pcieport 0000:00:00.0: BAR 15: failed to assign [mem size 0x300000000 64bit pref]</div>
<div class="line">[   15.015590] amdgpu 0000:01:00.0: BAR 0: no space <span class="keywordflow">for</span> [mem size 0x200000000 64bit pref]</div>
<div class="line">[   15.024950] amdgpu 0000:01:00.0: BAR 0: failed to assign [mem size 0x200000000 64bit pref]</div>
<div class="line">[   15.033368] amdgpu 0000:01:00.0: BAR 2: no space <span class="keywordflow">for</span> [mem size 0x00200000 64bit pref]</div>
<div class="line">[   15.041335] amdgpu 0000:01:00.0: BAR 2: failed to assign [mem size 0x00200000 64bit pref]</div>
<div class="line">[   15.097912] [drm] Not enough PCI address space <span class="keywordflow">for</span> a large BAR.</div>
<div class="line">[   15.097933] amdgpu 0000:01:00.0: BAR 0: assigned [mem 0xfe20000000-0xfe2fffffff 64bit pref]</div>
<div class="line">[   15.112403] amdgpu 0000:01:00.0: BAR 2: assigned [mem 0xfe18000000-0xfe181fffff 64bit pref]</div>
<div class="line">[   15.140949] [drm] Detected VRAM RAM=8192M, BAR=256M</div>
</div><!-- fragment --><p >For this case, users should limit VRAM by adding "vis_vramlimit=512 vramlimit=512 gartsize=128 gttsize=512" to the kernel commandline; however, this is not sufficient because it only limits VRAM usage and would still require 8192 M. Therefore, users should disable bar resize: </p><div class="fragment"><div class="line">modified   drivers/gpu/drm/amd/amdgpu/gmc_v8_0.c</div>
<div class="line">@@ -572,11 +572,11 @@ <span class="keyword">static</span> <span class="keywordtype">int</span> gmc_v8_0_mc_init(<span class="keyword">struct</span> amdgpu_device *adev)</div>
<div class="line">         adev-&gt;gmc.mc_vram_size = tmp * 1024ULL * 1024ULL;</div>
<div class="line">         adev-&gt;gmc.real_vram_size = adev-&gt;gmc.mc_vram_size;</div>
<div class="line"> </div>
<div class="line">-        <span class="keywordflow">if</span> (!(adev-&gt;flags &amp; AMD_IS_APU)) {</div>
<div class="line">-                r = amdgpu_device_resize_fb_bar(adev);</div>
<div class="line">-                <span class="keywordflow">if</span> (r)</div>
<div class="line">-                        <span class="keywordflow">return</span> r;</div>
<div class="line">-        }</div>
<div class="line">+        <span class="comment">//if (!(adev-&gt;flags &amp; AMD_IS_APU)) {</span></div>
<div class="line">+        <span class="comment">//     r = amdgpu_device_resize_fb_bar(adev);</span></div>
<div class="line">+        <span class="comment">//     if (r)</span></div>
<div class="line">+        <span class="comment">//             return r;</span></div>
<div class="line">+        <span class="comment">//}</span></div>
</div><!-- fragment --><p >Note that if the amdgpu driver used is not gmc_v8_0.c, users should remove the bar resize function in the correct gmc_vN_M.c.</p>
<h4><a class="anchor" id="autotoc_md9"></a>
Ring Test Failed</h4>
<p >If users encounter error messages such as <code>*ERROR* ring gfx test failed (-110)</code> or <code>*ERROR* radeon: ring 0 test failed</code>, there is an issue with reading or writing to the ring buffer (also known as the GPU's command buffer). The specific cause of these errors can vary depending on the platform and other factors, such as support for ExtTag by the upstream switch. For the Ambarella platform, this issue arises due to a limitation with the Cadence Gen3 PCIe controller. This controller does not permit variations from its maximum <code>pcie_master_AXI_ARSIZE</code> value of four, unless <code>pcie_master_AXI_ARLEN</code> is zero in a request. This means that, if users must read or write (memory-mapped input / output (MMIO)) to the endpoint's bar, they are required to use writel / readl operations. The use of <code>memcpy / memcpy_to / fromio / readq / writeq</code> operations is not allowed under these circumstances.</p>
<p >At present, the <code>radeon / amdgpu</code> driver uses the <code>memcpy_toio / memcpy_fromio</code> functions for the ring buffer. To address this issue, these functions should be replaced with the 32-bit version of <code>memcpy</code>. Users can easily implement this change by applying the modifications found in [Coreforge's PR] (<a href="https://github.com/Coreforge/linux/pull/1/commits">https://github.com/Coreforge/linux/pull/1/commits</a>), which introduces the 32-bit <code>memcpy</code>. Alternatively, users can utilize the <code>memcpy_fromio_ambarella</code> function that the Ambarella kernel provides.</p>
<p >It is important to note that this limitation does not only impact kernel space drivers; updates to memcpy in the userspace are also necessary. The <code>GLIBC</code>'s <code>memcpy</code> for <code>aarch64</code> is implemented in assembly and uses single instruction / multiple data (SIMD) <code>stp/ldp</code> operations where possible. A solution could be to implement a version of memcpy that copies four-byte chunks at one time, similar to how <code>memcpy_fromio_ambarella</code> functions. An example of how to perform this operation can be found in this Stack Overflow post: <a href="https://stackoverflow.com/a/11876613/6949852">https://stackoverflow.com/a/11876613/6949852</a>. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> memcpy(<span class="keywordtype">void</span>* dest, <span class="keywordtype">void</span>* src, <span class="keywordtype">int</span> size)</div>
<div class="line">{</div>
<div class="line">    uint8_t *pdest = (uint8_t*) dest;</div>
<div class="line">    uint8_t *psrc = (uint8_t*) src;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> loops = (size / <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> index = 0; <a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a> &lt; loops; ++<a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>)</div>
<div class="line">    {</div>
<div class="line">        *((uint32_t*)pdest) = *((uint32_t*)psrc);</div>
<div class="line">        pdest += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">        psrc += <span class="keyword">sizeof</span>(uint32_t);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    loops = (size % <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> index = 0; <a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a> &lt; loops; ++<a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>)</div>
<div class="line">    {</div>
<div class="line">        *pdest = *psrc;</div>
<div class="line">        ++pdest;</div>
<div class="line">        ++psrc;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="acJSON_8h_html_a750b5d744c39a06bfb13e6eb010e35d0"><div class="ttname"><a href="../../../library/d1/d82/cJSON_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a></div><div class="ttdeci">int index</div></div>
</div><!-- fragment --><p >To compile the shared library, use the following flags: <code>-fPIC -g -fno-inline -fno-builtin-inline -fno-inline-functions -fno-builtin -shared</code>. Users can test this library by using the <code>LD_PRELOAD="./libmemcpy.so"</code> command, followed by the user application. Alternatively, users can make the library globally available by adding its full path to the <code>/etc/ld.so.preload</code> file.</p>
<p >As pointed above, it is the Ambarella controller's limition, but only the GPU driver requires this change because drivers, such as NVMe, have performed similar changes in <a href="https://github.com/torvalds/linux/commit/a310acd7a7ea53533886c11bb7edd11ffd61a036">https://github.com/torvalds/linux/commit/a310acd7a7ea53533886c11bb7edd11ffd61a036</a>. The commit changes how NVMe storage devices are managed by the kernel, specifically in relation to how 64-bit <code>read / write</code> operations are managed. The commit modifies the kernel's NVMe driver to use "split" <code>read / write</code> operations for certain storage controllers that may require ordered split transfers, even on 64-bit machines. This includes, for example, the NVMe controller found in certain models of Apple™'s MacBook™. The commit changes several instances in the code where <code>readq</code> and <code>writeq</code> functions were used, to instead use <code>lo_hi_readq</code> and <code>lo_hi_writeq</code> respectively. These changes should ensure ordered split transfers on 64-bit platforms, which helps avoid potential issues with the aforementioned controllers.</p>
<p >Users are not required to modify the NVMe driver. If desired, users can attempt to undo the changes made by the commit using the following method: </p><div class="fragment"><div class="line">modified   drivers/nvme/host/pci.c</div>
<div class="line">@@ -1755,8 +1755,8 @@ <span class="keyword">static</span> <span class="keywordtype">int</span> nvme_pci_configure_admin_queue(<span class="keyword">struct</span> nvme_dev *dev)</div>
<div class="line">         aqa |= aqa &lt;&lt; 16;</div>
<div class="line"> </div>
<div class="line">         writel(aqa, dev-&gt;bar + NVME_REG_AQA);</div>
<div class="line">-        lo_hi_writeq(nvmeq-&gt;sq_dma_addr, dev-&gt;bar + NVME_REG_ASQ);</div>
<div class="line">-        lo_hi_writeq(nvmeq-&gt;cq_dma_addr, dev-&gt;bar + NVME_REG_ACQ);</div>
<div class="line">+        writeq(nvmeq-&gt;sq_dma_addr, dev-&gt;bar + NVME_REG_ASQ);</div>
<div class="line">+        writeq(nvmeq-&gt;cq_dma_addr, dev-&gt;bar + NVME_REG_ACQ);</div>
<div class="line"> </div>
<div class="line">         result = nvme_enable_ctrl(&amp;dev-&gt;ctrl);</div>
<div class="line">         <span class="keywordflow">if</span> (result)</div>
<div class="line">@@ -2501,7 +2501,7 @@ <span class="keyword">static</span> <span class="keywordtype">int</span> nvme_pci_enable(<span class="keyword">struct</span> nvme_dev *dev)</div>
<div class="line">         <span class="keywordflow">if</span> (result &lt; 0)</div>
<div class="line">                 <span class="keywordflow">return</span> result;</div>
<div class="line"> </div>
<div class="line">-        dev-&gt;ctrl.cap = lo_hi_readq(dev-&gt;bar + NVME_REG_CAP);</div>
<div class="line">+        dev-&gt;ctrl.cap = readq(dev-&gt;bar + NVME_REG_CAP);</div>
<div class="line"> </div>
<div class="line">         dev-&gt;q_depth = min_t(<a class="code hl_typedefRef" href="../../../driver/d0/dfa/group__iav-typedef.html#ga10e94b422ef0c20dcdec20d31a1f5049">u32</a>, NVME_CAP_MQES(dev-&gt;ctrl.cap) + 1,</div>
<div class="line">                                 io_queue_depth);</div>
<div class="line">@@ -2868,7 +2868,7 @@ <span class="keyword">static</span> <span class="keywordtype">int</span> nvme_pci_reg_write32(<span class="keyword">struct</span> nvme_ctrl *ctrl, <a class="code hl_typedefRef" href="../../../driver/d0/dfa/group__iav-typedef.html#ga10e94b422ef0c20dcdec20d31a1f5049">u32</a> off, <a class="code hl_typedefRef" href="../../../driver/d0/dfa/group__iav-typedef.html#ga10e94b422ef0c20dcdec20d31a1f5049">u32</a> val)</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">int</span> nvme_pci_reg_read64(<span class="keyword">struct</span> nvme_ctrl *ctrl, <a class="code hl_typedefRef" href="../../../driver/d0/dfa/group__iav-typedef.html#ga10e94b422ef0c20dcdec20d31a1f5049">u32</a> off, <a class="code hl_typedefRef" href="../../../driver/d0/dfa/group__iav-typedef.html#gad758b7a5c3f18ed79d2fcd23d9f16357">u64</a> *val)</div>
<div class="line"> {</div>
<div class="line">-        *val = lo_hi_readq(to_nvme_dev(ctrl)-&gt;bar + off);</div>
<div class="line">+        *val = readq(to_nvme_dev(ctrl)-&gt;bar + off);</div>
<div class="line">         <span class="keywordflow">return</span> 0;</div>
<div class="line"> }</div>
<div class="ttc" id="agroup__iav-typedef_html_ga10e94b422ef0c20dcdec20d31a1f5049"><div class="ttname"><a href="../../../driver/d0/dfa/group__iav-typedef.html#ga10e94b422ef0c20dcdec20d31a1f5049">u32</a></div><div class="ttdeci">unsigned int u32</div></div>
<div class="ttc" id="agroup__iav-typedef_html_gad758b7a5c3f18ed79d2fcd23d9f16357"><div class="ttname"><a href="../../../driver/d0/dfa/group__iav-typedef.html#gad758b7a5c3f18ed79d2fcd23d9f16357">u64</a></div><div class="ttdeci">unsigned long long u64</div></div>
</div><!-- fragment --><p >Users will then notice that the NVMe controller ceases to function properly: </p><div class="fragment"><div class="line">nvme nvme0: pci function 0000:05:00.0</div>
<div class="line">nvme 0000:05:00.0: enabling device (0000 -&gt; 0002)</div>
<div class="line">sdhci: Secure Digital Host Controller Interface driver</div>
<div class="line">sdhci: Copyright(c) Pierre Ossman</div>
<div class="line">irq 48: nobody cared (try booting with the &quot;irqpoll&quot; option)</div>
<div class="line">CPU: 0 PID: 197 Comm: kworker/u4:2 Tainted: G           O      5.15.108-rt61 <span class="preprocessor">#2</span></div>
<div class="line">Hardware <a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a25d22ecc7e656d2c59332072684e8766">name</a>: Ambarella CV5 TIMN Board (DT)</div>
<div class="line">Workqueue: events_unbound async_run_entry_fn</div>
<div class="line">Call trace:</div>
<div class="line">...</div>
<div class="line">nvme nvme0: I/O 16 QID 0 timeout, disable controller</div>
<div class="line">nvme nvme0: Device shutdown incomplete; abort shutdown</div>
<div class="line">nvme nvme0: Identify Controller failed (-4)</div>
<div class="line">nvme nvme0: Removing after probe failure status: -5</div>
<div class="ttc" id="acJSON_8h_html_a25d22ecc7e656d2c59332072684e8766"><div class="ttname"><a href="../../../library/d1/d82/cJSON_8h.html#a25d22ecc7e656d2c59332072684e8766">name</a></div><div class="ttdeci">const char *const name</div></div>
</div><!-- fragment --><p >Users can also utilize the Ambarella <code>pci-amba-test</code> to validate the presence of this issue: </p><div class="fragment"><div class="line">modified   drivers/misc/pci_endpoint_amba_test.c</div>
<div class="line">@@ -154,18 +154,18 @@ pci_endpoint_amba_test_writel(<span class="keyword">struct</span> pci_endpoint_amba_test *test, <a class="code hl_typedefRef" href="../../../driver/d0/dfa/group__iav-typedef.html#ga10e94b422ef0c20dcdec20d31a1f5049">u32</a> offset,</div>
<div class="line">    writel(value, test-&gt;base + offset);</div>
<div class="line"> }</div>
<div class="line"> </div>
<div class="line">-<span class="keyword">static</span> <span class="keyword">inline</span> <a class="code hl_typedefRef" href="../../../driver/d0/dfa/group__iav-typedef.html#ga10e94b422ef0c20dcdec20d31a1f5049">u32</a></div>
<div class="line">-pci_endpoint_amba_test_bar_readl(<span class="keyword">struct</span> pci_endpoint_amba_test *test, <span class="keywordtype">int</span> bar,</div>
<div class="line">+<span class="keyword">static</span> <span class="keyword">inline</span> <a class="code hl_typedefRef" href="../../../driver/d0/dfa/group__iav-typedef.html#gad758b7a5c3f18ed79d2fcd23d9f16357">u64</a></div>
<div class="line">+pci_endpoint_amba_test_bar_readq(<span class="keyword">struct</span> pci_endpoint_amba_test *test, <span class="keywordtype">int</span> bar,</div>
<div class="line">                 <span class="keywordtype">int</span> offset)</div>
<div class="line"> {</div>
<div class="line">-   <span class="keywordflow">return</span> readl(test-&gt;bar[bar] + offset);</div>
<div class="line">+   <span class="keywordflow">return</span> readq(test-&gt;bar[bar] + offset);</div>
<div class="line"> }</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span></div>
<div class="line">-pci_endpoint_amba_test_bar_writel(<span class="keyword">struct</span> pci_endpoint_amba_test *test, <span class="keywordtype">int</span> bar,</div>
<div class="line">-                 <a class="code hl_typedefRef" href="../../../driver/d0/dfa/group__iav-typedef.html#ga10e94b422ef0c20dcdec20d31a1f5049">u32</a> offset, <a class="code hl_typedefRef" href="../../../driver/d0/dfa/group__iav-typedef.html#ga10e94b422ef0c20dcdec20d31a1f5049">u32</a> value)</div>
<div class="line">+pci_endpoint_amba_test_bar_writeq(<span class="keyword">struct</span> pci_endpoint_amba_test *test, <span class="keywordtype">int</span> bar,</div>
<div class="line">+                 <a class="code hl_typedefRef" href="../../../driver/d0/dfa/group__iav-typedef.html#ga10e94b422ef0c20dcdec20d31a1f5049">u32</a> offset, <a class="code hl_typedefRef" href="../../../driver/d0/dfa/group__iav-typedef.html#gad758b7a5c3f18ed79d2fcd23d9f16357">u64</a> value)</div>
<div class="line"> {</div>
<div class="line">-   writel(value, test-&gt;bar[bar] + offset);</div>
<div class="line">+   writeq(value, test-&gt;bar[bar] + offset);</div>
<div class="line"> }</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">static</span> irqreturn_t pci_endpoint_amba_test_irqhandler(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *dev_id)</div>
<div class="line">@@ -288,7 +288,7 @@ <span class="keyword">static</span> <span class="keywordtype">bool</span> pci_endpoint_amba_test_bar(<span class="keyword">struct</span> pci_endpoint_amba_test *test,</div>
<div class="line">                       <span class="keyword">enum</span> pci_barno barno)</div>
<div class="line"> {</div>
<div class="line">    <span class="keywordtype">int</span> j;</div>
<div class="line">-   <a class="code hl_typedefRef" href="../../../driver/d0/dfa/group__iav-typedef.html#ga10e94b422ef0c20dcdec20d31a1f5049">u32</a> val;</div>
<div class="line">+   <a class="code hl_typedefRef" href="../../../driver/d0/dfa/group__iav-typedef.html#gad758b7a5c3f18ed79d2fcd23d9f16357">u64</a> val;</div>
<div class="line">    <span class="keywordtype">int</span> size;</div>
<div class="line">    <span class="keyword">struct </span>pci_dev *pdev = test-&gt;pdev;</div>
<div class="line"> </div>
<div class="line">@@ -301,11 +301,11 @@ <span class="keyword">static</span> <span class="keywordtype">bool</span> pci_endpoint_amba_test_bar(<span class="keyword">struct</span> pci_endpoint_amba_test *test,</div>
<div class="line">        size = 0x4;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (j = 0; j &lt; size; j += 4)</div>
<div class="line">-       pci_endpoint_amba_test_bar_writel(test, barno, j, 0xA0A0A0A0);</div>
<div class="line">+       pci_endpoint_amba_test_bar_writeq(test, barno, j, 0xA0A0A0A0A0A0A0A0);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (j = 0; j &lt; size; j += 4) {</div>
<div class="line">-       val = pci_endpoint_amba_test_bar_readl(test, barno, j);</div>
<div class="line">-       <span class="keywordflow">if</span> (val != 0xA0A0A0A0)</div>
<div class="line">+       val = pci_endpoint_amba_test_bar_readq(test, barno, j);</div>
<div class="line">+       <span class="keywordflow">if</span> (val != 0xA0A0A0A0A0A0A0A0)</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
</div><!-- fragment --><p> When running <code>amba-pcitest -b 0</code>, users can see the following: </p><div class="fragment"><div class="line"><span class="preprocessor"># amba-pcitest -b 0</span></div>
<div class="line">BAR0            NOT OKAY</div>
</div><!-- fragment --><p> This also implies that attempts to access the 64-bit bar will be unsuccessful.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
PCIe Ethernet:</h2>
<p >Some drivers for PCIe Ethernet are already in the kernel. The two drivers below are selected by default.</p>
<div class="fragment"><div class="line">build $ make cv5_ipcam_config</div>
<div class="line">build $ make defconfig_public_linux</div>
<div class="line">build $ make menuconfig_public_linux</div>
<div class="line">       Device Drivers  ---&gt;</div>
<div class="line">         [*] Network device support  ---&gt;</div>
<div class="line">           [*]   Ethernet driver support  ---&gt;</div>
<div class="line">              [*]   aQuantia devices</div>
<div class="line">              &lt;M&gt;     aQuantia AQtion(tm) Support</div>
<div class="line">              [*]   Intel devices</div>
<div class="line">              &lt;M&gt;     Intel(R) 10GbE PCI Express adapters support</div>
</div><!-- fragment --><p >After building the binary and flashing it to the EVK board, the command below can be used to enable the hardware.</p><ul>
<li><p class="startli">Intel® PCIe Ethernet card</p>
<p class="startli">board # modprobe ixgbe InterruptThrottleRate=1 IntMode=0</p>
</li>
<li>Marvel PCIe Ethernet card board # modprobe atlantic aq_itr=1</li>
</ul>
<p >The table below provides PCIe Ethernet performance data: </p><table class="doxtable">
<tr>
<th><div style="width:240px"><b>Connection</b></div> </th><th><div style="width:240px"><b>Throughput (Gbits/s)</b></div> </th></tr>
<tr>
<td>PC &lt;-&gt; CV5 Timn </td><td>9.38 </td></tr>
<tr>
<td>CV5 Timn &lt;-&gt; CV5 Timn </td><td>3.71 </td></tr>
</table>
<p><br  />
</p>
<h1><a class="anchor" id="autotoc_md11"></a>
RC mode:</h1>
<p >Users can refer to [Wikipedia] (<a href="https://www.wikiwand.com/en/Root_complex">https://www.wikiwand.com/en/Root_complex</a>) for details.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Troubleshooting:</h2>
<h3><a class="anchor" id="autotoc_md13"></a>
RC often gets hung when read / write endpoints' BAR / CFG</h3>
<p >If users are testing a new board with a PCIe controller acting as either an RC or EP, and you encountered the issue mentioned in the title, ensure that the signal lengths of the PCIe connector's P and N are the same. If they are different, prioritize fixing this issue by replacing the connector with one which has the same length.</p>
<h3><a class="anchor" id="autotoc_md14"></a>
Downstream EP devices cannot be recongized or are not functioning:</h3>
<ul>
<li>If using a CV5 / CV52 EVK, verify that the PCIe switch is attached to the board.</li>
</ul>
<p > <img src="../../switch.jpg" alt="" class="inline" title="switch"/>   </p>
<ul>
<li>If the PCIe switch does not exist, enable CONFIG_AMBOOT_PCIE_MODE_RC_QUIRK(CONFIG_AMBOOT_PCIE0/1/2_MODE_RC_QUIRK for CV3) under the Ambarella software development kit (SDK).</li>
<li>If the steps above do not resolve the issue, check the PCIe status register. PCIe status reg:<ul>
<li>CV5: devmem 0x20e0024198</li>
<li>CV3:<ul>
<li>PCIe0: devmem 0xffe00241ac</li>
<li>PCIe1: devmem 0xffe00241b0</li>
<li>PCIe2: devmem 0xffe00241b4</li>
</ul>
</li>
<li>CV72: devmem 0xffe003e1ac</li>
</ul>
</li>
</ul>
<p >If all values are 0, verify that the PCIe controller driver has been probed. In SDK 2.0, the CV52 PCIe has not been checked because its compatible is "cdns,cdns-pcie-host", but the driver uses "ambarella,cdns-pcie-host". As a result, the driver is not probed and the register receives all 0 values. Update the compatible to "ambarella,cnds-pcie-host" and try again.</p>
<p >Get bit [3:2]. If the value is not 0b11 (linkup completed), it indicates that the controller linkup has not succeeded. It is possible that some SoC pins are broken. Some CV5 boards have this issue; if so, request a new CV5 board.</p>
<p >If the status register is functional, verify that the PCIe slot powers on. For example, the CV5 EVK uses a PCA953x GPIO 6 for slot power control. If the user's GPIO setting is incorrect, and the slot does not have power, the endpoint cannot be recongized.</p>
<h1><a class="anchor" id="autotoc_md15"></a>
EP mode:</h1>
<p >Ambarella's PCIe controller can function as a regular endpoint.</p>
<h3><a class="anchor" id="autotoc_md16"></a>
As an EP, rework is required.</h3>
<h4><a class="anchor" id="autotoc_md17"></a>
CV3 and CV5:</h4>
<p >For the CV3 bring-up board (BUB): pull up U38.47 to SYS_VCC1V8 with 10 K. Pull up U38.46 to SYS_VCC1V8 with 10 K. Pull up U38.44 to SYS_VCC1V8 with 10 K.</p>
<p >For the CV5 BUB:</p>
<ol type="1">
<li>Pull up U60.pin37 (PCIE_PERST_N) to SYS_VCC1V8 with 10 K.</li>
<li><p class="startli">The CV5 BUB default is as follows: (R59,R61 is fitted and R62,R63 is removed). (XXX: this step should only be required if the PC is the root complex).</p>
<p class="startli">  Remove R86, R88, R87, and R90, then wire two lines as shown in the pictures below to the user's external clock from the PCIe connector: <img src="../../cv5_ep_01.png" alt="" class="inline" title="cv5 ep.png"/>    <img src="../../cv5_ep_02.png" alt="" class="inline" title="cv5 ep.png"/>   </p>
</li>
</ol>
<h3><a class="anchor" id="autotoc_md18"></a>
CV72 EP Mode:</h3>
<p >If users set up the EP (CV72) after the RC boots up (which is the recommended method), they can ignore this section. The rest of this section is only for situations where the EP is configured before RC bootup.</p>
<p >Unlike CV3 / CV5, the CV72 EVK does not include level shift. Perst is asserted when the RC links up and some registers, such as the EP trans IB register, are cleared.</p>
<p >To fix this issue, Perst must be disabled. This can be performed, for example, by removing R1125 from the CV72 EVK. Note that with this rework, if CV72 functions as an RC, the endpoints may malfunction due to missing fundmental resets. For example, NVMe will receive a timeout when reading / writing.</p>
<p >Users should only disable Perst (remove R1125 or add a diode) when CV72 functions as an EP and configures its EPF before RC bootup.</p>
<h2><a class="anchor" id="autotoc_md19"></a>
Rework may be required if a PC is used as the RC.</h2>
<p >If the user wants to use a PC as the RC and the Ambarella chip's PCIe controller as the EP, the EP must use the RC's clock source. To find the root cause, users can refer to <a href="../../xxx/arm/ambarella/pci/verify-soc-interconnect-via-pci.html">here</a>.</p>
<h3><a class="anchor" id="autotoc_md20"></a>
CV3:</h3>
<p >CV3 integrates three PCIe controllers: PCIe0, PCIe1, and PCIe2. To configure the connections for the BUB's PCIe2, follow the steps below:</p><ol type="1">
<li>Disconnect resistors R411, R413, R414, and R415.</li>
<li>Connect the A13 and A14 pins on the PCIe2 connector (PCIe Port-2) to CV3:<ul>
<li>Connect A13 to the PCIEP2_CK_REFREFCLK_P clock.</li>
<li>Connect A14 to the PCIEP2_CK_REFREFCLK_N clock. Refer to the images below for more information. <img src="../../cv3_pcie2_external_refclk0.png" alt="" class="inline" title="cv3 pcie2 external refclk"/>    <img src="../../cv3_pcie2_external_refclk.png" alt="" class="inline" title="cv3 pcie2 external refclk"/>   </li>
</ul>
</li>
</ol>
<p >For PCIe0, follow the steps below to modify the connections:</p><ol type="1">
<li>Disconnect resistors R401, R402, R403, and R405.</li>
<li>Connect the A13 and A14 pins on the PCIe0 connector (PCIe Port-0) to CV3:<ul>
<li>Connect A13 to the PCIEP0_REFCLK_P (R401) clock.</li>
<li>Connect A14 to the PCIEP0_REFCLK_N (R402) clock.</li>
</ul>
</li>
</ol>
<p >For PCIe1, follow the steps below to modify the connections:</p><ol type="1">
<li>Disconnect R406, R407, R408, and R409.</li>
<li>Connect the A13 and A14 pins on the PCIe1 connector (PCIe Port-1) to CV3:<ul>
<li>Connect A13 to the PCIEP1_REFCLK_P (R406) clock.</li>
<li>Connect A14 to the PCIEP1_REFCLK_N (R407) clock.</li>
</ul>
</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>When connecting the reference clock, ensure that it is connected to the end of the original resistor that is furthest from the clock chip: <img src="../../this_side.jpg" alt="" title="this_side.jpg" width="500" class="inline"/></dd></dl>
<h3><a class="anchor" id="autotoc_md21"></a>
CV72:</h3>
<p >CV72 EVK (Ga): <img src="../../cv72_ep_connector_clock.png" alt="" class="inline" title="cv72 ep connector clock"/>    <img src="../../cv72_ep_connector_clock2.png" alt="" class="inline" title="cv72 ep connector clock"/>   </p>
<h3><a class="anchor" id="autotoc_md22"></a>
CV5:</h3>
<p >CV5 performs similar rework to CV3 / CV72.</p>
<h1><a class="anchor" id="autotoc_md23"></a>
Use I2C to read / write the clock generator on the board.</h1>
<dl class="section note"><dt>Note</dt><dd>The clock generator is located on the board rather than on the chip.</dd></dl>
<ul>
<li>All Shanghai EVKs can use I2C to read / write the clock generator / PCIe switch, for example, to disable the clock.</li>
<li>Taiwan CV72 and CV5 BUBs have no such support.</li>
</ul>
<p >The Taiwan CV3 BUB supports I2C clock generator read / write.</p>
<h1><a class="anchor" id="autotoc_md24"></a>
Disable unused lanes:</h1>
<p >Users may have a variety of reasons for preferring to use a single lane, even if the SoC provides four PCIe lanes. For instance, in certain cases, users may only require single-lane throughput for specific applications, such as serial adanced technology attachment (SATA) controllers.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
AMBoot:</h2>
<div class="fragment"><div class="line">From 612aa5a822429c0160210b5741e0d39d0e3b30f0 Mon Sep 17 00:00:00 2001</div>
<div class="line">From: Li Chen &lt;lchen@ambarella.com&gt;</div>
<div class="line">Date: Wed, 9 Mar 2022 17:23:26 +0800</div>
<div class="line">Subject: [PATCH] limit PCIe controller<span class="stringliteral">&#39;s lane to single</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">Signed-off-by: Li Chen &lt;lchen@ambarella.com&gt;</span></div>
<div class="line"><span class="stringliteral">Change-Id: I93cef1542f444b700352be0c9ac7631b7d6160ca</span></div>
<div class="line"><span class="stringliteral">---</span></div>
<div class="line"><span class="stringliteral"> src/bld/main.c | 20 ++++++++++++++++++++</span></div>
<div class="line"><span class="stringliteral"> 1 file changed, 20 insertions(+)</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">diff --git a/src/bld/main.c b/src/bld/main.c</span></div>
<div class="line"><span class="stringliteral">index 4251c899..920ce073 100644</span></div>
<div class="line"><span class="stringliteral">--- a/src/bld/main.c</span></div>
<div class="line"><span class="stringliteral">+++ b/src/bld/main.c</span></div>
<div class="line"><span class="stringliteral">@@ -57,6 +57,24 @@ static const char *AMBOOT_LOGO =                     \</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">+#include &lt;ambhw/pcie.h&gt;</span></div>
<div class="line"><span class="stringliteral">+#include &lt;ambhw/idc.h&gt;</span></div>
<div class="line"><span class="stringliteral">+void limit_pcie_lane_to_single()</span></div>
<div class="line"><span class="stringliteral">+{</span></div>
<div class="line"><span class="stringliteral">+   u32 tmp = 0;</span></div>
<div class="line"><span class="stringliteral">+   pca9539_set_gpio(IDC3, EXGPIO6_PCIESLOT_PWERON, 0);</span></div>
<div class="line"><span class="stringliteral">+   pca9539_set_gpio(IDC3, EXGPIO5_PCIECLK_EN, 0);</span></div>
<div class="line"><span class="stringliteral">+</span></div>
<div class="line"><span class="stringliteral">+   tmp = readl(PCIEC_CTRL1_REG) &amp; (~(1 &lt;&lt; 19)) &amp; (~(1 &lt;&lt; 20));</span></div>
<div class="line"><span class="stringliteral">+   writel(PCIEC_CTRL1_REG, tmp);</span></div>
<div class="line"><span class="stringliteral">+</span></div>
<div class="line"><span class="stringliteral">+   pca9539_set_gpio(IDC3, EXGPIO6_PCIESLOT_PWERON, 1);</span></div>
<div class="line"><span class="stringliteral">+   pca9539_set_gpio(IDC3, EXGPIO5_PCIECLK_EN, 1);</span></div>
<div class="line"><span class="stringliteral">+</span></div>
<div class="line"><span class="stringliteral">+   tmp = readl(PCIEC_STATUS_REG);</span></div>
<div class="line"><span class="stringliteral">+   printf(&quot;pcie link width: 0x%x%x&quot;, tmp &amp; (1 &lt;&lt; 5), tmp &amp; (1 &lt;&lt; 4));</span></div>
<div class="line"><span class="stringliteral">+}</span></div>
<div class="line"><span class="stringliteral">+</span></div>
<div class="line"><span class="stringliteral"> int main(void)</span></div>
<div class="line"><span class="stringliteral"> {</span></div>
<div class="line"><span class="stringliteral">    u32 recovery_mode = (amboot_recovery_boot[0] == BAKFW_MAGIC);</span></div>
<div class="line"><span class="stringliteral">@@ -78,6 +96,8 @@ int main(void)</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    watchdog_init();</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">+   limit_pcie_lane_to_single();</span></div>
<div class="line"><span class="stringliteral">+</span></div>
<div class="line"><span class="stringliteral"> #if defined(AMBOOT_DEV_USBDL_MODE)</span></div>
<div class="line"><span class="stringliteral">    usb_boot();</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">--</span></div>
<div class="line"><span class="stringliteral">2.35.1</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md26"></a>
Linux kernel:</h2>
<div class="fragment"><div class="line">--- a/drivers/phy/cadence/phy-cadence-torrent.c</div>
<div class="line">+++ <a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a>/drivers/phy/cadence/phy-cadence-torrent.c</div>
<div class="line">@@ -222,6 +222,7 @@</div>
<div class="line"> </div>
<div class="line"> <span class="comment">/* PHY PCS common registers */</span></div>
<div class="line"><span class="preprocessor"> #define PHY_PIPE_CMN_CTRL1     0x0000U</span></div>
<div class="line">+#define PHY_PIPE_LANE_DSBL     0x0005U</div>
<div class="line"><span class="preprocessor"> #define PHY_PLL_CFG            0x000EU</span></div>
<div class="line"><span class="preprocessor"> #define PHY_PIPE_USB3_GEN2_PRE_CFG0    0x0020U</span></div>
<div class="line"><span class="preprocessor"> #define PHY_PIPE_USB3_GEN2_POST_CFG0   0x0022U</span></div>
<div class="line">@@ -1939,6 +1940,10 @@ <span class="keyword">static</span> <span class="keywordtype">int</span> cdns_torrent_phy_init(<span class="keyword">struct</span> phy *phy)</div>
<div class="line">     */</div>
<div class="line">    regmap = cdns_phy-&gt;regmap_phy_pcs_lane_cdb[inst-&gt;mlane];</div>
<div class="line">    regmap_write(regmap, 0x0013U, 0x1111);</div>
<div class="line">+</div>
<div class="line">+    regmap = cdns_phy-&gt;regmap_phy_pcs_common_cdb;</div>
<div class="line">+   regmap_write(regmap, 0x0005U, 0xFE);<span class="comment">// only enable lane 0</span></div>
<div class="line">+    <span class="comment">//regmap_write(regmap, 0x0005U, 0xFC);// enable lane 0 and 1</span></div>
<div class="line"><span class="preprocessor"> #endif</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a> 59060c2101fe7..a532ce93a28dd</div>
<div class="line">--- a/drivers/reset/reset-amba-cdns-phy.c</div>
<div class="line">+++ <a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a>/drivers/reset/reset-amba-cdns-phy.c</div>
<div class="line">@@ -39,6 +39,8 @@</div>
<div class="line"><span class="preprocessor"> #define PCIEC_APB_CORE_RATIO_4         (4 &lt;&lt; 9)</span></div>
<div class="line"><span class="preprocessor"> #define PCIEC_APB_CORE_RATIO_MASK      GENMASK(13, 9)</span></div>
<div class="line"><span class="preprocessor"> #define PCIEC_MISC_RESET           GENMASK(7, 0)</span></div>
<div class="line">+#define PCIEC_GEN_RESET            GENMASK(18, 17)</div>
<div class="line">+#define PCIEC_LANE_RESET           GENMASK(20, 19)</div>
<div class="line"> </div>
<div class="line"> enum {</div>
<div class="line">    PMA_CTRL_REG = 0,</div>
<div class="line">@@ -97,6 +99,8 @@ <span class="keyword">static</span> <span class="keywordtype">int</span> amba_phyrst_pcie_deassert(<span class="keyword">struct</span> reset_controller_dev *rcdev, unsigne</div>
<div class="line">    <span class="keywordflow">case</span> CDSN_PHY_LINK_RESET:</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> CDSN_PHY_RESET:</div>
<div class="line">+        regmap_clear_bits(phyrst-&gt;regmap, phyrst-&gt;offset[C_CTRL_REG], PCIEC_GEN_RESET);</div>
<div class="line">+        regmap_clear_bits(phyrst-&gt;regmap, phyrst-&gt;offset[C_CTRL_REG], PCIEC_LANE_RESET);</div>
<div class="line">        regmap_clear_bits(phyrst-&gt;regmap, phyrst-&gt;offset[P_CTRL_REG], PCIEP_PHY_RESET(phy_id));</div>
<div class="line">        regmap_clear_bits(phyrst-&gt;regmap, phyrst-&gt;offset[C_CTRL_REG], PCIEC_MISC_RESET);</div>
<div class="line">        regmap_set_bits(phyrst-&gt;regmap, phyrst-&gt;offset[C_CTRL_REG], PCIEC_LINK_TRAIN_EN);</div>
<div class="ttc" id="acJSON_8h_html_a1a175e87536301df98c805ac0636ad7c"><div class="ttname"><a href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a></div><div class="ttdeci">const cJSON *const b</div></div>
</div><!-- fragment --><p >Users can check the PCIe status register to see if the lanes are limited to a single lane, using CV5 for an example: devmem 0x20e0024198</p><ul>
<li>if <a class="elRef" href="../../../library/d3/d5a/group__iav-common-helper.html#ga3a8ea58898cb58fc96013383d39f482c">BIT(5:4)</a> is 0b00 -&gt; x1</li>
<li>if <a class="elRef" href="../../../library/d3/d5a/group__iav-common-helper.html#ga3a8ea58898cb58fc96013383d39f482c">BIT(5:4)</a> is 0b01 -&gt; x2</li>
<li>if <a class="elRef" href="../../../library/d3/d5a/group__iav-common-helper.html#ga3a8ea58898cb58fc96013383d39f482c">BIT(5:4)</a> is 0b10 -&gt; x4</li>
</ul>
<h1><a class="anchor" id="autotoc_md27"></a>
Utilizing Alternate General Purpose Input / Output (GPIO) for Power Provision</h1>
<p ><b>Depending on the specific board design</b>, it may be necessary to supply power to the slot during the PCIe controller boot-on process. This can be verified within AMBoot, for instance, if users are utilizing GPIO 68 to manage the power for the slot. </p><div class="fragment"><div class="line">amboot&gt; gpio hw 68 0 # operate exclusively as a GPIO, instead of repurposing it <span class="keywordflow">for</span> alternative functions</div>
<div class="line">amboot&gt; gpio set 68 # pull up</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
