<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Video: ADVANCED - Multi-VIN &amp; Multi-Channel</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<link rel="search" href="../../search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Video"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-ambarella.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../Ambarella.png"/></td>
  <td id="projectalign">
   <div id="projectname">Video<span id="projectnumber">&#160;Cooper_1.6.0 (CV72 &amp; CV3) @ 2024.07.10 14:12:44</span>
   </div>
   <div id="projectbrief">placeholder</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d3/dc4/fd_adv_multi_vin.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">ADVANCED - Multi-VIN &amp; Multi-Channel </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="multi_vin_design_overview"></a>
1. Overview</h1>
<p >This document provides guidelines for the system and software design of multi-video input (VIN) channels, as well as implementation using the Ambarella CV5x / CV7x Flexible Linux Software Development Kit (SDK).<br  />
</p>
<p >Ambarella assumes that readers of this document have previously read and worked through the steps outlined in the Getting Started Guide document of the Ambarella CV5x / CV7x Flexible Linux Evaluation Kit (EVK).<br  />
</p>
<p >This chapter includes the following sections:<br  />
</p>
<ul>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_key_updates">1.1 Key Updates</a></li>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_uses_of_multi_vin">1.2 Uses of Multi-VIN</a></li>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_third_party_serdes_chips">1.3 Third-Party SERDES Chips</a></li>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_reference_kit">1.4 Reference Kit</a></li>
</ul>
<h2><a class="anchor" id="multi_vin_design_key_updates"></a>
1.1 Key Updates</h2>
<a class="anchor" id="key_updates_for_each_sdk_version"></a>
<table class="doxtable">
<caption>Key Updates</caption>
<tr>
<th>SDK Version </th><th>Date </th><th>Modification </th></tr>
<tr>
<td align="center">0.2 </td><td align="center">20190816 </td><td><ul>
<li>Revised for the CV5x Chip family </li>
</ul>
</td></tr>
<tr>
<td align="center">0.2.2 </td><td align="center">20211210 </td><td><ul>
<li>Added Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_dual_sensors_with_different_modes_from_single_serdes">2.4 Dual Sensors with Different Modes from Single SERDES</a> <br  />
</li>
<li>Added Section multi_vin_design_sensors_with_a_serdes_bridge <br  />
</li>
<li>Added Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_dual_sensors_with_different_modes_from_max9296">4.4 Dual Sensors with Different Modes from MAX9296</a> <br  />
 </li>
</ul>
</td></tr>
<tr>
<td align="center">0.5 </td><td align="center">20220114 </td><td><ul>
<li>Added Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_dual_channels_from_a_single_sensor_and_raw_data">2.5 Dual Channels from a Single Sensor and Raw Data</a> <br  />
</li>
<li>Added Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_dual_channels_from_a_single_sensor_with_dual_vsrc_ctx">2.6 Dual Channels from a Single Sensor with Dual Vsrc_ctx</a> <br  />
</li>
<li>Added Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_single_sensor_with_a_dual_vsrc_ctx">3.2.4 Single Sensor with a Dual Vsrc_ctx.</a> <br  />
</li>
<li>Updated Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_vsrc_to_channel">3.2.5 Vsrc to Channel</a> <br  />
</li>
<li>Added Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_dual_channels_from_the_sensor_and_the_yuv_raw_data">4.3 Dual Channels from the Sensor and the YUV Raw Data</a> <br  />
</li>
<li>Added Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_dual_channels_from_imx264_with_dual_vsrc_ctx">4.5 Dual Channels from IMX264 with Dual Vsrc_ctx</a> <br  />
</li>
<li>Added Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_multiple_yuv_input">4.7 Multiple YUV Input</a> <br  />
 </li>
</ul>
</td></tr>
<tr>
<td align="center">1.0 </td><td align="center">20220415 </td><td><ul>
<li>Added Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_cv52_multi_vin_design_kit">1.4.2 CV52 Multi-VIN Design Kit</a> <br  />
</li>
<li>Updated Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_quad_sensors_with_a_long_cable_through_max9296_4_1">4.1 Quad Sensors with a Long Cable through MAX9296</a> <br  />
 </li>
</ul>
</td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>The SDK versions listed in the above table reflect the current SDK version (x.x) or patch release (x.x.x). A patch number that is not sequential indicates that the previous patch release did not apply to this document.<br  />
</dd></dl>
<h2><a class="anchor" id="multi_vin_design_uses_of_multi_vin"></a>
1.2 Uses of Multi-VIN</h2>
<p >Most cameras come with a single VIN and sensor input equipped with a limited view and one lens, which is either a fixed or zoom lens. However, new market standards require more sophisticated cameras, such as those that include a wider viewfinder, multi-view stitching, and dual-view capabilities (to spare the expense of dual cameras).<br  />
</p>
<p >To perform these tasks, current camera products use either a field-programmable gate array (FGPA) to stitch multiple sensor inputs into one picture, then feed them into the system on chip (SoC), or come with multiple SoCs. With multiple SoCs, the camera controls multiple sensor inputs separately, and then stitches the video clips together using back-end decoding devices. However, these methods fail to meet all requirements of a multi-VIN design.<br  />
</p>
<p >To address these challenges, CV5x / CV7x support multiple independent sensors as multi-channel inputs (up to eight channels can be supported), as the CV5x /CV7x families of chips come equipped with more than one VIN controller. Using serializer / deserializer (SERDES) chips, such as the MAX9286 and MAX9296 from MAX, can support the multi-VIN design on CV5x / CV7x. CV5x /CV7x support independent automatic exposure (AE) / automatic white balance (AWB) / automatic focus (AF) (3A) control processes for each VIN. CV5x / CV7x encode different streams, using various parameters from each VIN, such as the frame rate, bit rate, and resolution. This enables the camera to function as if there are multiple independent cameras running within a single SoC. The following table lists the number of VIN controllers and the supported sensors for each chip in the CV5x / CV7x family.<br  />
</p>
<a class="anchor" id="number_of_vin_controllers_and_supported_sensors"></a>
<table class="doxtable">
<caption>Number of VIN Controllers and Supported Sensors.</caption>
<tr>
<th>SoC </th><th>VIN Controllers </th><th>Supported Independent Sensors </th><th>Supported Sensors (via SERDES) </th><th>Cameras </th></tr>
<tr>
<td align="center">CV5x </td><td align="center">14 </td><td align="center">4 </td><td align="center">up to 8 </td><td align="center">2 - 8 </td></tr>
<tr>
<td align="center">CV7x </td><td align="center">10 </td><td align="center">3 </td><td align="center">up to 6 </td><td align="center">2 - 6 </td></tr>
</table>
<p >Ambarella CV5x / CV7x also support the multi-VIN design for synchronizing super-wide angle views and 180° / 360° panoramic views. Synchronizing sensors is simple to perform because all sensor logic comes from the same SoC.<br  />
</p>
<p >Because of its many features, the Ambarella CV5x / CV7x multi-VIN design support several new camera models, such as the ATM camera, the super-wide-angle camera, and multiple cameras (with a long cable) shooting different views.<br  />
</p>
<h2><a class="anchor" id="multi_vin_design_third_party_serdes_chips"></a>
1.3 Third-Party SERDES Chips</h2>
<p >Using third-party SERDES chips, CV5x / CV7x can support additional sensors for multi-VIN designs. The following describes third-party deserializers and highlights the serializers that provide a bridge between the remote sensors and the deserializers.<br  />
</p>
<ul>
<li>The <b>MAX9296</b> deserializer receives the full high definition (FHD) video from up to two gigabit multimedia serial link (GMSL) serializers (such as MAX9295) through coaxial cables (up to 15 meters long). Each GMSL serializer connects to a single sensor.<br  />
</li>
<li><b>MAX9295:</b> This chip serves as a bridge between the remote sensor and MAX9296. It captures and serializes sensor data from a remote sensor before transmitting to MAX9296.<br  />
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>In order to maintain synchronization, the sensors connected to the same SERDES must have exactly the same resolution, frames per second (fps), and clock settings.</li>
</ul>
</dd></dl>
<h2><a class="anchor" id="multi_vin_design_reference_kit"></a>
1.4 Reference Kit</h2>
<p >The Ambarella CV5x / CV7x multi-VIN design kit enable developers to quickly create a line of differentiated multi-VIN products. This section shows the multi-VIN design kits for the chips in the CV5x / CV7x families.<br  />
</p>
<h3><a class="anchor" id="multi_vin_design_cv5_multi_vin_design_kit"></a>
1.4.1 CV5 Multi-VIN Design Kit</h3>
<p >CV5 supports 4x native VIN controllers. Through the mobile industry processor interface (MIPI®) virtual channel, it can be extended to 14x VIN controllers. CV5 can support various VIN interfaces including MIPI D/C-PHY, scalable low-voltage signaling (SLVS), and SLVS with embedded clock (SLVS-EC). MIPI and SLVS-EC interfaces can be up to 16 lanes. SLVS interface can be up to eight lanes. The following table lists various Ambarella VIN controller layouts.<br  />
</p>
<a class="anchor" id="cv5_vin_controller_layout"></a>
<table class="doxtable">
<caption>CV5 VIN Controller Layout.</caption>
<tr>
<th>VIN Slot </th><th>I2C Bus ID </th><th>VIN Controller ID </th><th>Type </th></tr>
<tr>
<td align="center" rowspan="6">SLVS + DPHY </td><td align="center" rowspan="6">3/4 </td><td align="center">8 </td><td align="center">Real </td></tr>
<tr>
<td align="center">9 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center">10 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center">11 </td><td align="center">Real </td></tr>
<tr>
<td align="center">12 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center">13 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center" rowspan="4">SLVS - EC </td><td align="center" rowspan="4">5 </td><td align="center">0 </td><td align="center">Real </td></tr>
<tr>
<td align="center">1 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center">2 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center">3 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center" rowspan="3">DCPHY 0 </td><td align="center" rowspan="3">5 </td><td align="center">0 </td><td align="center">Real </td></tr>
<tr>
<td align="center">1 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center">2 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center">DCPHY 0 (Cont'd) </td><td align="center"></td><td align="center">3 </td><td align="center">virtual </td></tr>
<tr>
<td align="center" rowspan="4">DCPHY 1 </td><td align="center" rowspan="4">1 </td><td align="center">4 </td><td align="center">Real </td></tr>
<tr>
<td align="center">5 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center">6 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center">7 </td><td align="center">Virtual </td></tr>
</table>
<p >Currently, CV5x supports a two to four multiple-VIN design through SERDES with the SLVS + DPHY VIN slot. The sensors must support a four-lane interface through either MIPI or SLVS. The following figure shows the sensor boards inserted into the SLVS + DPHY VIN slot on the CV5 Timn board.<br  />
</p>
<div class="image">
<img src="../../single_sensor_board_plug_in_the_cv5_timn_board.png" alt=""/>
<div class="caption">
Single Sensor Board Plug in the CV5 Timn Board.</div></div>
<h3><a class="anchor" id="multi_vin_design_cv52_multi_vin_design_kit"></a>
1.4.2 CV52 Multi-VIN Design Kit</h3>
<p >CV52 supports 4x native VIN controllers. Through the MIPI virtual channel, it can be extended to 14x VIN controllers. CV52 can support various VIN interfaces including MIPI D/C-PHY and SLVS. MIPI interfaces can be up to 16 lanes. SLVS interface can be up to eight lanes. The following table lists various Ambarella VIN controller layouts.<br  />
</p>
<a class="anchor" id="cv52_vin_controller_layout"></a>
<table class="doxtable">
<caption>CV52 VIN Controller Layout.</caption>
<tr>
<th>VIN Slot </th><th>I2C Bus ID </th><th>VIN Controller ID </th><th>Type </th></tr>
<tr>
<td align="center" rowspan="6">SLVS + DPHY </td><td align="center" rowspan="6">3/4 </td><td align="center">8 </td><td align="center">Real </td></tr>
<tr>
<td align="center">9 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center">10 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center">11 </td><td align="center">Real </td></tr>
<tr>
<td align="center">12 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center">13 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center" rowspan="4">DCPHY 0 </td><td align="center" rowspan="4">5 </td><td align="center">0 </td><td align="center">Real </td></tr>
<tr>
<td align="center">1 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center">2 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center">3 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center" rowspan="4">DCPHY 1 </td><td align="center" rowspan="4">1 </td><td align="center">4 </td><td align="center">Real </td></tr>
<tr>
<td align="center">5 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center">6 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center">7 </td><td align="center">Virtual </td></tr>
</table>
<p >Currently, CV52 supports two to four multiple-VIN designs through SERDES with SLVS + DPHY VIN slot. The sensors must support a four-lane interface through either MIPI or SLVS. The following figure shows the sensor boards inserted into the SLVS + DPHY VIN slot on the CV52 Zircon board. Compared with CV5, CV52 does not support SLVS-EC VIN interface.<br  />
</p>
<div class="image">
<img src="../../single_sensor_board_plug_in_the_cv52_zircon_board.png" alt=""/>
<div class="caption">
Single Sensor Board Plug in the CV52 zircon Board.</div></div>
<h3><a class="anchor" id="multi_vin_design_cv72_multi_vin_design_kit"></a>
1.4.3 CV72 Multi-VIN Design Kit</h3>
<p >CV72 supports 3x native VIN controllers. Through the MIPI virtual channel, it can be extended to 10x VIN controllers. CV72 can support various VIN interfaces including MIPI D/C-PHY and SLVS. MIPI interfaces can be up to 16 lanes. SLVS interface can be up to 8 lanes. The following table lists various Ambarella VIN controller layouts.<br  />
</p>
<a class="anchor" id="cv72_vin_controller_layout"></a>
<table class="doxtable">
<caption>CV72 VIN Controller Layout.</caption>
<tr>
<th>VIN Slot </th><th>I2C Bus ID </th><th>VIN Controller ID </th><th>Type </th></tr>
<tr>
<td align="center" rowspan="6">SLVS + DPHY </td><td align="center" rowspan="6">0 </td><td align="center">8 </td><td align="center">Real </td></tr>
<tr>
<td align="center">9 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center">10 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center">11 </td><td align="center">Real </td></tr>
<tr>
<td align="center">12 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center">13 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center" rowspan="4">DCPHY 0 </td><td align="center" rowspan="4">0 </td><td align="center">0 </td><td align="center">Real </td></tr>
<tr>
<td align="center">1 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center">2 </td><td align="center">Virtual </td></tr>
<tr>
<td align="center">3 </td><td align="center">Virtual </td></tr>
</table>
<p >Currently, CV72 supports two to three multiple-VIN design through SERDES with SLVS + DPHY VIN slot. The sensors must support a four-lane interface through either MIPI or SLVS. The following figure shows the sensor boards inserted into the SLVS + DPHY VIN slot on the CV72 Ga board. Compared with CV5, CV72 does not support SLVS-EC VIN interface, and CV72 removes DCPHY 1.<br  />
</p>
<div class="image">
<img src="../../single_sensor_board_plug_in_the_cv72_ga_board.png" alt=""/>
<div class="caption">
Single Sensor Board Plug in the CV72 Ga Board.</div></div>
<h3><a class="anchor" id="multi_vin_design_max9296_board"></a>
1.4.4 MAX9296 Board</h3>
<p >Because the MAX9296 board is designed to support up to four remote sensors via a coaxial cable, it includes two MAX9296 mounted on the board. Each MAX9296 is capable of connecting up to two remote sensors through the GMSL serializer. For more information about the reference kit board design, contact the Ambarella support team.<br  />
</p>
<p >The four coaxial cable ports are mounted on the reverse side of the MAX9296 board, as shown below.<br  />
</p>
<div class="image">
<img src="../../max9296_board_back_view_with_four_coaxial_cable_ports.png" alt=""/>
<div class="caption">
MAX9296 Board Back View with Four Coaxial Cable Ports.</div></div>
<p >The following figure shows the reference kit board MAX9296 + 4x (GMSL serializer MAX9295 + imx290 sensor) connected with a coaxial cable.<br  />
</p>
<div class="image">
<img src="../../four_sensors_with_a_coaxial_cable_max9296_4x_gmsl_serializer_imx290.png" alt=""/>
<div class="caption">
MAX9296 Board Back View with Four Coaxial Cable Ports.</div></div>
<p >The following figure shows the GMSL serializer MAX9295 plus a remote sensor reference kit with coaxial cables. With the long cable, the GMSL serializer MAX9295 with a remote sensor can capture images in different directions.<br  />
 </p><div class="image">
<img src="../../gmsl_serializer_max9295_plus_remote_sensor_with_a_coaxial_cable.png" alt=""/>
<div class="caption">
GMSL Serializer MAX9295 Plus Remote Sensor with a Coaxial Cable.</div></div>
<hr  />
<h1><a class="anchor" id="multi_vin_design_product_plan"></a>
2 Product Plan</h1>
<p >This chapter introduces the details of a potential product plan for a multi-VIN design with independent sensors, using different cable options.<br  />
</p>
<p >The chapter includes the following sections:<br  />
</p>
<ul>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_quad_sensors_with_a_long_cable_through_max9296">2.1 Quad Sensors with a Long Cable through MAX9296</a></li>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_quad_independent_sensors">2.2 Quad Independent Sensors</a></li>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_dual_channels_from_a_single_sensor">2.3 Dual Channels from a Single Sensor</a></li>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_dual_sensors_with_different_modes_from_single_serdes">2.4 Dual Sensors with Different Modes from Single SERDES</a></li>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_dual_channels_from_a_single_sensor_and_raw_data">2.5 Dual Channels from a Single Sensor and Raw Data</a></li>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_dual_channels_from_a_single_sensor_with_dual_vsrc_ctx">2.6 Dual Channels from a Single Sensor with Dual Vsrc_ctx</a></li>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_supported_sensors">2.7 Supported Sensors</a></li>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_stream_view">2.8 Stream View</a></li>
</ul>
<h2><a class="anchor" id="multi_vin_design_quad_sensors_with_a_long_cable_through_max9296"></a>
2.1 Quad Sensors with a Long Cable through MAX9296</h2>
<p >This section provides an outline for users who prefer to set up their quad sensors with long cables. In this design, four sensors are mounted on four GMSL serializer chips (such as MAX9296), respectively. Every two GMSL serializers connect to a single SERDES (two SERDES are required). The two SERDES directly connect to controllers VIN8 and VIN11.<br  />
</p>
<p >The following diagram shows the four quad sensors with a long cable design.<br  />
 </p><div class="image">
<img src="../../quad_sensors_with_long_cable_through_the_max9296_design_cv5x_cv7x.png" alt=""/>
<div class="caption">
Quad Sensors with Long Cable through the MAX9296 Design.</div></div>
<dl class="section user"><dt>Implementation:</dt><dd></dd></dl>
<ul>
<li>The four sensors can shoot in any direction, and the application can run 3A independently for these four sensor inputs.</li>
<li>Every two sensors (sensor A and B or sensor C and D) that connect to the same SERDES must be identical in resolution, fps, and image signal processor (ISP) pipeline.</li>
<li>The maximum resolution of each sensor is up to 1080p60.</li>
<li>The length of the cable can be up to 15 meters.</li>
<li>Every two GMSL serializers that connect to the same SERDES must be the same length. This keeps the sensor phase lock loop (PLL) clock synchronized.</li>
<li>Each sensor possesses two streams. The main stream is 1080p, and the second stream is a smaller resolution, 480p or common intermediate format (CIF).</li>
<li>There is no picture-stitching inside the image digital signal processing (IDSP) channel. Each sensor input must be either an individual stream or be a part of the combined view stream.</li>
</ul>
<dl class="section user"><dt>Product Plan:</dt><dd></dd></dl>
<ul>
<li>Electronic mirror, surround view, and four cameras in a single case.</li>
</ul>
<h2><a class="anchor" id="multi_vin_design_quad_independent_sensors"></a>
2.2 Quad Independent Sensors</h2>
<p >CV5x SoC includes fourteen VIN controllers, among which has four native VIN controllers. It can support quad independent sensors. Refer to the figure below for a diagram of the quad independent sensors. <br  />
</p>
<p >The four sensors can use up to a 4-lane interface (SLVS + DPHY, DCPHY 0, DCPHY 1), respectively.<br  />
</p>
<p >The sensor boards with quad independent sensors have an I2C mux multiplexed by these four sensors. If this is a configuration users want to run on the CV5 EVK board, follow the instructions through "menuconfig": <br  />
 For Cooper SDK Amba build: </p><div class="fragment"><div class="line">build$ make menuconfig</div>
<div class="line">       -&gt; drv_modules</div>
<div class="line">          -&gt; platform</div>
<div class="line">             -&gt; vin</div>
<div class="line">                sensor-<a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a01b4671c6b7cc8f831c951c000a37735">number</a>-choice@<span class="keyword">virtual</span> (drv_modules/platform/vin/sensors) (quad-sensor@<span class="keyword">virtual</span>)</div>
<div class="line">                (X) quad-sensor@virtual</div>
<div class="ttc" id="acJSON_8h_html_a01b4671c6b7cc8f831c951c000a37735"><div class="ttname"><a href="../../../library/d1/d82/cJSON_8h.html#a01b4671c6b7cc8f831c951c000a37735">number</a></div><div class="ttdeci">const char *const const double number</div></div>
</div><!-- fragment --><p> For Cooper SDK Yocto build: </p><div class="fragment"><div class="line">build$ make menuconfig</div>
<div class="line">       Main menu</div>
<div class="line">          -&gt; meta-ambabsp</div>
<div class="line">             -&gt; recipes-bsp</div>
<div class="line">                -&gt; sensor-<a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a01b4671c6b7cc8f831c951c000a37735">number</a>-choice@<span class="keyword">virtual</span> (meta-ambabsp/recipes-sensor)</div>
<div class="line">                   (X) quad-sensor@<span class="keyword">virtual</span></div>
</div><!-- fragment --><div class="image">
<img src="../../cv5_quad_independent_sensors.png" alt=""/>
<div class="caption">
Quad Independent Sensors.</div></div>
<dl class="section user"><dt>Implementation:</dt><dd></dd></dl>
<ul>
<li>Independent sensors with the 4-lane MIPI (or SLVS) interface.</li>
<li>Independent 3A parameters for four sensor inputs.</li>
<li>Independent VIN resolution and frame rate.</li>
<li>Independent HDR mode (linear + linear, 2X HDR + 2X HDR or linear + 2X HDR).</li>
<li>Application independently can enable / disable VIN0, VIN4, VIN8, and VIN11 dynamically.</li>
</ul>
<dl class="section user"><dt>Product Plan:</dt><dd>A wide-angle view camera that provides four different resolutions.</dd></dl>
<h2><a class="anchor" id="multi_vin_design_dual_channels_from_a_single_sensor"></a>
2.3 Dual Channels from a Single Sensor</h2>
<p >This section defines the design of dual channels from a single sensor.<br  />
</p>
<p >Both channels are captured from a single sensor with the same frame data. The DSP processes the frame data for each channel independently. For example, both channels can apply different lens distortion correction (LDC) types for wide-angle or fish-eye lenses.<br  />
</p>
<p >This is a special use case named “IDSP virtual channel”. For more information about “IDSP virtual channel”, refer to Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_idsp_virtual_channels">3.2.3 IDSP Virtual Channels</a>.</p>
<p >The following diagram shows the dual channels from the single sensor design.<br  />
 </p><div class="image">
<img src="../../dual_channels_from_the_single_sensor_design_cv5x_cv7x.png" alt=""/>
<div class="caption">
Dual Channels from the Single Sensor Design.</div></div>
<dl class="section user"><dt>Implementation:</dt><dd></dd></dl>
<ul>
<li>The maximum resolution of the sensor is up to 2592x1944 (5 MP).</li>
<li>The maximum throughput of the sensor is up to 2592x1944@30 in linear mode and 2592x1944@15 in 2X high dynamic range (HDR) modes.</li>
<li>The two channels have a different IDSP processing frame rate than the VIN frame rate.</li>
<li>One channel can have up to four canvases for four streams, and the main stream resolution is the same as the maximum VIN resolution of 2592x1944. The second stream is 480p or CIF. Both third and fourth streams are 720p.</li>
<li>The second channel includes multiple canvases, similar to the first channel and the multi-streams. The main stream resolution is up to 5 MP with a lower frame rate.</li>
<li>There is no picture stitched inside the DSP. Each channel must be an individual stream or a part of the combined view stream, either blended view or picture-in-picture (PIP) view.</li>
<li>If there is one canvas designed as the blended view or PIP view, the data from the two channels must run at the same frame rate.</li>
<li>Different CV5x / CV7x chip part support different encode performance combinations.</li>
</ul>
<dl class="section user"><dt>Product Plan:</dt><dd></dd></dl>
<ul>
<li>For products such as a doorbell camera, one channel can show either a rectilinear view captured from the lens center, or a panoramic view captured from the entire lens, for people detection and recognition. The other channel can show the rectilinear view captured from the lens bottom in order to perform object detection.</li>
<li>For particular consumer-type products, one channel can be downscaled from the original VIN resolution (&gt; 2 MP) to a smaller resolution, such as 2 MP for stream encoding. The other channel can be down-sampled from 30 fps to 1 fps for the MJPEG snapshot with the original VIN resolution.</li>
<li>For select professional products, dual channels double the total number of independent source buffers from four to eight, enabling the encoding of four or more different resolution streams.</li>
</ul>
<h2><a class="anchor" id="multi_vin_design_dual_sensors_with_different_modes_from_single_serdes"></a>
2.4 Dual Sensors with Different Modes from Single SERDES</h2>
<p >This section defines the design of dual sensors with different modes from a single SERDES. This is achieved based on the capability of the MIPI virtual channel supported by both SERDES and CV5x / CV7x.<br  />
</p>
<p >In this design, two sensors are mounted on two GMSL serializer chips (such as MAX9296) respectively. Each GMSL serializer connects to a single SERDES (two SERDES are required) with long cables. The two SERDES directly connect to controllers VIN8 and VIN9.<br  />
</p>
<p >The following diagram shows the two sensors with a long cable design.<br  />
 </p><div class="image">
<img src="../../two_sensors_with_long_cable_through_the_max9296_design_cv5x_cv7x.png" alt=""/>
<div class="caption">
Two Sensors with Long Cable Through the MAX9296 Design.</div></div>
<dl class="section user"><dt>Implementation</dt><dd></dd></dl>
<ul>
<li>The two sensors can shoot in any direction, and the application can run 3A independently for these two sensor inputs.</li>
<li>Each sensor can run different VIN modes. For example, one in linear mode, and the other in digital overlap (DOL) 2x HDR mode.</li>
<li>The length of the cable can be up to 15 meters.</li>
<li>There is no picture stitching inside the IDSP channel. Each sensor input must be either an individual stream or a part of the combined view stream.</li>
</ul>
<dl class="section user"><dt>Product Plan:</dt><dd></dd></dl>
<ul>
<li>Electronic mirror, surround view, and two cameras in a single case.</li>
</ul>
<h2><a class="anchor" id="multi_vin_design_dual_channels_from_a_single_sensor_and_raw_data"></a>
2.5 Dual Channels from a Single Sensor and Raw Data</h2>
<p >This section defines the design of dual channels from a single sensor and the raw data via direct memory input.<br  />
</p>
<p >One channel captures the frame data from a regular sensor input. The other channel captures the raw data fed by the user application through memory, which acquires the frame data from a device, such as the USB camera.<br  />
</p>
<p >The following shows the diagram of dual channels from a single sensor and the raw data:<br  />
 </p><div class="image">
<img src="../../dual_channels_from_a_single_sensor_and_raw_data_cv5x_cv7x.png" alt=""/>
<div class="caption">
Dual Channels from a Single Sensor and Raw Data.</div></div>
<dl class="section user"><dt>Implementation:</dt><dd></dd></dl>
<ul>
<li>The maximum resolution of the sensor input and raw data input is 1080p.</li>
<li>For sensor input, the maximum throughput is up to 1080p60 in linear mode and 1080p30 in 2X HDR mode.</li>
<li>For raw data input, the maximum frame rate cannot exceed the sensor input frame rate. For example, if the sensor input frame rate is 30 fps, the raw data feeding rate must be lower than 30 fps.</li>
<li>The format for raw data must be either the standard Bayer RGB format or the YUV422 format with UV interleaved.</li>
<li>Each channel can include three streams; the main and the third streams’ resolutions are both 1080p, and the second stream is smaller, such as 480p or CIF.</li>
<li>There is no picture stitched inside the DSP. Each channel must be an individual stream or a part of the combined view stream (either blended view or PIP view).</li>
<li>The application can feed raw data via “test_efm”, the standard unit test tool.</li>
<li>Different CV5x / CV7x chip parts support different encode performance combinations.</li>
</ul>
<dl class="section user"><dt>Product Plan:</dt><dd></dd></dl>
<p>Single sensor + USB camera, single optical sensor + thermal sensor.</p>
<h2><a class="anchor" id="multi_vin_design_dual_channels_from_a_single_sensor_with_dual_vsrc_ctx"></a>
2.6 Dual Channels from a Single Sensor with Dual Vsrc_ctx</h2>
<p >This section describes the design setup of dual channels from a single sensor with the dual vsrc_ctx. For more information about "vsrc_ctx", refer to Section multi_vin_design_single_sensor_with_a_dual_vsrc_ctx<br  />
</p>
<p >For the implementation of the dual vsrc_ctx, different sensor manufacturers may require different solutions. Additionally, the maximum number of supported vsrc_ctx depends on the sensor models. Currently, CV5x / CV7x support the following forms of dual vsrc_ctx solutions:<br  />
</p>
<ul>
<li>Some sensor models from Sony, such as IMX264 and IMX265, can support up to four vsrc_ctx. Users can opt to enable two or four of them. The sensor itself can automatically generate frame-interleaved frames with different vsrc_ctx. Each frame corresponding to a specific vsrc_ctx has a different pattern embedded in the first line of its data. CV5x / CV7x IDSP can dispatch them into different channels, according to their fixed patterns. The embedded frame pattern data will be cropped out by the IDSP.<br  />
</li>
</ul>
<dl class="section user"><dt>Implementation:</dt><dd></dd></dl>
<ul>
<li>The maximum-supported resolution of the sensor can be up to 3840x2160 (8 MP) depending on the specific chip specifications; only linear mode is supported. This feature requires the sensor support for multiple register groups of shutter / gain settings.</li>
<li>In linear mode, the maximum throughput of the sensor is 3840x2160@30.</li>
<li>With dual vsrc_ctx, the IDSP processing frame rate of these two channels must be 1/2 of the VIN frame rate. The frames of the sensor are divided into two groups, half-by-half. One is for channel 0; the other is for channel 1.</li>
<li>Each channel can have up to four canvases for four streams, and the main stream resolution is the same as the maximum VIN resolution. The second stream is 480p or CIF. Both third and fourth streams are 1080p.</li>
<li>There is no picture stitched inside the DSP. Each channel must be an individual stream or a part of the combined view stream (either blended view or PIP view).</li>
<li>Various CV5x / CV7x chip parts support different encode performance combinations.</li>
</ul>
<p >@Product Plan:</p>
<p >For some video content analysis (VCA) products, the application configures the long and short exposures interleaved frame-by-frame with two groups of different 3A settings. This process enables the application to achieve much larger long / short shutter ratios than the typical HDR ratio (16x or 32x).<br  />
</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This feature is highly dependent on the sensor register settings; it requires sensor support for multiple shutter / gain register groups.</li>
<li>Dual context from a single sensor uses one VIN interface; the application can connect the other sensor to another VIN interface.</li>
<li>There is no limitation for the sensor type or sensor mode for another VIN.</li>
</ul>
</dd></dl>
<h2><a class="anchor" id="multi_vin_design_supported_sensors"></a>
2.7 Supported Sensors</h2>
<p >This section provides information about the sensors supported for various multi-VIN designs.<br  />
</p>
<p >The two VIN controllers are limited by the total number of VIN lanes. The dual independent sensors use four lanes each; the sensor drivers must support all lanes.<br  />
</p>
<a class="anchor" id="supported_sensors_for_multi_vin_with_native_dual_vin_design"></a>
<table class="doxtable">
<caption>Supported Sensors for Multi-VIN with Native Dual VIN Design. </caption>
<tr>
<th>Sensor(4-lane MIPI or SLVS I/F) </th><th>Resolution(MP) </th><th>Native Dual Sensors </th><th>Notes </th></tr>
<tr>
<td align="center">IMX290 </td><td align="center">2.0 </td><td align="center">Yes </td><td>1: Lnear mode <br  />
 2: DOL 2X HDR mode </td></tr>
<tr>
<td align="center">IMX274 </td><td align="center">8.0 </td><td align="center">Yes </td><td>1: Lnear mode<br  />
 2: DOL 2X HDR mode </td></tr>
<tr>
<td align="center">IMX327 </td><td align="center">2.0 </td><td align="center">Yes </td><td>1: Lnear mode<br  />
 2: DOL 2X HDR mode </td></tr>
<tr>
<td align="center">IMX334 </td><td align="center">8.0 </td><td align="center">Yes </td><td>1: Lnear mode<br  />
 2: DOL 2X HDR mode </td></tr>
<tr>
<td align="center">IMX335 </td><td align="center">5.0 </td><td align="center">Yes </td><td>1: Lnear mode<br  />
 2: DOL 2X HDR mode </td></tr>
<tr>
<td align="center">IMX415 </td><td align="center">8.0 </td><td align="center">Yes </td><td>1: Lnear mode<br  />
 2: DOL 2X HDR mode </td></tr>
<tr>
<td align="center">OS05A10 </td><td align="center">5.0 </td><td align="center">Yes </td><td>1: Lnear mode<br  />
 2: DOL 2X HDR mode </td></tr>
<tr>
<td align="center">OS08A10 </td><td align="center">8.0 </td><td align="center">Yes </td><td>1: Lnear mode<br  />
 2: DOL 2X HDR mode </td></tr>
</table>
<p >The multi-VIN design with MAX9296 must use the same sensors. The support list is shown below:<br  />
</p>
<a class="anchor" id="supported_sensors_for_multi_vin_with_max9296"></a>
<table class="doxtable">
<caption>Supported Sensors for Multi-VIN with MAX9296.</caption>
<tr>
<th>Sensor </th><th>Resolution (MP) </th><th>Dual Remote Sensors </th><th>Triple Remote Sensors </th><th>Quad Remote Sensors </th><th>Notes </th></tr>
<tr>
<td align="center">IMX290 </td><td align="center">2.0 </td><td align="center">Yes </td><td align="center">Yes </td><td align="center">Yes </td><td>1: Linear mode<br  />
 2: DOL 2X HDR mode </td></tr>
<tr>
<td align="center">IMX390 </td><td align="center">2.0 </td><td align="center">Yes </td><td align="center">Yes </td><td align="center">Yes </td><td>1: Linear mode<br  />
 2: DOL 2X HDR mode </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The native dual VIN can support various sensor combinations as long as each individual sensor includes four lanes of MIPI interface connected to the CV5x / CV7x.</li>
<li>The native dual VIN can also support a long cable with the SERDES chip, which extends the distance from the sensor to the CV5x / CV7x.</li>
<li>B5F / B5N requires three or four pairs of SERDES cables to support a higher image resolution in each channel.</li>
<li>B6F / B6N can use either coaxial or Ethernet cables to support a higher image resolution in each channel.</li>
</ul>
</dd></dl>
<h2><a class="anchor" id="multi_vin_design_stream_view"></a>
2.8 Stream View</h2>
<p >For multi-VIN design, CV5x / CV7x support several stream views:<br  />
</p>
<ul>
<li>Independent stream view: Each stream is separately encoded from each sensor.</li>
<li>Blend stream view: One stream covers several sensor inputs’ field of view (FoV). The sensor’s input FoV can be aligned in either horizontal or vertical directions.</li>
<li>PIP stream view: One stream covers several sensor inputs’ FoV. One sensor input’s FoV functions as a small on-screen display (OSD) on another sensor input’s FoV.</li>
</ul>
<h3><a class="anchor" id="multi_vin_design_independent_stream_view"></a>
2.8.1 Independent Stream View</h3>
<p >The source buffers can be applied to different scale factors from the different VIN channels, as shown in the following diagram. Streams can be encoded separately from these FoVs.<br  />
</p>
<div class="image">
<img src="../../independent_stream_view_in_multi_vin_design.png" alt=""/>
<div class="caption">
Independent Stream View in the Multi-VIN Design.</div></div>
<dl class="section user"><dt>Implementation:</dt><dd></dd></dl>
<ul>
<li>A separate canvas for each output. One stream cannot cross FoVs.</li>
<li>An independent frame rate for each output or stream.</li>
</ul>
<h3><a class="anchor" id="multi_vin_design_blend_stream_view"></a>
2.8.2 Blend Stream View</h3>
<p >The source buffer can be applied to the same scale factor from different VIN channels (as shown in the following diagrams). All channels of the main buffer are combined in horizontal and vertical directions.<br  />
</p>
<div class="image">
<img src="../../horizontal_blend_stream_view_in_multi_vin_design.png" alt=""/>
<div class="caption">
Horizontal Blend Stream View in the Multi-VIN Design.</div></div>
 <div class="image">
<img src="../../vertical_blend_stream_view_in_multi_vin_design.png" alt=""/>
<div class="caption">
Vertical Blend Stream View in the Multi-VIN Design.</div></div>
<p >The application can encode the single stream to cover the three sensors’ input FoVs, enabling a 180° panoramic view.<br  />
</p>
<p >Stitched or panoramic view is one of the combinations of the blend view.<br  />
</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>When multiple main buffers are placed in the same canvas in the vertical blend view, the canvas option “enable_order” must be enabled. The bottom of the main buffer always adds 16 lines of extra padding data. This option enables the next buffer to vertically cover the padding data of the current buffer. This prevents the padding data from leaking.<br  />
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Implementation:</dt><dd></dd></dl>
<ul>
<li>Multiple outputs in one canvas</li>
<li>Identical frame rates for all VIN channels</li>
</ul>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<ul>
<li>Horizontal Blend Stream View</li>
</ul>
<div class="fragment"><div class="line">board # init.sh --na</div>
<div class="line">board # modprobe imx274_mipi vinc_id=8 bus_id=3 <span class="comment">// For CV5 or CV52</span></div>
<div class="line">(or board # modprobe imx274_mipi vinc_id=8)     <span class="comment">// For CV72</span></div>
<div class="line">board # test_aaa_service -a&amp;</div>
<div class="line">board # test_encode --resource-cfg dual_chan_single_sensor.lua</div>
<div class="line">board # test_encode -S 4 -H 3840x1072 --smaxsize 3840x1072 -b 4 -e</div>
</div><!-- fragment --><ul>
<li>Vertical Blend Stream View</li>
</ul>
<div class="fragment"><div class="line">board # init.sh --na</div>
<div class="line">board # modprobe imx274_mipi vinc_id=8 bus_id=3 <span class="comment">// For CV5 or CV52</span></div>
<div class="line">(or board # modprobe imx274_mipi vinc_id=8)     <span class="comment">// For CV72</span></div>
<div class="line">board # test_aaa_service -a&amp;</div>
<div class="line">board # test_encode --resource-cfg dual_chan_single_sensor.lua</div>
<div class="line">board # test_encode -S 5 -H 1920x2144 --smaxsize 1920x2144 -b 5 -e</div>
</div><!-- fragment --><p >For lua script to configure VIN / canvas / buffer layouts / stream, please refer to <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_lua_script_4_2">4.2.2 Lua Script</a></p>
<h3><a class="anchor" id="multi_vin_design_pip_stream_view"></a>
2.8.3 PIP Stream View</h3>
<p >The source buffer can be applied to different scale factors from the different VIN channels, and the output from one channel can be overlapped with another.<br  />
</p>
<p >The application can encode the single stream to cover the three sensors’ input FoVs, enabling a PIP view.<br  />
 </p><div class="image">
<img src="../../pip_stream_view_in_multi_vin_design.png" alt=""/>
<div class="caption">
PIP Stream View in the Multi-VIN Design.</div></div>
<dl class="section user"><dt>Implementation:</dt><dd></dd></dl>
<ul>
<li>Multiple outputs in one canvas</li>
<li>Identical frame rates for all VIN channels</li>
<li>The output from one VIN channel of the sub-source buffer, which is overlapped onto another VIN channel of the same source buffer in one canvas</li>
</ul>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<div class="fragment"><div class="line">board # init.sh --na</div>
<div class="line">board # modprobe imx274_mipi vinc_id=8 bus_id=3 <span class="comment">// For CV5 or CV52</span></div>
<div class="line">(or board # modprobe imx274_mipi vinc_id=8)     <span class="comment">// For CV72</span></div>
<div class="line">board # test_aaa_service -a&amp;</div>
<div class="line">board # test_encode --resource-cfg dual_chan_single_sensor.lua</div>
<div class="line">board # test_encode -S 6 -H 1920x1072 -b 6 -e</div>
</div><!-- fragment --><p >For lua script to configure VIN / canvas / buffer layouts / stream, please refer to <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_lua_script_4_2">4.2.2 Lua Script</a></p>
<hr  />
<h1><a class="anchor" id="multi_vin_design_system_design"></a>
3 System Design</h1>
<p >This chapter describes the details of a multi-VIN design, including memory management, VIN channel layout, canvas layout, buffer layout, stream layout, and PIP effect between channels.<br  />
</p>
<ul>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_memory_management">3.1 Memory Management</a></li>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_data_flow">3.2 Data Flow</a></li>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_concept_and_configuration">3.3 Concept and Configuration</a></li>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_sensor_driver_installation">3.4 Sensor Driver Installation</a></li>
</ul>
<h2><a class="anchor" id="multi_vin_design_memory_management"></a>
3.1 Memory Management</h2>
<p >Compared to the single-VIN design, DSP requires a larger dynamic random-access memory (DRAM) size for the multi-VIN design. Additionally, the multi-VIN design requires more DSP messages and commands to dynamically exchange the multi-channel information, such as VIN channel layout, canvas layout, stream layout, and so on. As a result, these additional commands and messages require a larger DRAM size for the image audio video (IAV) driver, as well.*<br  />
</p>
<p >The IAV creates a new partition to store multi-channel commands for this information, which is approximately 6 KB per channel. Users can configure the channel number from “menuconfig” as follows:<br  />
 For Cooper SDK Amba build: </p><div class="fragment"><div class="line">build$ make menuconfig</div>
<div class="line">       -&gt; drv_modules</div>
<div class="line">          -&gt; platform</div>
<div class="line">             -*- ambvideo-header (drv_modules/<span class="keyword">private</span>/video/dsp_v6)</div>
<div class="line">             (4) Max VIN Channel Number <span class="comment">// Change to 2 ~ 16 (depends on the real channel number)</span></div>
</div><!-- fragment --><p> For Cooper SDK Yocto build: </p><div class="fragment"><div class="line">build$ make menuconfig</div>
<div class="line">       Main menu</div>
<div class="line">          -&gt; meta-ambabsp</div>
<div class="line">             -&gt; recipes-bsp</div>
<div class="line">                -&gt; recipes-video</div>
<div class="line">                   -&gt; ambvideo-header (meta-ambabsp/recipes-video/ambvideo-header)</div>
<div class="line">                      (4)   Max VIN Channel Number</div>
</div><!-- fragment --> <h2><a class="anchor" id="multi_vin_design_data_flow"></a>
3.2 Data Flow</h2>
<p >CV5x / CV7x-supported product types of multi-VIN design are described in Section: <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_product_plan">2 Product Plan</a></p>
<p >This section describes the entire data flow of product types, including the sensor to VIN controller, the VIN controller to channel, and the channel to canvas.<br  />
</p>
<h3><a class="anchor" id="multi_vin_design_dual_vin_controllers"></a>
3.2.1 Dual VIN Controllers</h3>
<p >The two real VIN controllers are limited only by the interface. The controllers can take up to a 4-lane MIPI sensor at one time.<br  />
</p>
<p >The VIN8 controller can use either the Bayer RGB format data or the YUV format data, while the VIN11 controller can only take the Bayer RGB format data.<br  />
</p>
<div class="image">
<img src="../../dual_vin_controllers_data_flow_cv5x_cv7x.png" alt=""/>
<div class="caption">
Dual Vin Controllers Data Flow.</div></div>
<dl class="section user"><dt>Data Flow:</dt><dd></dd></dl>
<ul>
<li>Each sensor is enumerated as a video source (VSRC) device and is connected to a separated VIN controller.</li>
<li>The CV5x / CV7x IDSP run two passes to process the data from the dual VIN controllers independently.</li>
<li>Channel 0 is from sensor A via VIN8, and channel 1 is from sensor B via VIN11.</li>
</ul>
<h3><a class="anchor" id="multi_vin_design_quad_sensors_long_cable_with_serdes"></a>
3.2.2 Quad Sensors (Long Cable) with SERDES</h3>
<p >For quad sensor cases:<br  />
</p>
<ul>
<li>Quad sensors are mounted on serializer chips. Every two serializers connect to one MAX9296. Two MAX9296 chips are required. Then, these two MAX9296 chips connect to the CV5x / CV7x controllers (VIN8 and VIN11).</li>
</ul>
<div class="image">
<img src="../../quad_sensors_through_the_max9296_data_flow_cv5x_cv7x.png" alt=""/>
<div class="caption">
Quad Sensors Through the MAX9296 Data Flow.</div></div>
<dl class="section user"><dt>Data Flow:</dt><dd></dd></dl>
<ul>
<li>Each sensor is enumerated as a VSRC device, connected to the VIN controller 0 through a bridge chip, B5N, or connected to VIN8 and VIN11 through two MAX9296 chips respectively.</li>
<li>The CV5x / CV7x IDSP runs four passes to independently process the data from VIN8 and VIN11.</li>
<li>Channels 0 / 1 / 2 / 3 are from sensor A / B / C / D.</li>
</ul>
<h3><a class="anchor" id="multi_vin_design_idsp_virtual_channels"></a>
3.2.3 IDSP Virtual Channels</h3>
<p >For single-sensor cases, CV5x / CV7x supports IDSP virtual channels with the multi-channel design (refer to the following figure).<br  />
</p>
<div class="image">
<img src="../../idsp_virtual_channels_data_flow_cv5x_cv7x.png" alt=""/>
<div class="caption">
IDSP Virtual Channels Data Flow.</div></div>
<dl class="section user"><dt>Data Flow:</dt><dd></dd></dl>
<ul>
<li>Sensor A is enumerated as the VSRC 0 device and connected to VIN0.</li>
<li>The CV5x / CV7x IDSP run four passes to process the sensor data from VIN0 independently with different IDSP filter parameters.</li>
<li>Channels 0 / 1 / 2 / 3 are from sensor A with duplicated sensor data.</li>
</ul>
<h3><a class="anchor" id="multi_vin_design_single_sensor_with_a_dual_vsrc_ctx"></a>
3.2.4 Single Sensor with a Dual Vsrc_ctx.</h3>
<p >A single sensor with a dual vsrc_ctx is a special use case of the “IDSP virtual channel”. Support for the dual vsrc_ctx depends on the sensor model.<br  />
</p>
<p >Some sensors possess two separated shutter / gain register groups. These two register groups are used to configure two different sets of the shutter / gain to two successive frames generated by this single sensor independently. For example, with the dual vsrc-ctx, all <b>2 * N + 0</b> frames are set to shutter / gain group 1, and all <b>2 * N + 1</b> frames are set to shutter / gain group 2. Here, each register group of shutter / gain is called vsrc_ctx. 2x channels are set up to capture the frames from the two vsrc_ctx, as shown below.<br  />
</p>
<p >Using dual vsrc-ctx as an example, all <b>2 * N + 0</b> frames with shutter / gain group 1 are captured through channel 0, and all <b>2 * N + 1</b> frames with shutter / gain group 2 are captured through channel 1. As the two register groups of shutter / gain can be configured independently without affecting each other, it functions as if channel 0 and channel 1 are from two different sensors.<br  />
</p>
<p >The following shows dual channels from the single sensor design with the dual vsrc_ctx.<br  />
</p>
<div class="image">
<img src="../../dual_channels_from_a_single_sensor_with_dual_vsrc_ctx_design_cv5x_cv7x.png" alt=""/>
<div class="caption">
Dual Channels from a Single Sensor with the Dual Vsrc_ctx Design.</div></div>
<dl class="section user"><dt>Data Flow:</dt><dd></dd></dl>
<ul>
<li>Sensor A is enumerated as the VSRC 0 device, and connected to VIN0.</li>
<li>With the dual vsrc_ctx, the IDSP processing frame rate of these two channels is 1/2 of the VIN frame rate. The sensor frames are divided into two groups: one for channel 0 and the other for channel 1.</li>
<li>Among the dual vsrc_ctx, each vsrc_ctx supports its own shutter / gain. Each channel processes the sensor data independently with its own IDSP filter parameters.</li>
</ul>
<h3><a class="anchor" id="multi_vin_design_vsrc_to_channel"></a>
3.2.5 Vsrc to Channel</h3>
<dl class="section user"><dt>Concept</dt><dd></dd></dl>
<ul>
<li>VIN: Each VIN controller is abstracted as a “VIN” instance. It can be connected directly to an independent sensor or multiple sensors through SERDES.</li>
<li>vsrc: Each sensor is abstracted as a “vsrc” instance.</li>
<li>vsrc_ctx: For sensors with multiple separated shutter / gain register groups that can configure different shutter / gain to multiple successive frames independently. Each shutter / gain register group is abstracted as a “vsrc_ctx” instance. A “vsrc” may have multiple “vsrc_ctx”.</li>
</ul>
<p >The following image demonstrates the data flow from the “vsrc” to the channel:<br  />
 </p><div class="image">
<img src="../../vsrc_to_channel_data_flow_cv5x_cv7x.png" alt=""/>
<div class="caption">
Vsrc to the Channel Data Flow.</div></div>
<dl class="section user"><dt>Data Flow:</dt><dd></dd></dl>
<ul>
<li>Sensor A and sensor B both connect to VIN0 through SERDES. Sensor A corresponds to vsrc0 and sensor B corresponds to vsrc1.</li>
<li>Each vsrc is captured into one channel that processes its data independently from the other channels.</li>
</ul>
<h3><a class="anchor" id="multi_vin_design_channel_to_canvas"></a>
3.2.6 Channel to Canvas</h3>
<p >The CV5x / CV7x multi-channel design enables up to five outputs per channel for data content and for pyramid output. The outputs for the multi-channel case include the main / second / third / fourth / fifth source buffers and the pyramid buffer. They function as follows:<br  />
</p>
<ul>
<li>ch0.main / ch1.main / ...</li>
<li>ch0.2nd / ch1.2nd / ...</li>
<li>ch0.3rd / ch1.3rd / ...</li>
<li>ch0.4th / ch1.4th / ...</li>
<li>ch0.5th / ch1.5th / ...</li>
<li>ch0.pyramid / ch1. pyramid / ...</li>
</ul>
<p >The figure on the following page illustrates the channel to buffer data flow, followed by a figure of the channel to canvas data flow.<br  />
</p>
<div class="image">
<img src="../../channel_to_buffer_data_flow_cv5x_cv7x.png" alt=""/>
<div class="caption">
Channel to Buffer Data Flow.</div></div>
 <div class="image">
<img src="../../channel_to_canvas_data_flow_cv5x_cv7x.png" alt=""/>
<div class="caption">
Channel to Canvas Data Flow.</div></div>
<dl class="section user"><dt>Data Flow:</dt><dd></dd></dl>
<ul>
<li>Channel 0 generates: ch0.main, ch0.2nd, ch0.3rd, ch0.4th, ch0.5th, and pyramid</li>
<li>Channel 1 generates: ch1.main, ch1.2nd, ch1.3rd, ch1.4th, ch1.5th, and pyramid</li>
<li>Channel 2 generates: ch2.main, ch2.2nd, ch2.3rd, ch2.4th, ch2.5th, and pyramid</li>
<li>Channel 3 generates: ch3.main, ch3.2nd, ch3.3rd, ch3.4th, ch3.5th, and pyramid</li>
</ul>
<p >The following list provides examples of five canvases derived from four channels:</p>
<ul>
<li>Canvas 0: ch0.main and ch1.main</li>
<li>Canvas 1: ch0.2nd, ch1.2nd, ch2.2nd, and ch3.2nd</li>
<li>Canvas 2: ch0.3rd, ch1.3rd and ch2.3rd</li>
<li>Canvas 3: ch0.4th</li>
<li>Canvas 4: ch1.4th</li>
</ul>
<h2><a class="anchor" id="multi_vin_design_concept_and_configuration"></a>
3.3 Concept and Configuration</h2>
<p >For the multi-VIN design, the application must configure the various layout settings, including VIN, canvas, stream, and VOUT.<br  />
</p>
<p >To facilitate parsing the parameters, a Lua script file is introduced as the configuration file for these layout settings. The Lua script is refined to organize the parameters and the multi-VIN design options in a streamlined format. This Lua script format is a good reference for users to configure their own implementation and file format for organizing these options.<br  />
</p>
<p ><b>Reference code:</b> test_encode.c / test_multi_chan.c;<br  />
 multi-channel Lua parser library;<br  />
 multi_chan_vin0_1_1080p_linear.lua /<br  />
 multi_chan_vin0_1_4Mp_hdr.lua<br  />
</p>
<h3><a class="anchor" id="multi_vin_design_sensor_configuration"></a>
3.3.1 Sensor Configuration</h3>
<p >For the two sensor designs on native dual VINs, the DSP receives the image content from the two sensors, independently.<br  />
</p>
<p >From the application, the sensor data saved in the DSP memory is as follows:<br  />
</p>
<ul>
<li>Frame N of VIN channel 0</li>
<li>Frame N of VIN channel 1</li>
<li>Frame N+1 of VIN channel 0</li>
<li>Frame N+1 of VIN channel 1</li>
<li>... ... ...</li>
</ul>
<dl class="section user"><dt>Implementation:</dt><dd></dd></dl>
<ul>
<li>Each sensor is configured as an independent "vsrc" instance in the Lua script.</li>
<li>Each sensor (vsrc) is connected with the independent VIN. It can have different resolution, frame rate, and output mode.</li>
<li>The application can capture the sensor's raw data via the standard unit test tool "test_yuvcap".</li>
</ul>
<dl class="section user"><dt>Usage:</dt><dd></dd></dl>
<ul>
<li>"vsrc_id" is used to specify the sensor input ID. It is suggested to keep the same value as a sensor index, which is generated automatically during the sensor driver probes and corresponds to a real sensor.</li>
<li>"mode" is used to specify the sensor resolution mode.</li>
<li>"hdr_mode" is used to specify the high dynamic range (HDR) mode or linear mode, for example linear, 2x, or 3x.</li>
<li>"fps" is used to specify the sensor frame rate.</li>
<li>"bits" is used to specify the sensor RGB bits. 0 for AUTO, 8 ~ 16 for specified bits.</li>
<li>"vsrc_ctx_switch" is used to specify the sensor register vsrc_ctx auto switch flag. It only works for some sensors, such as AR0230 and AR0237, which can support multiple register groups of the shutter and AGC. Not currently supported but planned for a later version CV5x / CV7x SDKs.</li>
</ul>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">vsrc_0 = {</div>
<div class="line">    vsrc_id = 0,</div>
<div class="line">    mode = <span class="stringliteral">&quot;1080p&quot;</span>,</div>
<div class="line">    <a class="code hl_variable" href="../../d4/daa/vin__init_8c.html#a9586a0cc85ebac1f283fc9f2d94c82e2">hdr_mode</a> = <span class="stringliteral">&quot;linear&quot;</span>, -- options: <span class="stringliteral">&quot;linear&quot;</span>, <span class="stringliteral">&quot;2x&quot;</span> or <span class="stringliteral">&quot;3x&quot;</span></div>
<div class="line">    fps = 20,</div>
<div class="line">    <a class="code hl_variable" href="../../d4/daa/vin__init_8c.html#ad1e28a1a66a25529b0b61b9ca4e66d44">bits</a> = 0,</div>
<div class="line">    vsrc_ctx_switch = 0</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">vsrc_1 = {</div>
<div class="line">    vsrc_id = 1,</div>
<div class="line">    mode = <span class="stringliteral">&quot;1080p&quot;</span>,</div>
<div class="line">    <a class="code hl_variable" href="../../d4/daa/vin__init_8c.html#a9586a0cc85ebac1f283fc9f2d94c82e2">hdr_mode</a> = <span class="stringliteral">&quot;linear&quot;</span>, -- options: <span class="stringliteral">&quot;linear&quot;</span>, <span class="stringliteral">&quot;2x&quot;</span> or <span class="stringliteral">&quot;3x&quot;</span></div>
<div class="line">    fps = 20,</div>
<div class="line">    <a class="code hl_variable" href="../../d4/daa/vin__init_8c.html#ad1e28a1a66a25529b0b61b9ca4e66d44">bits</a> = 0,</div>
<div class="line">    vsrc_ctx_switch = 0</div>
<div class="line">}</div>
<div class="ttc" id="avin__init_8c_html_a9586a0cc85ebac1f283fc9f2d94c82e2"><div class="ttname"><a href="../../d4/daa/vin__init_8c.html#a9586a0cc85ebac1f283fc9f2d94c82e2">hdr_mode</a></div><div class="ttdeci">int hdr_mode</div><div class="ttdef"><b>Definition:</b> vin_init.c:61</div></div>
<div class="ttc" id="avin__init_8c_html_ad1e28a1a66a25529b0b61b9ca4e66d44"><div class="ttname"><a href="../../d4/daa/vin__init_8c.html#ad1e28a1a66a25529b0b61b9ca4e66d44">bits</a></div><div class="ttdeci">int bits</div><div class="ttdef"><b>Definition:</b> vin_init.c:63</div></div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="multi_vin_design_channel_configuration"></a>
3.3.2 Channel Configuration</h3>
<p >For the multi-VIN design, the application can define different maximum source-buffer output widths for each VIN channel, as well as various channel processing orders.<br  />
</p>
<dl class="section user"><dt>Implementation:</dt><dd></dd></dl>
<ul>
<li>CV5x / CV7x chips support up to eight channels.</li>
<li>DSP supports the flexible channel processing order. By default, it processes channels in ascending order. Each channel that the DSP processes is overlapped by the following channel.</li>
<li>Channel processing order supports on the fly updating to switch the content among channels.</li>
<li>The channel processing order is applied per-canvas.</li>
<li>If the application must swap PIP image content with background image content, it must change the channel processing order on the fly. The latter order channel can be overlapped with the former order channel.</li>
<li>The application can capture the canvas YUV / ME1 / ME0 data via the standard unit test tool "test_yuvcap".</li>
<li>For dual channels from a single sensor, DSP generates two copies of the 3A statistical data. Only one channel's 3A data is required to control 3A because there is only a single sensor. For example, if channel 0's 3A statistic data is selected, users must set "sensor_ctrl = 1" and "img_stats_src_chan = chan_0" for channel 0. Then, set the "sensor_ctrl = 0" and "img_stats_src_chan = chan_0" for channel 1 in the Lua script.</li>
<li>max_main_input_width is used to configure the maximum input width for the main buffer. By default, max_main_ input_width is set to 0, which is equal to the VIN raw width. However, the maximum input width must be configured if the user application requires a small main buffer input size, such as 720x480, with a large VIN, size such as 3840x2160. The main buffer input width cannot exceed this parameter, if set, through the run-time update during the preview / encoding state. Not currently supported but planned for a later version.</li>
<li>A sixth source buffer is multiplexed from the pyramid; only one can be enabled at a time.</li>
</ul>
<dl class="section user"><dt>Usage:</dt><dd></dd></dl>
<ul>
<li>"id" specifies the channel ID. Ambarella recommends that users keep the same value as the channel index, which starts from zero.</li>
<li>"vsrc" specifies the source sensor (vsrc) for the channel. The content must be declared before the channel definition in the Lua script.</li>
<li>"raw_capture" is used to enable raw data capture from the RGB sensor. Users can get more information from the help message of the unit test app, test_yucap.</li>
<li>"vsrc_ctx" specifies the sensor register context of the source sensor (vsrc) for the channel. It functions with specific sensors, such as AR0230, which support multiple register groups of shutter and AGC.</li>
<li>"img_stats_src_chan" tells the 3A process which channel’s statistics are used for 3A control for the channel. It is used for the multi-channel stitching and IDSP virtual channel cases.</li>
<li>"sensor_ctrl" tells the sensor driver which channel is allowed to configure the shutter and AGC. It is only used for special "IDSP virtual channel" cases.</li>
<li>"max_padding_width" configures the padding value for the LDC purpose on this channel. It must function with the "lens_warp" option.</li>
<li>"idsp_fps" specifies the resample IDSP output frame rate. It must be less than or equal to the VIN frame rate.</li>
<li>"lens_warp" enables the LDC function.</li>
<li>"max_main_input_width" specifies the maximum main buffer input width and can help the DSP allocate the proper resources from various cases. It must be configured when the user application requires a small main buffer input size (for example, 720x480) with a large VIN size (for example, 3840x2160). If set, it cannot be exceeded by the main buffer input width through the run-time update during the preview / encoding.</li>
<li>"blend_left" enables horizontal cross-channel stitching.</li>
<li>"blend_right" enables vertical cross-channel stitching.</li>
<li>"mctf_cmpr" enables motion-compensated temporal filtering (MCTF) compression.</li>
<li>"mctf_10bit_ref" enables the MCTF 10-bit reference.</li>
<li>"main_burst_tile" enables main burst tile mode. By default, it must be set to 1.</li>
<li>"extra_downscale" enables a large downscale. When the downscale ratio is greater than or equal to 6X, it must be set to 1.</li>
<li>"enable_group" enables channel grouping. The channels in the same group must run the same frame rate.</li>
<li>"group_idx" specifies group index. For example, if channel 0’s and channel 1’s group_idx = 0, then channel 0 and channel 1 are in the same group0. Its range is 0-3 and is only valid when enable_group = 1.</li>
<li>"group_sync" enables channel grouping synchronization. It is only valid when enable_group = 1.</li>
<li>"max_warp_input_width" specifies the maximum input width for dewarp.</li>
<li>"max_warp_output_width" specifies the maximum output width for dewarp.</li>
<li>"max_vwarp_wait_lines" specifies the waiting lines for vwarp.</li>
<li>"invert_mode" enables invert mode. In this mode, all pixels of source buffers will be inverted.</li>
<li>"use_vsrc_ctx_pattern" specifies if the IDSP splits the VIN frame into the current channel according to its "vsrc_ctx_pattern”. This feature is only supported by certain SONY sensors, such as IMX264 and IMX265.
  - "vsrc_ctx_pattern" specifies the data pattern that is embedded in the first line of sensor data.
  - "vsrc_ctx_pattern_mask" specifies valid bits in the "vsrc_ctx_pattern”.</li>
<li>"vsrc_ctx_pattern_offset" specifies the data offset in the sensor data.</li>
<li>"pass_num" specifies the pass number generated by the IDSP for the source buffers.</li>
<li>"pass_0_rotation" specifies if the first pass is rotated.</li>
<li>"low_delay_vin_vout" enables low-delay mode between VIN and VOUT.</li>
<li>"packing_mode_enable" enables VIN packing mode only when the VIN RAW compression is disabled to save the DRAM bandwidth.</li>
<li>"low_delay_vin_vout" enables low-delay mode between VIN and VOUT.</li>
<li>"packing_mode_enable" enables VIN packing mode only when the VIN RAW compression is disabled to save DRAM bandwidth.</li>
<li>"vsrc_region_num" specifies the total region number of the source sensor. These multiple vsrc_regions must be stored in a line-interleaved format in the sensor data.</li>
<li>"vsrc_region_idx" specifies a region from which the current channel captures the sensor data.</li>
<li>"premain / main / second / third / fourth / fifth / sixth" are used to specify the buffer output of each channel.</li>
</ul>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line">chan_0 = {</div>
<div class="line">    <span class="keywordtype">id</span> = 0,</div>
<div class="line">    vsrc = vsrc_0,</div>
<div class="line">    raw_capture = 1,</div>
<div class="line">    vsrc_ctx = 0,</div>
<div class="line">    img_stats_src_chan = <span class="stringliteral">&quot;chan_0&quot;</span>,</div>
<div class="line">    sensor_ctrl = 1,</div>
<div class="line">    max_padding_width = 0,</div>
<div class="line">    idsp_fps = 0,</div>
<div class="line">    lens_warp = 0,</div>
<div class="line">    max_main_input_width = 0, -- 0: VIN <a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a788db922597cf2fb6389e278f822e59f">raw</a> <a class="code hl_variableRef" href="../../../driver/df/dc0/group__IAV.html#ga85db88ffee2944ecd35c616393976289">width</a></div>
<div class="line">    blend_left = 0,</div>
<div class="line">    blend_right = 0,</div>
<div class="line">    mctf_cmpr = 0,</div>
<div class="line">    mctf_10bit_ref = 0,</div>
<div class="line">    main_burst_tile = 1,</div>
<div class="line">    extra_downscale = 0,</div>
<div class="line">    enable_group = 0,</div>
<div class="line">    group_idx = 0,</div>
<div class="line">    group_sync = 0,</div>
<div class="line">    <a class="code hl_function" href="../../db/d1a/test__vout__cfg_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> = {</div>
<div class="line">        max_output = {0, 0}, -- output <a class="code hl_variableRef" href="../../../driver/df/dc0/group__IAV.html#ga85db88ffee2944ecd35c616393976289">width</a></div>
<div class="line">        input      = {0, 0, 0, 0}, -- full VIN</div>
<div class="line">        output     = {0, 0, 1920, 1080},</div>
<div class="line">    },</div>
<div class="line"> </div>
<div class="line">    second = {</div>
<div class="line">        max_output = {0, 0}, -- output <a class="code hl_variableRef" href="../../../driver/df/dc0/group__IAV.html#ga85db88ffee2944ecd35c616393976289">width</a></div>
<div class="line">        input      = {0, 0, 0, 0}, -- full <a class="code hl_function" href="../../db/d1a/test__vout__cfg_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div>
<div class="line">        output     = {0, 0, 720, 480},</div>
<div class="line">    },</div>
<div class="line"> </div>
<div class="line">    third = {</div>
<div class="line">        ... ... ...</div>
<div class="line">    },</div>
<div class="line"> </div>
<div class="line">    fourth = {</div>
<div class="line">        ... ... ...</div>
<div class="line">    },</div>
<div class="line"> </div>
<div class="line">    fifth = {</div>
<div class="line">        ... ... ...</div>
<div class="line">    },</div>
<div class="line"> </div>
<div class="line">    pyramid = {</div>
<div class="line">        input_buf_id = 4,   -- 0: Main, 1: Second, 2: Third, 3: Fourth, 4: Fifth</div>
<div class="line">        <a class="code hl_variable" href="../../d4/daa/vin__init_8c.html#a12db301b040a15818f8d32874c312444">scale_type</a> = 0,     -- 0: 1/sqrt(2) 1: 1/2</div>
<div class="line">        buf_addr = 0x0,</div>
<div class="line">        buf_size = 0x0,</div>
<div class="line">        layer_map = 0x3F,</div>
<div class="line">        layers = {</div>
<div class="line">            {</div>
<div class="line">                crop_win = {0, 0, 0 ,0},</div>
<div class="line">            },</div>
<div class="line">            ... ... ...</div>
<div class="line">        },</div>
<div class="line">    },</div>
<div class="line">}</div>
<div class="ttc" id="acJSON_8h_html_a788db922597cf2fb6389e278f822e59f"><div class="ttname"><a href="../../../library/d1/d82/cJSON_8h.html#a788db922597cf2fb6389e278f822e59f">raw</a></div><div class="ttdeci">const char *const const char *const raw</div></div>
<div class="ttc" id="agroup__IAV_html_ga85db88ffee2944ecd35c616393976289"><div class="ttname"><a href="../../../driver/df/dc0/group__IAV.html#ga85db88ffee2944ecd35c616393976289">width</a></div><div class="ttdeci">u32 width</div></div>
<div class="ttc" id="atest__vout__cfg_8c_html_a3c04138a5bfe5d72780bb7e82a18e627"><div class="ttname"><a href="../../db/d1a/test__vout__cfg_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="ttdeci">int main(int argc, char **argv)</div><div class="ttdef"><b>Definition:</b> test_vout_cfg.c:85</div></div>
<div class="ttc" id="avin__init_8c_html_a12db301b040a15818f8d32874c312444"><div class="ttname"><a href="../../d4/daa/vin__init_8c.html#a12db301b040a15818f8d32874c312444">scale_type</a></div><div class="ttdeci">int scale_type</div><div class="ttdef"><b>Definition:</b> vin_init.c:77</div></div>
</div><!-- fragment --><h3><a class="anchor" id="multi_vin_design_channel_group"></a>
3.3.3 Channel Group</h3>
<p >The channel group concept applies in the multi-VIN design.</p>
<p >The main purpose of channel group is to ensure that the order of output of all channels is the same. This feature is very important for multi-vin design because the mechanism of processing video frame for image digital signal processing (DSP) is FIFO.<br  />
</p>
<p >For example, in picture in picture (PIP) stream view, the output from one channel can be overlapped on another. If the output order of these channels cannot be the same, the overlap will be disordered (one minute for the output of channel A is on the top of the output of channel B, the next B is on top of A). Once the channel group is enabled, this uncertainty does not exist because DSP will not process the frames until all grouping channels receive new frames. When all grouping channels' new frames are received, DSP will process them orderly.<br  />
</p>
<p >The application must use the following rules for channel group design:</p>
<dl class="section user"><dt>Implementation:</dt><dd></dd></dl>
<ul>
<li>All VIN sensors in a group are suggested to be the same and started at the same time. If sensors in a group are not the same, in order to keep in sync, the sensors are suggested to work in slave mode and use the same fsync signal from Amba SoC. This is to keep the sensors output the raw frames in sync. Otherwise, a longer tolerance needs to be set via <code>test_encode option</code> "--debug-chan-group-tolerance 90" (using 90 as an example, the default value is 50) to avoid frame drop due to tolerance missing.</li>
</ul>
<dl class="section user"><dt>Usage:</dt><dd></dd></dl>
<ul>
<li>"enable_group" is used to enable the channel grouping. The channels in the same group must run the same frame rate.</li>
<li>"group_sync" is used to enable the channel grouping synchronization. It is only valid when enable_group = 1.</li>
<li>"group_idx" is used to specify the group index. For example, if chan0's and chan1's group_idx = 0, it means that chan0 and chan1 are in the same group0. Its range is 0~3, and is only valid when enable_group = 1.</li>
<li>"group_order_index" is used to specify the process order of channel in a group.</li>
</ul>
<dl class="section user"><dt>Example:</dt><dd><pre class="fragment">@code
chan_0 {
    ... ... ...
    enable_group = 1,
    enable_sync = 1,
    group_index = 0,
    group_order_index = 1,
    main = {
        max_output = {1920, 0},
        input      = {   0, 0, 1920, 1080},
        output     = { 960, 0,  960, 1080},
    },

    second = {
        ... ... ...
    },

    third = {
        max_output = {1920, 0},
        input      = {   0, 0,  960, 1080},
        output     = { 960, 0,  960, 1080},
    }

    fourth = {
        ... ... ...
    },

    fifth = {
        ... ... ...
    },
}

chan_1 {
    ... ... ...
    enable_group = 1,
    enable_sync = 1,
    group_index = 0,
    group_order_index = 2,
    main = {
        max_output = {1920, 0},
        input      = {   0, 0, 1920, 1080},
        output     = { 960, 0,  960, 1080},
    },

    second = {
        ... ... ...
    },

    third = {
        max_output = {1920, 0},
        input      = {   0, 0,  960, 1080},
        output     = { 960, 0,  960, 1080},
    }

    fourth = {
        ... ... ...
    },

    fifth = {
        ... ... ...
    },
}
@endcode
</pre> </dd></dl>
<h3><a class="anchor" id="multi_vin_design_buffer_layout"></a>
3.3.4 Buffer Layout</h3>
<p >The source buffer concept applies in the multi-VIN design.<br  />
</p>
<p >Every source buffer output window can be arranged in the canvas layout. The application must use the following rules for the buffer layout design.<br  />
</p>
<dl class="section user"><dt>Implementation:</dt><dd></dd></dl>
<ul>
<li>The source buffers combined into the same canvas must be in the same type of canvas, either preview or encode.</li>
<li>The source buffer input size of each channel should not exceed the VIN channel resolution.</li>
<li>The source buffer output size and offset should not exceed the canvas resolution.</li>
<li>The source buffer input size in the channel layout and the output size in canvas layout can be changed on the fly to serve as the digital pan / tilt / zoom (DPTZ) effect for each channel.</li>
<li>The source buffer output size can be 0x0 to function as a turning off source buffer. When the output size is 0x0, Ambarella recommends setting the buffer type as "off".</li>
<li>The source buffer output size can be different for each of the channels.</li>
<li>The source buffer output region can be overlapped with other source buffer output regions in the canvas layout to act as a PIP effect.</li>
<li>The source buffer output region can be overlapped only when they have the same buffer type and in the same canvas.</li>
<li>The source buffer type must be the same for all channels.</li>
</ul>
<dl class="section user"><dt>Usage:</dt><dd></dd></dl>
<ul>
<li>"max_output {width, height}" is used to specify the maximum output width / height of each source buffer.</li>
<li>"input {offset_x, offset_y, width, height}" is used to specify the input window of each source buffer. The main buffer input window is cropped from the sensor (vsrc) resolution, and the other source buffer input window is cropped from the main buffer output window.</li>
<li>"output {offset_x, offset_y, width, height}" is used to specify the output window of each source buffer in canvas. The output offset is in the canvas coordinate.</li>
</ul>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">chan_0 {</div>
<div class="line">    ... ... ...</div>
<div class="line">    <a class="code hl_function" href="../../db/d1a/test__vout__cfg_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> = {</div>
<div class="line">        max_output = {1920, 0},</div>
<div class="line">        input      = {   0, 0, 1920, 1080},</div>
<div class="line">        output     = { 960, 0,  960, 1080},</div>
<div class="line">    },</div>
<div class="line"> </div>
<div class="line">    second = {</div>
<div class="line">        ... ... ...</div>
<div class="line">    },</div>
<div class="line"> </div>
<div class="line">    third = {</div>
<div class="line">        max_output = {1920, 0},</div>
<div class="line">        input      = {   0, 0,  960, 1080},</div>
<div class="line">        output     = { 960, 0,  960, 1080},</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    fourth = {</div>
<div class="line">        ... ... ...</div>
<div class="line">    },</div>
<div class="line"> </div>
<div class="line">    fifth = {</div>
<div class="line">        ... ... ...</div>
<div class="line">    },</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="multi_vin_design_pyramid_layout"></a>
3.3.5 Pyramid Layout</h3>
<p >Pyramid buffers are generated by the CV5x / CV7x DSP and are used to perform a video content analysis (VCA). CV5x / CV7x support generating up to six pyramid layers.<br  />
</p>
<p >The pyramid can choose its input source buffer from one of the Main / Second / Third / Fourth / Fifth source buffers in the same channel. The pyramid's first layer size is the same as its input buffer size. When the input source buffer is one of the sub-buffers, it cannot be put into the canvas for preview or encode. Consequently, if the pyramid is generated from the main buffer, the main buffer still can be put into the canvas and used as an encode source.<br  />
</p>
<p >However, it is recommended to use one of the sub-buffers for the pyramid input. This saves DRAM bandwidth, as sub-buffers can be smaller. Typically, the fifth source buffer is the best choice for the pyramid input.<br  />
</p>
<p >The six layers of the pyramid buffer are different sizes determined by the scale type. CV5x / CV7x support two scale types: when the scale type is 0, the width and / or height of each layer is 1 / sqrt(2) of the previous layer. When the scale type is 1, the width and / or height is half the size of the previous layer.<br  />
</p>
<p >The actual size of each layer is determined by the pyramid input buffer size and scale type. However, CV5x / CV7x also support cropping from the output pyramid layer by specifying the crop window on the active window of the pyramid layer.<br  />
</p>
<dl class="section user"><dt>Implementation:</dt><dd></dd></dl>
<ul>
<li>The scale type can be 0 or 1.</li>
<li>The buffer can come from an external buffer. When buf_addr is valid, DSP generates the pyramid buffers from the external buffer address. When buf_addr is 0, DSP generates the pyramid buffers in the internal memory. If buf_addr is valid, then buf_size also is valid.</li>
</ul>
<p >There are two methods for allocating and maintaining the pyramid buffers: the pyramid auto-generation mode and the pyramid manual-feed mode. For the auto-generation mode, DSP is responsible for the allocation and maintenance of pyramid buffers. Each time, when DSP generates a group of pyramid buffers, it reports to Arm automatically. For the manual-feed mode, Arm takes charge of the allocation and maintenance of the pyramid buffers. Each time the user application wants a group of pyramid buffers, it feeds an empty group to DSP. When DSP fills the pyramid data into the buffers, it reports them back to Arm. For more details, refer to the <em>Ambarella CV5x DG Flexible Linux SDK Video Process</em> document.<br  />
</p>
<dl class="section user"><dt>Usage:</dt><dd></dd></dl>
<ul>
<li>"input_buf_id" is used to specify the input source buffer ID in this channel.</li>
<li>"scale_type" is used to specify the pyramid layer scale ratio.</li>
<li>"buf_addr" is used to specify the external buffer address in the auto-generation mode. It is 0 when the pyramid is from DSP's internal buffer. In the manual-feed mode, it must be 0 as its pyramid buffer pool is allocated by the image audio video (IAV) driver.</li>
<li>"buf_size" in the auto-generation mode is used to specify the total external buffer size to store all of the pyramid layers. It is valid only when the "buf_addr" is specified. The total buffer size includes up to six layers, with 4x ~ 8x for circular usage. In the manual-feed mode, it also can be used to specify a fixed pyramid buffer pool size. When it is specified, the IAV driver will not reallocate the pyramid buffer pool again even if the required pool size is changed.</li>
<li>"manual_feed" is used to enable the manual-feed mode. 0: pyramid auto-generation mode; 1: pyramid manual-feed mode.</li>
<li>"item_num" is used to specify the number of pyramid buffers in the pyramid manual-feed mode. It must be within the range of [4, 8]. When the setting is 0, it uses 4 as a default.</li>
<li>"layer_map" is used to specify which layers are not enabled to reduce the DRAM bandwidth. To enable all six layers, set this to 0x3F.</li>
<li>"crop_win {offset_x, offset_y, width, height}" is used to specify the output window of each pyramid layer buffer. The default value {0,0,0,0} refers to the pyramid layer's active window without cropping, rather than the window with the size 0x0.</li>
</ul>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line">pyramid = {</div>
<div class="line">    input_buf_id = 4,   -- 0: Main, 1: Second, 2: Third, 3: Fourth, 4: Fifth</div>
<div class="line">    <a class="code hl_variable" href="../../d4/daa/vin__init_8c.html#a12db301b040a15818f8d32874c312444">scale_type</a> = 0,     -- 0: 1/sqrt(2) 1: 1/2</div>
<div class="line">    buf_addr = 0,</div>
<div class="line">    buf_size = 0,</div>
<div class="line">    manual_feed = 0,</div>
<div class="line">    item_num = 0,</div>
<div class="line">    layer_map = 0x3F,   -- 0: means disable all pyramid layers</div>
<div class="line">    --[[For each pyramid layer, the input is always full sized Main.</div>
<div class="line">        And the full sized pyramid is generated according to Main size and the <a class="code hl_variable" href="../../d4/daa/vin__init_8c.html#a12db301b040a15818f8d32874c312444">scale_type</a>.</div>
<div class="line">        The output pyramid is cropped from the full sized pyramid.</div>
<div class="line">        Offset 0x0 with size 0x0 means the full pyramid output without cropping.</div>
<div class="line">    --]]</div>
<div class="line"> </div>
<div class="line">    layers = {</div>
<div class="line">        {</div>
<div class="line">            crop_win    = {0, 0, 0 ,0},</div>
<div class="line">        },</div>
<div class="line">        {</div>
<div class="line">            crop_win    = {0, 0, 0 ,0},</div>
<div class="line">        },</div>
<div class="line">        {</div>
<div class="line">            crop_win    = {0, 0, 0 ,0},</div>
<div class="line">        },</div>
<div class="line">        {</div>
<div class="line">            crop_win    = {0, 0, 0 ,0},</div>
<div class="line">        },</div>
<div class="line">        {</div>
<div class="line">            crop_win    = {0, 0, 0 ,0},</div>
<div class="line">        },</div>
<div class="line">        {</div>
<div class="line">            crop_win    = {0, 0, 0 ,0},</div>
<div class="line">        },</div>
<div class="line">    },</div>
<div class="line">},</div>
</div><!-- fragment --><h3><a class="anchor" id="multi_vin_design_canvas_layout"></a>
3.3.6 Canvas Layout</h3>
<p >The multi-VIN design includes a new memory layout: canvas layout (also the concept behind the encode source memory).<br  />
</p>
<p >In the multi-VIN design, each source buffer (from the main to the fourth buffer) can output the data for each channel using different resolutions. The application can combine the field of view (FoV) of each source buffer output of each channel together into one canvas so that the stream encoded from this canvas can cover several FoVs from different VIN channels. Alternatively, the application can crop the separate streams from encoding, using different areas of the blend view canvas.<br  />
</p>
<dl class="section user"><dt>Implementation:</dt><dd></dd></dl>
<ul>
<li>The maximum canvas number is 10.</li>
<li>The canvas type must be either the preview or encode. There is no off type.</li>
<li>The source buffer outputs combined in the same canvas must be in the same buffer type, preview, encode, or off.</li>
</ul>
<dl class="section user"><dt>Typical configuration:</dt><dd></dd></dl>
<ul>
<li>Different source buffer output content is aligned seamlessly in the horizontal or vertical direction, such as the Nx1 or 1xN order.</li>
<li>One source buffer output is overlapped on another source buffer output as the PIP effect.</li>
</ul>
<dl class="section user"><dt>Usage:</dt><dd></dd></dl>
<ul>
<li>"type" is used to specify the canvas type. It can be either "encode" or "prev". There is no "off" type for canvas. If the application requires to turn off the canvas, it has to reconfigure the system and remove the canvas definition. If canvas type is previewed, it outputs the YUV422 format with UV interleaved data. If canvas type is encoded, it outputs the YUV420 format with UV interleaved data.</li>
<li>"size {width, height}" is used to specify the canvas resolution.</li>
<li>"source" is used to specify the source buffer of channels to canvas. DSP follows the source buffer declare order to put channel source buffer data in this field. The latter source buffer is put in with a higher Z order and may cover the source buffer with a lower Z order. The channels whose source buffer are put to the same canvas must have the same "idsp_fps".</li>
<li>"vout_id" is used to specify VOUT. If the value is set to 1, VOUT1 (like HDMI, CVBS) will be used to show the preview canvas. If the value is set to 0, VOUT0 (like LDC, DSI) will be used to show the preview canvas.</li>
<li>"vout_YUV422" is used to specify the YUV format of "prev" type canvas. If the value is set to 1, its YUV format is YUV422. Then VOUT captures the display data from it directly to show out. If the value is set to 0, its YUV format is YUV420, which is the same as other "encode" type canvases. The VOUT then converts it to YUV422 before showing out.</li>
<li>"extra_dram_buf" specifies the extra DRAM frames for the canvas.</li>
<li>"enable_order" enables channel order within the current canvas. It must be enabled in PIP cases.</li>
<li>"clear_background" enables clearing the whole canvas at the initial stage when entering the preview state. It clears the background garbage when the canvas is not fully covered by its source buffers.</li>
</ul>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<div class="fragment"><div class="line">canvas = {</div>
<div class="line">    {</div>
<div class="line">        type = <span class="stringliteral">&quot;encode&quot;</span>,</div>
<div class="line">        size = {1920, 1080},</div>
<div class="line">        <a class="code hl_variable" href="../../d4/daa/vin__init_8c.html#a07a87b2e6ed927503e2f95f119c9fc23">source</a> = {<span class="stringliteral">&quot;chan_0.main&quot;</span>, <span class="stringliteral">&quot;chan_1.main&quot;</span>, },</div>
<div class="line">        extra_dram_buf = 0,</div>
<div class="line">        enable_order = 1,</div>
<div class="line">        clear_background = 0,</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">        type = <span class="stringliteral">&quot;prev&quot;</span>,</div>
<div class="line">        size = {1920, 1080},</div>
<div class="line">        <a class="code hl_variable" href="../../d4/daa/vin__init_8c.html#a07a87b2e6ed927503e2f95f119c9fc23">source</a> = {<span class="stringliteral">&quot;chan_0.third&quot;</span>, <span class="stringliteral">&quot;chan_1.third&quot;</span>, },</div>
<div class="line">        <a class="code hl_variable" href="../../d4/de8/vout__init_8c.html#a049a525f0e8bc8bee106f89f18f896ce">vout_id</a> = 1,</div>
<div class="line">        <a class="code hl_variable" href="../../d4/de8/vout__init_8c.html#ab4a73b5629d37ce98639684eb84d8410">vout_YUV422</a> = 0,</div>
<div class="line">        extra_dram_buf = 0,</div>
<div class="line">        enable_order = 1,</div>
<div class="line">        clear_background = 1,</div>
<div class="line">    },</div>
<div class="line">}</div>
<div class="ttc" id="avin__init_8c_html_a07a87b2e6ed927503e2f95f119c9fc23"><div class="ttname"><a href="../../d4/daa/vin__init_8c.html#a07a87b2e6ed927503e2f95f119c9fc23">source</a></div><div class="ttdeci">int source</div><div class="ttdef"><b>Definition:</b> vin_init.c:57</div></div>
<div class="ttc" id="avout__init_8c_html_a049a525f0e8bc8bee106f89f18f896ce"><div class="ttname"><a href="../../d4/de8/vout__init_8c.html#a049a525f0e8bc8bee106f89f18f896ce">vout_id</a></div><div class="ttdeci">int vout_id</div><div class="ttdef"><b>Definition:</b> vout_init.c:36</div></div>
<div class="ttc" id="avout__init_8c_html_ab4a73b5629d37ce98639684eb84d8410"><div class="ttname"><a href="../../d4/de8/vout__init_8c.html#ab4a73b5629d37ce98639684eb84d8410">vout_YUV422</a></div><div class="ttdeci">int vout_YUV422[VOUT_NUM]</div><div class="ttdef"><b>Definition:</b> vout_init.c:42</div></div>
</div><!-- fragment --><h3><a class="anchor" id="multi_vin_design_stream_configuration"></a>
3.3.7 Stream Configuration</h3>
<p >Single-VIN system designs enable easy configuration of the stream encode size and offset. If required, the application can dynamically change the stream offset.<br  />
</p>
<dl class="section user"><dt>Implementation:</dt><dd></dd></dl>
<ul>
<li>For the multi-VIN design, use the source canvas for the encode source rather than the source buffer.</li>
<li>The encode source ID must be the source canvas ID, not the source buffer ID.</li>
<li>All encoding features of the multi-VIN stream are the same as the single VIN design.</li>
</ul>
<dl class="section user"><dt>Usage:</dt><dd></dd></dl>
<ul>
<li>Up to 16 streams are supported.</li>
<li>"id" specifies the stream ID. Ambarella recommends keeping the same value as the stream index, starting from zero.</li>
<li>"max_size" specifies the maximum stream resolution.</li>
<li>"max_M" specifies the maximum GOP M for the stream. For B frame, max_M &gt; 1. For MJPEG encoding, max_M = 0.</li>
<li>"fast_seek_enable" enables the fast seek frame.</li>
<li>"two_ref_enable" enables two forward reference frames.</li>
<li>"max_svct_layers_minus_1" specifies the maximum SVC-T layers options. 0: no SVC-T; 1: 2 layers SVC-T.</li>
<li>"max_num_minus_1_ltrs" specifies the maximum long-term number minus 1.</li>
<li>"possible_enc_src_map" specifies the encoding source canvas map for the encoding stream. 0 (default): all canvases. Users must specify when the stream will be encoded with an advanced OP. Advanced GOP requires more memory resources to be allocated for the source canvases. By default, the DSP allocates memory resources for all canvases, so specifying the designated source canvases can save memory.</li>
<li><p class="startli">"codec_enable" enables the stream CODEC.</p>
<p class="startli">0: HEVC / H264 / MJPEG 1: HEVC / MJPEG 2: H264 / MJPEG, 3: MJPEG only</p>
</li>
<li>"efm_enable" specifies if the current stream can run encode from memory (EFM).</li>
<li>"efm_buf_num" specifies the number of frame buffers allocated for the EFM. These frame buffers are allocated by the DSP and occupy extra memory.</li>
<li>"efm_size" specifies the EFM frame buffer resolution.</li>
</ul>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">stream_0 = {</div>
<div class="line">       <span class="keywordtype">id</span> = 0,</div>
<div class="line">       max_size = {1920, 1080},</div>
<div class="line">       max_M = 1,</div>
<div class="line">       fast_seek_enable = 0,</div>
<div class="line">       two_ref_enable = 0,</div>
<div class="line">       max_svct_layers_minus_1 = 0,</div>
<div class="line">       max_num_minus_1_ltrs = 0,</div>
<div class="line">       possible_enc_src_map = 0,</div>
<div class="line">       codec_enable = 0, -- 0: H264/H265/MJPEG; 1: H265/MJPEG; 2: H264/MJPEG; 3: MJPEG</div>
<div class="line">       efm_enable = 0,</div>
<div class="line">       efm_buf_num = 0,</div>
<div class="line">       efm_size = {0, 0},</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<h3><a class="anchor" id="multi_vin_design_vout_layout"></a>
3.3.8 VOUT Layout</h3>
<p >In the multi-VIN design, the VOUT layout is used to show a single view (PIP) of preview mode, or multiple views of installation mode.<br  />
</p>
<p >As the source buffer output size can be configured as 0x0, the application disables one of the VOUT channels, or switches the channels in the background and foreground in the PIP view on the fly. This is useful for users entering multi-channel product installation mode.<br  />
</p>
<p >The third and fourth source buffers are connected to VOUT 1 / 2 / 3, making the VOUT layout rule the same as the buffer layout.<br  />
</p>
<dl class="section user"><dt>Implementation:</dt><dd></dd></dl>
<ul>
<li>VOUT content comes from the source canvas, as well as the encoded streams.</li>
<li>VOUT supports independent view, blended view, and PIP view, along with encoded streams.</li>
</ul>
<h2><a class="anchor" id="multi_vin_design_sensor_driver_installation"></a>
3.4 Sensor Driver Installation</h2>
<p >The multi-VIN design can require different sensors mounted to the various VIN controllers. As each sensor possesses its own sensor driver, users must install each sensor driver accordingly. For more detail, you can take reference from <a class="elRef" href="../../../driver/d2/dcb/page_sys_sensor_driver_installation.html">Sensor &amp; SERDES Driver Installation</a></p>
<hr  />
<h1><a class="anchor" id="multi_vin_design_examples"></a>
4 Examples</h1>
<p >This chapter provides examples for configuring various layout settings in the Lua script and for running the time update layout.<br  />
</p>
<ul>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_quad_sensors_with_a_long_cable_through_max9296_4_1">4.1 Quad Sensors with a Long Cable through MAX9296</a></li>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_dual_channels_from_a_single_sensor_4_2">4.2 Dual Channels from a Single Sensor</a></li>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_dual_channels_from_the_sensor_and_the_yuv_raw_data">4.3 Dual Channels from the Sensor and the YUV Raw Data</a></li>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_dual_sensors_with_different_modes_from_max9296">4.4 Dual Sensors with Different Modes from MAX9296</a></li>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_dual_channels_from_imx264_with_dual_vsrc_ctx">4.5 Dual Channels from IMX264 with Dual Vsrc_ctx</a></li>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_quad_sensors_with_imx274">4.6 Quad Sensors with imx274</a></li>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_multiple_yuv_input">4.7 Multiple YUV Input</a></li>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_quad_sensors_through_bridge_chip">4.8 Quad Sensors through Bridge Chip</a></li>
</ul>
<h2><a class="anchor" id="multi_vin_design_quad_sensors_with_a_long_cable_through_max9296_4_1"></a>
4.1 Quad Sensors with a Long Cable through MAX9296</h2>
<p ><em> Example 7: For Quad Sensors, Start Ten Streams from Nine Canvas View. One is a Blend View for Encoding, and the Others are Normal Views for Encoding. </em></p>
<h3><a class="anchor" id="multi_vin_design_test_commands_4_1"></a>
4.1.1 Test Commands</h3>
<p >The command sequence for the test command is as follows:<br  />
 </p><div class="fragment"><div class="line">board # init.sh --na</div>
<div class="line">board # modprobe max9296 <span class="keywordtype">id</span>=0x0303 vinc_id=0xb8</div>
<div class="line">board # modprobe os08a10_mipi_brg fsync=1</div>
<div class="line">board # test_aaa_service -a &amp;</div>
<div class="line">board # test_encode --resource-cfg quad_remote_sensors.lua</div>
<div class="line">board # test_encode -S0 -<a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a> 0 -H 3840x2160 -e</div>
<div class="line">board # test_encode -S1 -<a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a> 0 -m 3840x2160 --frame-factor 1/6 -e</div>
<div class="line">board # test_encode -S2 -<a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a> 1 -H 1920x1080  -e</div>
<div class="line">board # test_encode -S3 -<a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a> 3 -H 1920x1080  -e</div>
<div class="line">board # test_encode -S4 -<a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a> 5 -H 1920x1080  -e</div>
<div class="line">board # test_encode -S5 -<a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a> 7 -H 1920x1080  -e</div>
<div class="line">board # test_encode -S6 -<a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a> 2 -H 1280x720  -e</div>
<div class="line">board # test_encode -S7 -<a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a> 4 -H 1280x720  -e</div>
<div class="line">board # test_encode -S8 -<a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a> 6 -H 1280x720  -e</div>
<div class="line">board # test_encode -S9 -<a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a> 8 -H 1280x720  -e</div>
<div class="ttc" id="acJSON_8h_html_a1a175e87536301df98c805ac0636ad7c"><div class="ttname"><a href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a></div><div class="ttdeci">const cJSON *const b</div></div>
</div><!-- fragment --><h3><a class="anchor" id="multi_vin_design_lua_script_4_1"></a>
4.1.2 Lua Script</h3>
<p >Lua script to configure the VIN / canvas / buffer layouts / streams is: <a href="../../script/quad_remote_sensors.lua" target="_blank"><b>quad_remote_sensors.lua</b></a>.</p>
<h2><a class="anchor" id="multi_vin_design_dual_channels_from_a_single_sensor_4_2"></a>
4.2 Dual Channels from a Single Sensor</h2>
<p ><em>Example 8: For Dual Channels from a Single VIN: Start Six Streams from Canvas View. </em></p>
<h3><a class="anchor" id="multi_vin_design_test_commands_4_2"></a>
4.2.1 Test Commands</h3>
<p >The following shows the command sequence for tests:<br  />
 </p><div class="fragment"><div class="line">board # init.sh --na;</div>
<div class="line">board # modprobe imx274_mipi vinc_id=8 bus_id=3 <span class="comment">// For CV5 or CV52</span></div>
<div class="line">(or board # modprobe imx274_mipi vinc_id=8)     <span class="comment">// For CV72</span></div>
<div class="line">board # test_aaa_service -a&amp;</div>
<div class="line">board # test_encode --resource-cfg dual_chan_single_sensor.lua</div>
<div class="line">board # test_encode -S 0 -H 3840x2160 -b 0 -e -S 1 -H 3840x2160 -b 1 -e -S 2 -m 3840x2160 -b 2 --frame-factor 1/6 -e -S 3 -m 3840x2160 -b 3 --frame-factor 1/6 -e</div>
</div><!-- fragment --><h3><a class="anchor" id="multi_vin_design_lua_script_4_2"></a>
4.2.2 Lua Script</h3>
<p >Lua script to configure the VIN / canvas / buffer layouts / streams is: <a href="../../script/dual_chan_single_sensor.lua" target="_blank"><b>dual_chan_single_sensor.lua</b></a>.</p>
<h2><a class="anchor" id="multi_vin_design_dual_channels_from_the_sensor_and_the_yuv_raw_data"></a>
4.3 Dual Channels from the Sensor and the YUV Raw Data</h2>
<p ><em>Example 9: Dual Channels from the Sensor and YUV Raw Data: Start Two Streams from Two Canvas Views. Channel 0 Captures Data from Sensor; Channel 1 Captures the YUV Raw Data Fed by User Application. </em></p>
<h3><a class="anchor" id="multi_vin_design_test_commands_4_3"></a>
4.3.1 Test Commands</h3>
<p >The command sequence is shown below:<br  />
 </p><div class="fragment"><div class="line">board # init.sh --na</div>
<div class="line">board # modprobe imx274_mipi vinc_id=8 bus_id=3 lane=2 <span class="comment">// For CV5 or CV52</span></div>
<div class="line">(or board # modprobe imx274_mipi vinc_id=8 lane=2)     <span class="comment">// For CV72</span></div>
<div class="line">board # modprobe ambdd video_type=5 cap_cap_w=1920 cap_cap_h=1080 video_fps=17066667 sensor_id=0x3014</div>
<div class="line">board # test_aaa_service -a &amp;</div>
<div class="line">board # test_mempart -m 2 -s 0x4000000</div>
<div class="line">board # test_encode --resource-cfg /usr/share/ambarella/lua_scripts/cv5_dual_chan_single_sensor.lua --vout-cfg /usr/share/ambarella/lua_scripts/vout_hdmi.lua --raw-capture 1 --enc-raw-rgb 1</div>
<div class="line">board # test_efm -t 3 -s 1920x1080 -i cap_raw_raw_1920x1080_3840.raw -T 1</div>
<div class="line">board # test_encode -A -h 1080p –b 0 -e -B -h 1080p -b 4 –e</div>
</div><!-- fragment --><h3><a class="anchor" id="multi_vin_design_lua_script_4_3"></a>
4.3.2 Lua Script</h3>
<p >Lua script to configure the VIN / canvas / buffer layouts / streams is: <a href="../../script/cv5_dual_chan_single_sensor.lua" target="_blank"><b>cv5_dual_chan_single_sensor.lua</b></a>.</p>
<h2><a class="anchor" id="multi_vin_design_dual_sensors_with_different_modes_from_max9296"></a>
4.4 Dual Sensors with Different Modes from MAX9296</h2>
<p ><em>Example 10: For Dual Sensors with Different Modes from MAX9296: Start Two Streams from Canvas View. </em></p>
<h3><a class="anchor" id="multi_vin_design_test_commands_4_4"></a>
4.4.1 Test Commands</h3>
<p >The command sequence is shown below:<br  />
 </p><div class="fragment"><div class="line">board # init.sh --na;</div>
<div class="line">board # modprobe max9296 <span class="keywordtype">id</span>=0x201 vc=1 dts_addr=1</div>
<div class="line">board # modprobe os08a10_mipi_brg brg_id=0x1</div>
<div class="line">board # modprobe imx290_mipi_brg brg_id=0x2 slave=1</div>
<div class="line">board # test_aaa_service -a&amp;</div>
<div class="line">board # test_encode --resource-cfg cv5_dual_chan.lua --vout-cfg /usr/share/ambarella/lua_scripts/vout_hdmi.lua</div>
<div class="line">board # test_encode -A -H 3840x2160 –b 0 -e –B –H 1080p –b 4 -e</div>
</div><!-- fragment --><h3><a class="anchor" id="multi_vin_design_lua_script_4_4"></a>
4.4.2 Lua Script</h3>
<p >Lua script to configure the VIN / canvas / buffer layouts / streams is: <a href="../../script/cv5_dual_chan.lua" target="_blank"><b>cv5_dual_chan.lua</b></a>.</p>
<h2><a class="anchor" id="multi_vin_design_dual_channels_from_imx264_with_dual_vsrc_ctx"></a>
4.5 Dual Channels from IMX264 with Dual Vsrc_ctx</h2>
<p ><em>Example 11: Dual Channels from IMX264 with Dual Vsrc_ctx: Divide Frames into Two Channels Half-by-Half and Start Two Streams from Two-Canvas View. </em></p>
<h3><a class="anchor" id="multi_vin_design_test_commands_4_5"></a>
4.5.1 Test Commands</h3>
<p >The command sequence is shown below:<br  />
 </p><div class="fragment"><div class="line">board # init.sh --na;</div>
<div class="line">board # modprobe imx264 vinc_id=8 bus_id=3 frameset=2       <span class="comment">// frameset must be set to 2</span></div>
<div class="line">board # test_aaa_service -a &amp;</div>
<div class="line">board # test_encode --resource-cfg /usr/share/ambarella/lua_scripts/cv5_imx264_2xframe_2432x2048_linear.lua --vout-cfg /usr/share/ambarella/lua_scripts/vout_hdmi.lua</div>
<div class="line">board # test_encode -A -H 2432x2048 –b 0 -e -B -h 2432x2048 -<a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a> 2 –e</div>
</div><!-- fragment --><h3><a class="anchor" id="multi_vin_design_lua_script_4_5"></a>
4.5.2 Lua Script</h3>
<p >Lua script to configure the VIN / canvas / buffer layouts / streams is: <a href="../../script/cv5_imx264_2xframe_2432x2048_linear.lua" target="_blank"><b>cv5_imx264_2xframe_2432x2048_linear.lua</b></a>.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>idsp_fps is set to 0. This leaves the IDSP to run its own frame down-sampling for channel 0 and channel 1. With the dual VSRC, channel 0 and channel 1 idsp_fps will be 15 when the VIN fps is set to 30.</li>
<li>The vsrc_ctx_pattern and the vsrc_ctx_pattern_mask are specified referring to the IMX264 sensor specification.</li>
</ul>
</dd></dl>
<h2><a class="anchor" id="multi_vin_design_quad_sensors_with_imx274"></a>
4.6 Quad Sensors with imx274</h2>
<p >Set up 4x imx274 sensors connected to CV5 EVK board. One sensor board includes two independent sensors connected to VIN8 and VIN11 controllers, respectively. The other sensor board has two independent sensors, which connected VIN0 and VIN4 controllers, at the same time, highlight DCPHY0 needs to be connected with DCPHY0 (converter board slot), and DCPHY1 needs to be connected with DCPHY1 (converter board slot).<br  />
</p>
<div class="image">
<img src="../../4x_imx274_connect_to_cv5_EVK.png" alt=""/>
<div class="caption">
4x imx274 Connect to CV5 Board.</div></div>
<p ><em>Example 12: For Quad Sensors with imx274: Start Four Streams from Canvas View. </em></p>
<h3><a class="anchor" id="multi_vin_design_test_commands_4_6"></a>
4.6.1 Test Commands</h3>
<p >The command sequence is shown below:<br  />
 </p><div class="fragment"><div class="line">board # init.sh --na;</div>
<div class="line">board # modprobe imx274_mipi vinc_id=0x40b8;</div>
<div class="line">board # test_aaa_service -a&amp;</div>
<div class="line">board # test_encode --resource-cfg cv5_four_vin_4k_encode.lua --vout-cfg /usr/share/ambarella/lua_scripts/vout_hdmi.lua</div>
<div class="line">board # test_encode -S 0 -h 3840x2160 -<a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a> 0 -e</div>
<div class="line">board # test_encode -S 1 -h 3840x2160 -<a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a> 1 -e</div>
<div class="line">board # test_encode -S 2 -h 3840x2160 -<a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a> 2 -e</div>
<div class="line">board # test_encode -S 3 -h 3840x2160 -<a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a> 3 -e</div>
</div><!-- fragment --><h3><a class="anchor" id="multi_vin_design_lua_script_4_6"></a>
4.6.2 Lua Script</h3>
<p >Lua script to configure the VIN / canvas / buffer layouts / streams is as follows: <a href="../../script/cv5_four_vin_4k_encode.lua" target="_blank"><b>cv5_four_vin_4k_encode.lua</b></a>.</p>
<h2><a class="anchor" id="multi_vin_design_multiple_yuv_input"></a>
4.7 Multiple YUV Input</h2>
<p ><em>Example 13: Multiple YUV Input: Dual YUV Input from LT6911. </em></p>
<h3><a class="anchor" id="multi_vin_design_preparation_4_7"></a>
4.7.1 Preparation</h3>
<p >This feature uses VINC0 and VINC8 on I2C bus 5 and 3. The ambvin section must be added to the related I2C section in the DTS as shown below:<br  />
 </p><div class="fragment"><div class="line">--- a/bsp/cv5_timn.dts</div>
<div class="line">+++ <a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a>/bsp/cv5_timn.dts</div>
<div class="line">@@ -145,11 +145,6 @@</div>
<div class="line"> &amp;i2c0 {</div>
<div class="line">        status = <span class="stringliteral">&quot;ok&quot;</span>;</div>
<div class="line"> </div>
<div class="line">-       ambvin0@01 {</div>
<div class="line">-               compatible = <span class="stringliteral">&quot;ambarella,ambvin&quot;</span>;</div>
<div class="line">-               reg = &lt;0x01&gt;;  <span class="comment">// fake address, will be overwritten in runtime</span></div>
<div class="line">-       };</div>
<div class="line">-</div>
<div class="line">        nau8810: codec@1a {</div>
<div class="line">                                compatible = <span class="stringliteral">&quot;nuvoton,nau8810&quot;</span>;</div>
<div class="line"><span class="preprocessor">                                #sound-dai-cells = &lt;0&gt;;</span></div>
<div class="line">@@ -201,6 +196,10 @@</div>
<div class="line"><span class="preprocessor"> #else</span></div>
<div class="line">        status = <span class="stringliteral">&quot;disabled&quot;</span>;</div>
<div class="line"><span class="preprocessor"> #endif</span></div>
<div class="line">+       ambvin0@01 {</div>
<div class="line">+               compatible = <span class="stringliteral">&quot;ambarella,ambvin&quot;</span>;</div>
<div class="line">+               reg = &lt;0x01&gt;;   <span class="comment">// fake address, will be overwritten in runtime</span></div>
<div class="line">+       };</div>
<div class="line"> </div>
<div class="line">        fan: amc6821@1a {</div>
<div class="line">                compatible = <span class="stringliteral">&quot;ti,amc6821&quot;</span>;</div>
</div><!-- fragment --><h3><a class="anchor" id="multi_vin_design_test_commands_4_7"></a>
4.7.2 Test Commands</h3>
<ol type="1">
<li>First, set up two 1080P HDMI outputs on any board. Call them board 1 and board 2.<br  />
 <div class="fragment"><div class="line">board # init.sh --imx274_mipi</div>
<div class="line">board # test_aaa_service -a &amp;</div>
<div class="line">board # test_encode -i0 --hdmi 1080p</div>
</div><!-- fragment --></li>
<li>Next, connect the HDMI output of board 1 to the HDMI input of LT6911. Then, connect the HDMI output of board 2 to LT6911's HDMI input, mounting the two LT6911 parts into the VIN slot of board 3.<br  />
 <div class="fragment"><div class="line">board # init.sh --na</div>
<div class="line">board # modprobe lt6911 vinc_id=0xf08</div>
<div class="line">board # test_aaa_service -a &amp;</div>
<div class="line">board # test_encode --resource-cfg cv5_dual_vin_yuv.lua  --vout-cfg /usr/share/ambarella/lua_scripts/vout_hdmi.lua</div>
</div><!-- fragment --></li>
</ol>
<h3><a class="anchor" id="multi_vin_design_lua_script_4_7"></a>
4.7.3 Lua Script</h3>
<p >Lua script to configure the VIN / canvas / buffer layouts / streams is: <a href="../../script/cv5_dual_vin_yuv.lua" target="_blank"><b>cv5_dual_vin_yuv.lua</b></a>.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The vsrc mode must be 0 when the YUV input is used.</li>
</ul>
</dd></dl>
<h2><a class="anchor" id="multi_vin_design_quad_sensors_through_bridge_chip"></a>
4.8 Quad Sensors through Bridge Chip</h2>
<p >Set up 4x os05a10 sensors connected to CV72 GA EVK board. CV72 supports 3x native VIN controllers, it can support three independent sensors. Two independent sensors connected to VIN8 and VIN11 controllers, respectively. The other two sensor connected to the same VIN0 controller through bridge chip B8N. At the same time, SLVS + DPHY VIN slot needs to be connected with SLVS + DPHY (sensor board slot), and DCPHY0 needs to be connected with B8 MIPI OUT slot (sensor board slot).<br  />
</p>
<div class="image">
<img src="../../4x_os05a10_connect_to_cv72_ga_board.png" alt=""/>
<div class="caption">
4x os05a10 Connect to CV72 Ga Board.</div></div>
<p ><em>Example 14: Quad Sensors through bridge chip: Start Four Streams from Canvas View. </em></p>
<h3><a class="anchor" id="multi_vin_design_preparation_4_8"></a>
4.8.1 Preparation</h3>
<p >Macro CONFIG_BOARD_TYPE_B8N_LOCAL_QUAD_SEN need to be defined in the DTS as shown below:<br  />
 </p><div class="fragment"><div class="line">--- a/bsp/cv72_gage.dts</div>
<div class="line">+++ <a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a>/bsp/cv72_gage.dts</div>
<div class="line">@@ -21,6 +21,7 @@</div>
<div class="line"><span class="preprocessor"> #endif</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"> #define PCI_QUIRK_PCI_ADDR 0x02000000</span></div>
<div class="line">+#define CONFIG_BOARD_TYPE_B8N_LOCAL_QUAD_SEN</div>
</div><!-- fragment --><h3><a class="anchor" id="multi_vin_design_test_commands_4_8"></a>
4.8.1 Test Commands</h3>
<p >The command sequence is shown below:<br  />
 </p><div class="fragment"><div class="line">board # init.sh --na;</div>
<div class="line">board # modprobe os05a10 vinc_id=0xb8 fsync=1 &amp;&amp; modprobe b8 <span class="keywordtype">id</span>=0x30 set_vin_first=1 &amp;&amp; modprobe os05a10_mipi_brg fsync=1;</div>
<div class="line">board # test_aaa_service -a&amp;</div>
<div class="line">board # test_encode --resource-cfg cv72_four_vin_5m_encode.lua --vout-cfg /usr/share/ambarella/lua_scripts/vout_hdmi.lua</div>
<div class="line">board # test_encode -S 0 -h 2560x1920 -<a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a> 0 -e</div>
<div class="line">board # test_encode -S 1 -h 2560x1920 -<a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a> 1 -e</div>
<div class="line">board # test_encode -S 2 -h 2560x1920 -<a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a> 2 -e</div>
<div class="line">board # test_encode -S 3 -h 2560x1920 -<a class="code hl_variableRef" href="../../../library/d1/d82/cJSON_8h.html#a1a175e87536301df98c805ac0636ad7c">b</a> 3 -e</div>
</div><!-- fragment --><h3><a class="anchor" id="multi_vin_design_lua_script_4_8"></a>
4.8.2 Lua Script</h3>
<p >Lua script to configure the VIN / canvas / buffer layouts / streams is as follows: <a href="../../script/cv72_four_vin_5m_encode.lua" target="_blank"><b>cv72_four_vin_5m_encode.lua</b></a>.</p>
<hr  />
<h1><a class="anchor" id="multi_vin_design_on_the_fly_settings"></a>
5 On the fly Settings</h1>
<p >This chapter provides examples of on the fly settings. The settings enable multi-channel parameters to be changed independently during the preview / encoding state, such as channel orders, preview buffer DPZ, and preview buffer on / off. The unit test tool (test_multi_chan) is used for the on the fly settings.<br  />
</p>
<dl class="section user"><dt>Implementation limitations:</dt><dd></dd></dl>
<ul>
<li>User applications cannot increase or decrease the number of canvases on the fly.</li>
<li>User applications cannot perform DPZ for main buffers on the fly.</li>
<li>User applications cannot change the canvas source of the source buffers on the fly.</li>
</ul>
<p >The chapter sections are as follows:<br  />
</p>
<ul>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_digital_pan_tilt_zoom">5.1 Digital Pan / Tilt / Zoom (DPTZ)</a></li>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_turn_the_preview_buffer_on_off">5.2 Turn the Preview Buffers On / Off</a></li>
<li>Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_dump_multi_channel_configurations">5.3 Dump Multi-Channel Configurations</a></li>
</ul>
<h2><a class="anchor" id="multi_vin_design_digital_pan_tilt_zoom"></a>
5.1 Digital Pan / Tilt / Zoom (DPTZ)</h2>
<p >This user application can dynamically change the input size / offset of the preview buffers within their main buffers. DPTZ can also change the output size / offset of the preview buffers within the canvases.<br  />
</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>To upscale the preview buffers on the fly, assign the maximum output width through the Lua script when preview state is entered. This is necessary because the maximum output width cannot be changed on the fly.</li>
<li>The maximum zoom-in and zoom-out factors of each preview buffer is the same as the single channel cases.</li>
</ul>
</dd></dl>
<p><em>Example 13: For DPTZ On the Fly: Third Buffer (800x600) of Channel 1 is Cropped (Offset 100x100 from Top Left) and Down-Scaled (from 720p to 800x600) from Main Buffer (1080p).</em></p>
<div class="fragment"><div class="line">board # init.sh --na</div>
<div class="line">board # modprobe imx274_mipi vinc_id=8 bus_id=3 <span class="comment">// For CV5 or CV52</span></div>
<div class="line">(or board # modprobe imx274_mipi vinc_id=8)     <span class="comment">// For CV72</span></div>
<div class="line">board # test_aaa_service -a &amp;</div>
<div class="line">board # test_encode --resource-cfg multi_chan_vin0_1080p_vin1_4M_linear.lua --hdmi 1080p</div>
<div class="line">board # test_multi_chan -c 1 -J --binsize 1280x720 --binoffset 100x100 --boutsize 800x600 --boutoffset 160x160</div>
</div><!-- fragment --><p ><em>Example 14: For DPTZ On the Fly: Third Buffer (1080p) of Channel 1 is Cropped (Offset 480x270 from Top Left) and Upscaled (from 960x540 to 1080p) from Main Buffer (1080p). </em></p>
<div class="fragment"><div class="line">board # init.sh --na</div>
<div class="line">board # modprobe imx274_mipi vinc_id=8 bus_id=3 <span class="comment">// For CV5 or CV52</span></div>
<div class="line">(or board # modprobe imx274_mipi vinc_id=8)     <span class="comment">// For CV72</span></div>
<div class="line">board # test_aaa_service -a &amp;</div>
<div class="line">board # test_encode --resource-cfg multi_chan_vin0_1080p_vin1_4M_linear.lua --hdmi 1080p</div>
<div class="line">board # test_multi_chan -c 1 -J --binsize 960x540 --binoffset 480x270 --boutsize 1920x1080 --boutoffset 0x0</div>
</div><!-- fragment --><p ><em>Example 15: For DPTZ On the Fly: Change Input, Output Offset, and Size of Third Buffer of Channel 1 On the Fly with Direction Keys. </em></p>
<div class="fragment"><div class="line">board # init.sh --imx274_mipi</div>
<div class="line">board # test_aaa_service -a &amp;</div>
<div class="line">board # test_encode --resource-cfg multi_chan_vin0_1080p_vin1_4M_linear.lua --hdmi 1080p</div>
<div class="line">board # test_multi_chan -c 1 -J --binsize m     <span class="comment">// tune input size</span></div>
<div class="line">board # test_multi_chan -c 1 -J --binoffset m       <span class="comment">// tune input offset</span></div>
<div class="line">board # test_multi_chan -c 1 -J --boutsize m        <span class="comment">// tune output size</span></div>
<div class="line">board # test_multi_chan -c 1 -J --boutoffset m  <span class="comment">// tune output offset</span></div>
</div><!-- fragment --><h2><a class="anchor" id="multi_vin_design_turn_the_preview_buffer_on_off"></a>
5.2 Turn the Preview Buffers On / Off</h2>
<p >To turn off the preview buffers on the fly, the input and output sizes must be set to zero. The buffers can be enabled again by setting the corresponding DPTZ parameters.<br  />
</p>
<p ><em> Example 16: Turn Off Preview Buffers On the Fly: Power Off Third Buffer of Channel 1.</em> </p><div class="fragment"><div class="line">board # init.sh --na</div>
<div class="line">board # modprobe imx274_mipi vinc_id=8 bus_id=3 <span class="comment">// For CV5 or CV52</span></div>
<div class="line">(or board # modprobe imx274_mipi vinc_id=8)     <span class="comment">// For CV72</span></div>
<div class="line">board # test_aaa_service -a &amp;</div>
<div class="line">board # test_encode --resource-cfg multi_chan_vin0_1080p_vin1_4M_linear.lua --hdmi 1080p</div>
<div class="line">board # test_multi_chan -c 1 -J --binsize 0x0 --boutsize 0x0</div>
</div><!-- fragment --><h2><a class="anchor" id="multi_vin_design_dump_multi_channel_configurations"></a>
5.3 Dump Multi-Channel Configurations</h2>
<p >To dump the multi-channel configurations for debugging or other purposes, use the multi-channel format of the Lua script with test_multi_chan. The printed data follows the multi-channel Lua script file format. Users can also copy the printed content and save it directly to the Lua script.<br  />
</p>
<p ><em>Example 17: Dump the Multi-Channel Configuration. </em> </p><div class="fragment"><div class="line">board # init.sh --na</div>
<div class="line">board # modprobe imx274_mipi vinc_id=8 bus_id=3 <span class="comment">// For CV5 or CV52</span></div>
<div class="line">(or board # modprobe imx274_mipi vinc_id=8)     <span class="comment">// For CV72</span></div>
<div class="line">board # test_aaa_service -a &amp;</div>
<div class="line">board # test_encode -i 0 --vout-cfg /usr/share/ambarella/lua_scripts/vout_hdmi.lua</div>
<div class="line">board # test_multi_chan -s</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="multi_vin_design_faq"></a>
6 FAQ</h1>
<p ><b>Question 1: </b> Why does the DSP hang when multiple streams are encoded from the same canvas?<br  />
 <b>Answer: </b> Similar to the single-channel design, the DSP uses the minimum possible number of frames for the canvas in the multi-channel design to reduce DRAM size. When multiple streams are encoded from the same canvas, the DSP has a race condition for frame release. The application must specify the “&ndash;extra-buf N-1” option for the canvas if there are N streams encoded from this canvas.<br  />
</p>
<p ><b>Question 2: </b> Does CV5x / CV7x support a multi-channel design from a single-sensor input?<br  />
 <b>Answer: </b> Yes. This is called the "IDSP virtual channel" design case described in Section <a class="el" href="../../d3/dc4/fd_adv_multi_vin.html#multi_vin_design_idsp_virtual_channels">3.2.3 IDSP Virtual Channels</a>. Although the "IDSP virtual channel" case requires more system resources than the single channel, it still requires less than the dual channels.<br  />
 As long as the system resources are sufficient, the application can run up to four "IDSP virtual channels" from a single sensor.<br  />
</p>
<p ><b>Question 3: </b> Why are there artifacts at the bottom of the channels?<br  />
 <b>Answer: </b> For the multi-VIN design, the DSP requires that each channel output height in the canvas is a multiple of 16. If the height is a multiple of eight, the DSP will repeat the last line eight times. As a result, the application can use the channel process order to have the latter channel output content cover the repeated lines of the former. If the latter channel content does not cover the repeated lines, users will most likely see artifacts at the bottom of the channel views.<br  />
</p>
<p ><b>Question 4: </b> What is the relationship between the sensors, the physical VIN controllers, and the IDSP channels?<br  />
 <b>Answer: </b> The following table provides a list of typical use cases for different combinations of sensors, physical VIN controllers, and the IDSP channels.<br  />
</p>
<a class="anchor" id="typical_use_cases_for_different_sensors"></a>
<table class="doxtable">
<caption>Typical Use Cases for Different Sensors.</caption>
<tr>
<th>Sensor </th><th>Physical VIN Controllers </th><th>IDSP Channels </th><th>Typical Use Cases </th></tr>
<tr>
<td align="center">1 </td><td align="center">1 </td><td align="center">1 </td><td>Standard single-sensor camera </td></tr>
<tr>
<td align="center">1 </td><td align="center">1 </td><td align="center">&gt;1 </td><td>IDSP virtual channel </td></tr>
<tr>
<td align="center">&gt;1 </td><td align="center">1 </td><td align="center">&gt;1 </td><td>Multi-sensor camera where the number of sensors exceeds the number of physical VINs.<br  />
 An external SERDES chip, such as B6, is needed to mux these sensors together into the line-interleaved format.<br  />
 </td></tr>
<tr>
<td align="center">&gt;1 </td><td align="center">&gt;1 </td><td align="center">&gt;1 </td><td>Standard multi-sensor cameras </td></tr>
<tr>
<td align="center">&gt;1 </td><td align="center">&gt;1 </td><td align="center">1 </td><td>Multiple sensors are combined into one IDSP output.<br  />
 1: Color filter array (CFA) sensor + infrared (IR) sensor fusion.<br  />
 2: CFA sensor + thermal sensor fusion.<br  />
 Simple blending with an optional negative image with a Chroma overlay based on the temperature.<br  />
 </td></tr>
</table>
<hr  />
<h1><a class="anchor" id="multi_vin_design_doc_license"></a>
7 License</h1>
<p >Copyright (c) 2024 Ambarella International LP.</p>
<p >This file and its contents ( "Software" ) are protected by intellectual property rights including, without limitation, U.S. and/or foreign copyrights. This Software is also the confidential and proprietary information of Ambarella International LP and its licensors. You may not use, reproduce, disclose, distribute, modify, or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates. In the absence of such an agreement, you agree to promptly notify and return this Software to Ambarella International LP.</p>
<p >THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
