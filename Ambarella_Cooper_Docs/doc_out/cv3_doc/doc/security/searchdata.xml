<?xml version="1.0" encoding="UTF-8"?>
<add>
  <doc>
    <field name="type">page</field>
    <field name="name">system_integrity_protection</field>
    <field name="url">d0/dfd/system_integrity_protection.html</field>
    <field name="keywords"></field>
    <field name="text">Intellectual Property Protection Intellectual Property Protection Pan Shi provides two major features for intellectual property protection unit licence protection ULP which prevents one license from covering multiple devices and neural network NN model protection NMP which protects the vendor’s NN model from being reverse-engineered by attackers For unit license protection ULP the software algorithm vendor issues a unit license to devices the device with the unit license is able to run the vendor’s software algorithm however the device without the unit license is not able to run the vendor’s software algorithm There are two online verification approaches unique ID and non-forgeable unique ID Additionally there are two on-chip verification approaches via the external hardware module and via AMBA on-chip verification Online verification offers better device management while the on-chip verification is faster and is lower cost because it does not require verification cloud service Table 1 1 Comparisons Between Different Unit License Approaches Unique ID Non-Forgeable Unique ID External HW Module Ambarella On-Chip Verification Cost No extra cost No extra cost HW module cost No extra cost Forge License Easy duplicate unique ID Difficult Difficult Difficult Requires Online Verification Yes Yes Depends on implementation Not required Verify Time Cost Typical 5 0 0 ms – 2 0 0 0 ms varies with different networks and servers Typical 5 0 0 ms – 2 0 0 0 ms varies with different networks and servers Typical 2 0 ms – 1 0 0 0 ms varies with different hardware CV0 3 ms or CVflow 9 0 0 ms Individual devices must possess unique IDs and therefore require different unit licenses If the unique ID is forgeable the attacker is able to tamper with a batch of devices with one unique ID The following diagram shows the problems of a forgeable unique ID marked in yellow on the right side Figure 1-1 Problems of Forgeable Unique ID Vendors who choose the online verification approach must use a non-forgeable unique ID to protect the unit license The ULP in the Ambarella Flexible Linux Software Development Kit SDK supports both non-forgeable unique ID and AMBA on-chip verification The software algorithm vendor uses its private key to issue a “unit license” to each device If a device has a valid unit license then it is able to run the vendor’s software algorithm otherwise the vendor’s software algorithm is not available Vendors can use this mechanism to charge per device unit A device with a unit license is called an “activated device” a device without a unit license is called a “not-activated device” Figure 1-2 Activated Device and Not-Activated Device This section describes the keys and certificates associated with the ULP solution followed by a table listing the format owner confidentiality and storage information of the related keys and certificates The vendor license key VLK is an asymmetric key ED25519 The vendor generates the VLK and must maintain confidentiality of the private VLK The private VLK owner is able to issue a unit license therefore the vendor maintains the private VLK’s confidentiality The owner is the only entity to issue the unit license The vendor must send the public VLK to Ambarella and Ambarella will issue a license certificate to the vendor The public VLK is embedded inside the license certificate The Ambarella certificate key ACK is an asymmetric key ED25519 Ambarella uses the ACK to issue a license certificate for vendors The Ambarella platform key APK is an asymmetric key ED25519 The APK is used in scenarios where providing the ULP transaction is being conducted on the actual Ambarella platform not a simulator Note that there are two APKs one for CVflow and one for the CV0 library The device identity key DIK is an asymmetric key ED25519 The DIK is dynamically derived from the chip hardware’s unique information and the vendor’s license certificate therefore it is not statically stored on the chip Additionally the DIK is unique per chip different vendors will have unique DIKs This design prevents cross-vendor attacks and analyses The client key is the vendor’s customer identity key it is also asymmetric ED25519 The vendor’s customer must keep the private client key confidential The public client key is sent to the vendor’s license server during registration and the vendor’s server stores it in its database The certificate authority key is an asymmetric key RSA or ECDSA which is used to sign the client application CA certificate or the server certificates The server key is the server’s identity key it is also asymmetric RSA or ECDSA The server key proves that the server is not fake during TLS The license certificate which is issued by Ambarella embeds and protects both the public VLK and the public APK It is a binary file with a length of 2 5 6 bytes Typically the license certificate is distributed together with the vendor’s software package The license certificate is required for chips that invoke ULP-related application programming interfaces APIs The CA certificate is the root certificate of the TLS issued by the vendor or a third-party CA The CA certificate is in a standard x.509 format The server certificate is a certificate of a server that is part of the chain of trust CoT while the CA certificate is the root of the CoT The device encryption key DEK is a symmetric key advanced encryption standard AES The DEK is dynamically derived from the chip hardware’s unique information and vendor’s license certificate therefore it is not statically stored on the chip The DEK is unique per chip some vendors will have different DEKs for the same chip This design prevents cross-vendor attacks and analyses The package encryption key PEK is a symmetric key AES Because the PEK is used to encrypt the neural network NN model the vendor must maintain the PEK’s confidentiality The DEK and PEK are only required for ‘ULP NMP’ cases If only the ULP case is used users can disregard the DEK and PEK The following table lists the related keys and certificates Table 1 2 Related Keys and Certificates Format Owner Keep Confidential Storage and Comment VLK Private ED25519 Vendor Yes the vendor keeps the private VLK confidential Stored at the vendor license server in encrypted form Public No the vendor sends the public VLK to Ambarella Stored at the license certificate ACK Prvate ED25519 Ambarella Yes Ambarella keeps the private ACK confidential Public Yes the chip keeps the public ACK confidential APK Private ED25519 Chip Yes the chip keeps the private APK confidential Public No the public APK is inside the license certificate Stored at the license certificate DIK Private ED25519 Chip Yes the chip keeps the private DIK confidential The DIK is unique per chip On the same chip different vendors different license certificates will receive different DIKs Public No the public DIK is a device unique ID Client key Private ED25519 Vendor’s customer Yes the vendor’s customer keeps the private client key confidential Stored at the deployment tool side in encrypted form Public No the vendor’s customer sends the public client key to the vendor license server Stored at the license server’s database CA key Private RSA or ECDSA Vendor or third-party CA Yes the vendor or third-party CA keeps the private CA key confidential Public Server key Private RSA or ECDSA Vendor Yes the vendor keeps the private server key confidential Public License certificate Binary Ambarella and Vendor No Ambarella issues a certificate to the vendor Distributed by the vendor CA certificate X.509 Vendor No the vendor distributes its CA certificate to its customer Stored at the vendor’s server side and the client’s deployment tool Server certificate X.509 Vendor No Stored at the vendor’s server and the client’s deployment tool DEK Optional AES Chip Yes the chip keeps the DEK confidential DEK is unique per chip On the same chip different vendors different license certificates will receive different DEKs PEK Optional AES Vendor Yes the vendor keeps the PEK confidential Stored at the vendor’s license server in encrypted form The vendor generates a VLK and uses this VLK to issue licenses via a license server Each manufacturer customer of the vendor uses a deployment tool to distribute the unit license activating devices The manufacturer must register an account with the vendor’s approval The vendor also specifies the number of licenses for each account manufacturer The connection between the manufacturer’s deployment tool and the vendor’s license server uses TLS along with a bi-directional authentication process This design prevents attacks from the internet The DIK is used as a device ID the VLK sign “public DIK meta” is used as a unit license If the vendor maintains confidentiality of its private VLK then only the vendor can generate unit licenses Because each device has a unique device ID public DIK each unit license applies only to a single device Engineering samples may have the same device ID but mass-production MP chips have unique device IDs Note that the unit license file is 2 5 6 bytes therefore the deployment process will require a writeable space to store the unit license file The unit license file location is configurable in the lc file The product design must consider the writable space in the file system for this feature Figure 1-3 License Deployment Process There are two license verification methods local verification and online verification The Ambarella Flexible Linux SDK supports both methods and the vendor can choose according to their requirements While local verification is fast and does not require cloud service for the license verification online license verification provides better management for devices Ambarella’s CVflow CV0 library performs a unit license check and reports the result to the vendor’s software This license verification process does not require network access The license verification process is as follows “Pub ACK” verify “license certificate” retrieve “Pub VLK” verify that the “unit license” is valid The vendor’s software triggers the license verification process by invoking the related application programming interfaces APIs For more details on verifying license APIs refer to ambarella/security/ulp_nmp/common/platform_ cvflow.c and platform_cv0.c The APIs are as shown below The CVflow CV0 library response also includes the ED25519_sign APK challenge and the ED25519_sign DIK challenge The challenge is sent by the vendor’s software and is a nonce from the random number generator RNG The challenge includes a random nonce in order to prevent a “replay attack” The replay attack records and reuses historic valid responses As such the random nonce guarantees that each challenge is different consequently historically valid responses cannot be reused ULP implementation also supports online license verification The key purpose is to provide a non-forgeable unique ID The non-forgeable unique ID includes a random challenge a unique ID and an APK signature The server generates the random challenge and verifies the APK signature in order to ensure that the unique ID has not been forged Figure 1-4 Non-Forgeable Unique ID There are four approaches for unit license protection “unique ID online verification” “non-forgeable unique ID online verification” “external hardware module” and “AMBA chip verification” The primary difference between a unique ID and a non-forgeable unique ID is that the non-forgeable unique ID can prevent multiple chips from being exploited with a tampered duplicated ID running on a single license Additionally the primary difference between the external hardware module and the Ambarella chip verification is cost As described previously the Ambarella Flexible Linux SDK supports two approaches “non-forgeable unique ID online verification” and “AMBA chip verification” The comparison list is as follows Table 1 3 Comparison Table of Different Unit License Approaches Unique ID Non-Forgeable Unique ID External Hardware Module Ambarella Chip Verification Cost No extra cost No extra cost Hardware module cost No extra cost Forge license difficulty Easy duplicate unique ID Difficult Difficult Difficult Online verification service requirement Required Required Depends on the implementation Not required Speed of license verification Depends on the network speed and the server capability Depends on the network speed and the server capability Fast Fast For the green-colored components shown in the following image the Linux SDK provides sample code for the evaluation of the information maintained by the software vendor For the blue-colored components the SDK includes the source code Figure 1-5 On-Chip Software Hierarchy For the green-colored components shown below the Linux SDK provides the sample code for the evaluation of the information maintained by the software vendor Figure 1-6 Software Hierarchy on the Linux PC With the reference code the vendor is able to support multiple customers and the license server manages transactions in parallel The system diagram showing support for multiple customers is below Figure 1-5 System Diagram Showing Support for Multiple Customers The Ambarella ULP sample code demonstrated in the following sections includes two parts one part runs on the SoC and the other runs on Linux Ubuntu Select menuconfig below Amba build Yocto build On CV5x CV7x CV3 chips “by CVflow” and “by CV0 library” can be selected simultaneously The license deploys and verifies the unit test ulp_nmp_pt_activate and ulp_nmp_pt_check_license which is located under on the SoC The default option uses the default key and certificate to set up the ULP and NMP refer to 2.4 Quick Launch User Guide If using the key generated by the user “ULP use product certs” must be selected refer to 2.2 Launch from Scratch User Guide Because the sample code on Linux Ubuntu requires OpenSSL install it first The minimum-required version of OpenSSL is 1.0.2 Generate a random seed for OpenSSL Go to the source code location and compile The servers and tools are placed in Components related to ULP include the license server the deployment tool and the provisioning tool on the device The following sections describe how to launch the license server and tools after compiling and installing the configurations Users can also refer to the help file located at from_scratch_steps.txt This chapter includes key generation Keep the private key and encryption key confidential retain the passphrase for each key and enable backup storage for the keys There is no recovery option for a lost key file or forgotten passphrase Go to the source code location compile and install Go to the license sever location First-Time Setup The license server requires some prerequisites the CA key and certificate the server key and certificate the vendor license key and certificate the package encryption key and so on The “first time setup” steps show how to generate or get those prerequisites Typically “first time setup” must be performed only once because it generates new keys and replaces existing keys If the key file is replaced there is no way to recover it Users must be very cautious when executing those command lines only do so when necessary Before generating keys change the key passphrases pass pass 1 2 3 4 and passphrase 1 2 3 4 for the following command lines 1 2 3 4 is the default passphrase for test purposes only DO NOT use it in production Generate a CA key and a CA certificate Generate a server key and issue a server certificate Generate the VLK Generate the PEK This step is only necessary when it is combined with NMP otherwise it can be skipped Send the public VLK to Ambarella and get the license certificate from Ambarella Note that “by CVflow” and “by CV0 library” are different certificate files Copy the license certificate to product_certs/ By CVflow By CV0 Copy the license certificate file for the device Launch the License Server When the prerequisites are ready the command line below will launch a license server Choose ulp_license_svr_cvflow.lc or ulp_license_svr_cv0.lc accordingly as they use different certificate files By CVflow By CV0 library After entering the correct passphrases for “private server key ” “private VLK key ” and “PEK ” the server is running and the console displays the following information The highlighted portions are the prompts for users to enter the default passphrase “1234.” Users must immediately change the default passphrase to a more secure passphrase as “1234” is used for test purposes only Go to the following location to find the deployment tool First-Time Setup The deployment tool requires the following prerequisites the CA certificate the public vendor license key and the account key The “first-time setup” steps show how to generate or obtain the prerequisites Typically “first-time setup” is required only once However because the setup process generates keys and replaces existing keys users must execute command lines with caution and only when necessary as the key file is not recoverable Before generating keys change the passphrases “-pass pass 1 2 3 4 ” and “ passphrase 1 2 3 4 ” for the following command lines “1234” is the default passphrase for test purposes only DO NOT use it in production Obtain the CA certificate and the public VLK from the vendor Generate the client key for the account Launch the Deployment Tool When the prerequisites are ready the command line below will launch the deployment tool Users must specify the correct license server IP address and port in ulp_nmp_deployment_tool.lc The deployment tool then prompts users to enter the client’s private key passphrase This key is the identity key for the client vendor’s customer After entering the private key’s passphrase “1234” ENTER the deployment tool runs and the console displays the following information The login prompt is displayed If the account is unregistered users must register it There are two approaches to registering an account manual and interactive For the manual approach users send the “account name” and “public account key file” to the server side and wait for the server side’s approval For more details regarding manual approval on the server side refer to Approve_an_Account_Manually For the interactive approach see the information below For more details regarding interactive approval on the server side refer to Approve_an_Account_Interactively Users must type “y ENTER” to post a registration request to the server Next users must wait for approval from the server side The server side also specifies the total number of licenses for this account After approval the console outputs the log as shown below including the total number of licenses The deployment tool is now ready to activate the device There are two approaches to approve an account interactive and manual Approve an Account Interactively Type “y ENTER” to approve Next specify the “granted license number” and the “metadata index” for this account to complete registration The console displays this account’s settings as shown below Approve an Account Interactively After a new account is registered on the server side the following prompt appears Type “y ENTER” to approve Next specify the “granted license number” and the “metadata index” for this account to complete registration The console will display this account’s settings as follows Approve an Account Manually Go to the database directory of the license server Create a new dir The dir name is the account name Copy the account’s public key file to this folder Then create two new text files one is for the total license number total_license_num.txt and the other for the metadata index metadata_ index.txt The files are as shown below Those two text files contain one digital number so the user can edit the number as required For example total_license_num.txt has a digital number of 1 0 0 0 0 and metadata_index.txt has a digital number of 0 After this process is complete restart the license server program By default the IP address of the device is 10.0.0.2 Once ulp_nmp_pt_activate is running the deployment tool connects to it via device_url device_port in the lc file To prepare for the running of the provisioning tool PT users must copy ambarella/security/build/ulp_nmp_simulate_device to DEVICE_PATH Then the provisioning tool can run on the device PT Tool by CVflow After activation pub_dik_cvflow.bin and unit_license_cvflow.bin are generated For this chip unit_license_cvflow.bin is the unit license PT Tool by CV0 Library After activation pub_dik_cv0.bin and unit_license_cv0.bin are generated For this chip unit_license_cv0.bin is the unit license To prepare for the running of the provisioning tool users must copy ambarella/security/build/ulp_nmp_simulate_device to DEVICE_PATH Then the provisioning tool can run on the device PT Tool by CVflow ulp_nmp_pt_check_license reports the check license result PT Tool by CV0 Library ulp_nmp_pt_check_license reports the check license result The software vendor must integrate this check code into the software The function call thiz- platform.verify_license checks the Cvflow- CV0 library-returned response and checks the response’s signatures Note that the random challenge is created by an RNG so as to prevent a replay attack ULP-related components include the license server the deployment tool and the provisioning tools on the device The following sections describe how to proceed with setting up and using the pre-set test files Users can also refer to the help file located at txt The process in this chapter copies the pre-set keys and certificates to the server/deployment_tool/provisioning_tool location therefore it will replace the existing keys and certificates If those existing keys and certificates are required back them up first Otherwise those replaced keys and certificates will be lost Go to the source code location compile it and install it together with the pre-set test files Go to the license server’s location and launch the server By CVflow By CV0 library After entering the correct passphrases for the private server key the private VLK key and PEK the server begins running Go to the following location to launch the deployment tool Users must specify the correct license server IP address and port in ulp_nmp_deployment_tool.lc The deployment tool then prompts the user to enter the client’s private key passphrase This key is the identity key for clients vendor’s customer After entering the private key’s passphrase “1234 ENTER” the deployment tool begins There are two approaches for approving an account interactive and manual Approve an Account Interactively After a new account is registered on the server side the following prompt appears Type “y ENTER” to approve Next specify the granted license number and the metadata index in order for this account to complete the registration The console will display this account’s settings as shown below Approve an Account Manually Go to the database directory of the license server Make a new dir The dir name is the account name Copy the account’s public key file to this folder and create two new text files one is for the total license number total_license_num.txt and the other is for the metadata index metadata_index.txt The files are as shown below rw-rw-r 1 amba_test amba_test 1 JUN 8 1 9 3 5 metadata_index.txt rw-rw-r 1 amba_test amba_test 3 2 JUN 8 1 9 3 5 pub_cli.bin rw-rw-r 1 amba_test amba_test 5 JUN 8 1 9 3 5 total_license_num.txt Those two text files only contain one digital number so the user can edit the number as required For example total_license_num.txt has a digital number of 1 0 0 0 0 and metadata_index.txt has a digital number of 0 Refer to 2.2.5 Run the Provisioning Tool to Deploy the License for more information Refer to 2.3 Run Sample Code to Check the License for more information The location of the configuration file for the license server is as follows lc or ulp_license_svr_cv0.lc The following describes each field nn_model_protection NMP is enabled or disabled If users only require a per-unit license this field is disabled debug_log if set to 1 it will print the debug information listen_port the listening TCP port db_path the database path priv_ca_pem the CA private key that signs the CA certificate ca_crt the CA certificate in X509 format The CA certificate is the root certificate of a CoT server_crt the server certificate in X509 format The server certificate is signed by the CA priv_svr_pem the server private key The server’s public key is inside the server certificate pub_cli_bin each client’s account public key file name in the database cli_total_license_num each client’s account license total number file name in the database cli_metadata_index each client’s account metadata index file name in the database priv_vlk_enc the private VLK file in encrypted form priv_vlk_enc_shadow the private VLK file’s passphrase shadow file pub_vlk the public VLK file license_cert the license certificate from Ambarella in binary format The location of the configuration file for the license server is lc The following describes each field debug_log if set to 1 it will print the debug information remote_url the license server’s URL or IP address remote_port the license server’s TCP port device_url the device’s IP address device_port the device’s TCP port ca_crt the CA certificate in X509 format The CA certificate includes a CA’s public key pub_vlk the public VLK key priv_cli_enc_bin the client’s account private key in encrypted form pub_cli_bin the client’s account public key The provisioning tool includes ulp_nmp_pt_activate and ulp_nmp_pt_check_license The location of the configuration file for the provisioning tool is lc or pt_cv0.lc The following describes each field debug_log if set to 1 it will print the debug information listen_port the device’s listening port TCP license_cert the license certificate platform CVflow or CV0 this is the field to choose from the CVflow or CV0 library approach unique_id_file the unique ID file unit_license_file the unit license file dek_encrypt_pek_file the DEK encrypt PEK file digest_file the digest file By default the database path is under the server’s directory build/ulp_nmp_license_server/db Under the database the first level subdirectory is an account Each account’s subdirectory includes three files pub_cli.bin metadata_index.txt and total_license_num.txt Users can check and edit the total license number and metadata index for each account In addition to the online register approve account creating the subdirectory and then placing those three files has the same function as the register approve account When the account starts to activate devices the account’s subdirectory records each activated device’s information the unique ID and the unit license file Those files are located in the subdirectory of the unique ID The license is a signature of the “unique_id metadata” Metadata is managed by the software vendor the vendor is able to embed the information into the license as required Additionally the license server supports multiple metadata types so the software vendor is able to apply various types of metadata for different customers Typically metadata is used by the vendor to identify the unit license’s capability Different price points receive different services It is easy for vendors to modify the metadata definition in the source code check metadata.c at the license server The metadata.c is a reference implementation of eight metadata If users are not required to use the license server to distribute issue a license they can issue a license manually using an offline approach For additional help refer to offline_issuer_steps.txt Go to the offline issuer location Offline issuer command The parameters of the ulp_nmp_offline_issuer are described below the cavalry_pub_dik.bin from the target device chip the index of the metadata the unit license file to issue a license for the device The process is as follows Obtain pub_dik_cvflow.bin or public_dik_cv0 from the target device chip Use the offline tool to generate the license manually Deploy the license file to the device unit_license_cvflow.bin or unit_license_cv0.bin NMP protects NN models on Ambarella chips The NN model in NAND and in memory are in encrypted forms When enabling NMP CVflow loads the encrypted model decrypts it and then executes it There is a secure channel for the vendor server to transfer the model’s encryption key to CVflow in the deployment stage CVflow re-encrypts the model key and stores it in NAND The NN model exists in encrypted form on the Linux side Then when it is loaded into CVflow it is decrypted and executed Figure 3 1 NN Model Protection Concept The primary objective of NMP is to protect the model encryption keys There are two main keys PEK and DEK The PEK generated by the vendor is used to encrypt the NN model within a software release package It is the vendor’s responsibility to keep the PEK confidential DEK is used to encrypt the PEK on the device The DEK is unique for each chip and can only be accessed by CVflow When CVflow receives the PEK it decrypts and re-encrypts the PEK with the DEK then the re-encrypted PEK is stored back to the file system A major design target of the deployment process is the secure distribution of the PEK to CVflow The Ambarella SDK uses X25519 for key exchange in addition to ED25519 for identity authentication in order to set up a secure channel between the software vendor’s server and CVflow To enhance the security level the sample code in the SDK uses a bi-directional authenticated TLS for internet communication The two cryptography layers of defense include TLS RSA ECDSA DH ECDH and ED25519 X25519 The deployment process is typically used in conjunction with “unit license” distribution For unit license protection refer to Unit License Protection Figure 3 2 Distributing the PEK in a Secure Channel If the vendor’s PEK remains the same the online upgrade is the same as the plaintext NN model upgrade Additionally if the PEK does not change the DEK-encrypted PEK is not required to change However if the PEK changes the device can re-trigger a new key exchange for the new PEK CVflow then re-encrypts the new PEK and stores it back on the Linux side Figure 3 3 Distributing the PEK in a Secure Channel CVflow loads the encrypted model along with the encrypted PEK and digest CVflow decrypts the PEK first and then uses the PEK to decrypt the NN model and execute the model Figure 3 4 Device Working Process For green-colored components the Linux SDK provides the sample code for evaluation The software vendor is responsible for their maintenance Figure 3 5 Software Hierarchy on Chip For green-colored components in the following image the Linux SDK provides the sample code for evaluation The software vendor is responsible for their maintenance Figure 3 6 Software Hierarchy on PC Each software vendor can support multiple customers Additionally the license server and upgrade server can manage transactions in parallel as shown below Figure 3 7 Multi-Customer Support Users can compile the Ambarella NN model protection sample code on the SoC and on the Linux Ubuntu platform Refer to the following to compile the sample code Select menuconfig below Amba build The provisioning tools ulp_nmp_pt_activate are under on the SoC Yocto build Go to the source code location and compile The servers and tools are placed on For a encrypted NN model with PEK users can also refer to ulp_nmp/doc/derive_pek_and_encrypt_model.txt Go to the following license server location Generate the PEK if it is not yet generated If PEK is already generated re-generation is not required Decrypt the PEK Encrypt the model via the PEK For more information about Cavalry generation and vas_output refer to the related CVflow documents Show model encryption status Load the encrypted model and execute The dev_encrpted_pek.bin and dev_encrypted_pek.digest are generated after deployment device activation Note that Cavalry must be loaded first on the chip Components related to NMP include the license server the deployment tool and the provisioning tool on the device The following sections describe how to launch the license server and tools after compiling and installing the configurations Users can also refer to the help file located at txt The process in this chapter includes key generation It is important that users keep the private key and encryption key confidential in addition to maintaining a record and backup of the key passphrases as security of the system is dependent on proper key maintenance Moreover because there is no method for recovering lost or forgotten key files it is vital that users prioritize key maintence in order to maintain system security Go to the source code location then compile and install the configurations Refer to 2.2.2 Launch the License Server for more information Only change the lc file when launching the server Refer to 2.2.3 Launch the Deployment Tool for more information Refer to 2.2.4 Approve an Account for more information By default the IP address of the device is 10.0.0.2 Once ulp_nmp_pt_activate is running the deployment tool connects to it via device_url device_port in the lc file To prepare copy ambarella/security/build/ulp_nmp_simulate_device to DEVICE_PATH Then run the provisioning tool on the device After activation pub_dik_cvflow.bin and unit_license_cvflow.bin will be generated unit_license_cvflow.bin is the unit license for this chip At the same time a re-encrypted PEK dev_encrypt_pek.bin and a digest file dev_encrypt_ pek.digest are generated Those two files are required for CVflow load encrypted modeling and execution Refer to 4.2.2 Encrypt Model with PEK for more information NMP-related components include the license server the deployment tool and the provisioning tools on the device The following sections describe how to proceed with setup using the pre-set test files Users can also refer to the help file located at ulp_nmp_quick_launch_steps.txt Because the process in this chapter includes copying the pre-set keys and certificates to the server/deployment_tool/provisioning_tool location it will replace the current keys and certificates If the current keys and certificates are still required perform a backup otherwise the keys and certificate will be overwritten Go to the source code location Then compile and install together with the pre-set test files Refer to 2.2.2 Launch the License Server for more information Only change the lc file when launching the server Refer to 2.2.3 Launch the Deployment Tool for more information Refer to 2.2.4 Approve an Account for more information Refer to 4.3.5 Run the Provisioning Tool to Deploy PEK for more information The ULP NMP key tool can be used to generate the AES key bin its encrypted form bin and the corresponding shadow file shadow In some cases users may be required to change the key’s passphrase The following examples demonstrate how to change the VLK passphrase re-encrypt the key client account key and generate the corresponding shadow file Decrypt with Old Passphrase Remove Old Encrypted File and Shadow File Re-Encrypt with New Passphrase Remove the Plaintext Private Key</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">data_storage_protection</field>
    <field name="url">d1/d37/data_storage_protection.html</field>
    <field name="keywords"></field>
    <field name="text">Data Storage Protection Data Storage Protection The Ambarella Flexible Linux Software Development Kit SDK supports dm-crypt a standard feature in Linux for data partition encryption DPE which encrypts the entire partition Using the Linux kernel’s crypto application programming interface API framework and device mapper subsystem dm-crypt enables administrators to encrypt entire disks logical volumes partitions and single files The dm-crypt subsystem supports the Linux unified key setup LUKS structure which enables multiple keys to access the encrypted data as well as the ability to manipulate the keys such as changing the keys adding additional passphrases and more Follow the steps below to set up dm-crypt The configuration for the Linux kernel is as follows The configuration for the Ambarella platform is as follows Users can enable dm-crypt and test it from the user space Amba build Yocto build Cryptsetup is a command-line tool that interfaces with dm-crypt for creating accessing and managing encrypted devices The following is a simple test for cryptsetup Cryptosetup uses Armv8 crypto extensions to accelerate the advanced encryption standard AES speed Follow the steps below to test AES performance Ambarella provides different crypto libraries for data encryption AES is a popular block cipher for data encryption The Ambarella SDK supports 1 2 8 bit 1 9 2 bit and 2 5 6 bit AES as well as ECB CBC CTR XTR modes Ambarella recommends using the AES algorithm The paths for the prebuilt library and OpenSSL sample code are listed below OpenSSL prebuilt library ambarella/prebuild/oss/armv8-a/openssl AES OpenSSL sample code ambarella/security/validation/crypto_performance/ openssl OpenSSL can use the Armv8 crypto extension instructions to achieve a high AES performance The paths for library and sample code for the lightweight cryptography library in Linux are provided below Library code ambarella/security/lw_cryptography/src Sample code ambarella/security/lw_cryptography/unit_test The lightweight cryptography library does not use Armv8 crypto extension instructions and its AES performance is sub-optimal The paths for the native AES with crypto extension instructions in Linux are as follows Library code ambarella/security/crypto_engine/src/armv8_crypto_extension Sample code ambarella/security/crypto_engine/unit_test The path for Mbed TLS in Arm® trusted firmware ATF is as follows Library code ambarella/boot/tee/mbedtls Secure storage refers to data-at-rest protection DARP or data in an encrypted form in external storage The data encryption key is managed by the trusted OS OP-TEE and is inaccessible from the unsecure world The following diagram displays the data encryption flow Abbreviations used in the diagram include the following HUK hardware-unique encryption key unique to each chip on one-time programmable OTP SSK secure storage key unique to each chip TSK trusted application storage key unique to each application FEK file encryption key random per file HMAC hash-based message authentication code Figure 3-1 Data Encryption Diagram The paths for the example code of the client application CA and for the trusted application TA are as follows CA ambarella/boot/tee/optee_test/host/test_secure_storage TA ambarella/boot/tee/optee_test/ta/test_secure_storage Data protection by passphrase is demonstrated on the following page Figure 3-2 Data Protection by Passphrase Diagram The paths for the example code of the CA and TA are as follows CA ambarella/boot/tee/optee_test/host/data_encryption_aes_v2 TA ambarella/boot/tee/optee_test/ta/data_encryption_aes_v2</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">security_validation_guide</field>
    <field name="url">d2/d1d/security_validation_guide.html</field>
    <field name="keywords"></field>
    <field name="text">Version Updated Date Modification 0.0.1 2 0 2 3 1 2 2 1 Initial version Users can follow this guide to test the security features on CV5x CV7x CV3 Secure aspects Security Features Validation Guide System Integrity Protection Secure Boot Secure_Boot Online Upgarde Online_Upgrade Rescue Mode Rescue_Mode Linux DM-Verity Linux_Dm_verity System Reinforcement Secure Enhanced Bootloader Secure_Enhanced_Bootloader OP-TEE OP_TEE Data Storage Protection DM-Crypt Dm_Crpypt Data Encryption Data_Encryption Secure Storage Secure_Storage Intellectual Property Protection Unit License Protection Unit_License_Protection Neural Network Model Protection Neural_Network_Model_Protection Secure Hardware OTP One_Time_Programmable RNG Random_Number_Generator Key Tools Key_tools By default Ambarella provides three methods for users to store keys In the local software development kit SDK Use the remote procedure call RPC toolkits provided by Ambarella Use Amazom Web Service AWS Key Management Service KMS Users also can use their own key management service to store keys Refer to 5.1.1 Generating New Keys for the Local Approach Optional for more information When users prepare the development server these keys will automatically be generated Users can refer to 5.4 Setting Up the RPC Environment to set up RPC enviroment If users use the default configuration file provided by Ambarella they can can refer to 5.3 Compiling the SDK with a Secure Boot If users want to enable secure boot with Arm® TrustZone® from a non-secure boot configuration the following options should be selected Amba build Yocto build Users also must modify the system memory layout to enable secure boot with TrustZone refer to 1.4 System Memory Layout for more information If users want to enable secure boot without TrustZone from a non-secure boot configuration the following options should be selected Amba build Yocto build By default the Ambarella SDK stores keys in the local approach Users can store keys in other locations Set up the RPC enviroment refer to set_up_rpc_env Select RPC in the menuconfig base configuration file with secure boot enabled Amba Build Yocto build Compile the SDK with the RPC enviroment enabled Compile the security tools Set up the KMS key and environment users can use their own keys Get the public RoT key must be programmed into OTP and the kernel key must be compiled into boot_loader Select Using AWS KMS key to sign binary in the menuconfig base in the configuration file with secure boot enabled Amba build Yocto build Compile the SDK If users have their own key management service and they want to use the keys in it for secure boot the following Makefile must be modified with their own key signing methods For the kernel key RoT key and CoT root key check ambarella/security/boot_security/Makefile.security For the trusted application TA key in the open-portable trusted execution environment OP-TEE check the lines in the following files In ambarella/boot/tee/optee_os Refer to 5.5 Programming a Public Key into OTP for more information Refer to 5.6 Enabling Secure Boot for more information Refer to 5.7 Running Secure Boot for more information Users can follow the steps below to test whether secure boot is able to function The secure boot authentication chain inculudes three stages refer to 1.1 Authentication Chain If users use the wrong key to sign different partition boot fails at different stages Prepare two sets of images signed with key pair A and key pair B Burn image A onto the board Upgrade image B s kernel parition onto the board and reboot Boot should fail at the BLD stage with secure boot enabled or disabled Burn image A onto the board upgrade image B s BLD partition onto board then reboot With secure boot enabled boot should fail at the BL2 stage With secure boot disabled BL2 check pass boot failed at BLD stage because the kernel key in BLD changed Burn image A onto the board then upgrade image B s Arm trusted firmware ATF partition onto the board and reboot Boot should fail at the BST stage with secure boot enabled no print at console Burn image A onto the board then upgrade image B s BST partition onto the board and reboot Boot should fail at the ROM stage with secure boot enabled no print at console Set up the RPC toolkit refer to 1.1.2 Generate Keys for the RPC Approach for more information Compile the SDK with three sets of keys Set A is with default local keys Set B is with new generated keys RPC approach Set C is with new generated keys RPC approach replace with the default RoT key in the RPC server Case 1 Set A images should boot successfully with secure boot enabled Case 2 Set C images should boot successfully with secure boot enabled Case 3 Set A images Set B’s kernel partition k ernel_release.elf via AmbaUSB Boot should fail at the BLD stage with secure boot enabled Case 4 Set A images Set B’s BLD partition bld_release.elf via AmbaUSB Boot should fail at the BL2 stage with secure boot enabled BL2 check pass boot failed at the BLD stage because the kernel key in BLD changed with secure boot disabled Case 5 Set A images Set B’s ATF partition atf_release.elf via AmbaUSB Boot should fail at the BST stage with secure boot enabled no print at console Boot was successful with secure boot disabled Case 6 Set A images Set B’s BST partition bst_release.elf via AmbaUSB Boot should fail at the ROM stage with secure boot enabled no print at console Boot was successful with secure boot disabled Write 1 6 RoT keys(key0, key1, key2, and so on) into OTP and lock them By default the firmware is compiled with key0 and the board can boot successfully Revoke key0 and reboot The boot fails because key0 was revoked Replace the key with key1 and compile a new image When using key1 the key index in ambarella/boot/amboot/vif/bst.info must be changed Burn the new image signed with key1 and boot The expected result is boot sucess Users can use the xtest command in OP-TEE to test OP-TEE related features Refer to 2.1 Online Upgrade for more information Refer to 2.2 Rescue Mode for more information Refer to 3.1 Set Up dm-verity on the Ambarella Platform for more information Refer to Secure Enhanced Bootloader for more information Refer to 1.1 dm-crypt for more information Use data_encryption_aes_v2_test to perform AES encryption decryption in OP-TEE Both input.bin and dec.bin must be the same Use test_secure_storage to test secure storage in OP-TEE For secure storage datails refer to 3.1 Data at Rest Protection Refer to Unit License Protection User Guide for more information Check the results between the RAW neural network NN model and the encrypted model Refer to 4.1 Compile NN Model Protection Sample Code for the usage of neural network model protection NMP Run the scripts in ambarella/security/security_tools/scripts/test_encrypt_network_output.sh The result should be the same and CRC should not change with multi loop Performance should be amost the same for both RAW and encoded NNs Refer to 1.2 Program OTP for more information Generally users can use daily test to test OTP With TrustZone Without TrustZone Refer to RNG_Quality_Test for more information Ambarella provides several key tools for security issues refer to the following to test them test_pkey_openssl key_convertor key_tool_ed25519 test_digital_signature Users can test the crypto performance for Ambarella chips Refer to ambarella/security/validation/crypto_performance/openssl/help_crypto_performance.txt for more information Refer to ambarella/security/validation/crypto_performance/optee/help_crypto_performance.txt for more information</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">migration_guide</field>
    <field name="url">d2/dad/migration_guide.html</field>
    <field name="keywords"></field>
    <field name="text">Migration Guide Migration Guide Version Updated Date Modification 0.0.1 2 0 2 2 1 1 1 8 Initial Version The points below aid customers through the migration process from CV2x to CV5x CV7x CV3 In CV2x Ambaella uses RSA2048 SHA256 for secure boot For secure enhancement Ambaella uses ED25519 SHA512 for secure boot in CV5x CV7x CV3 Due to the cryptography algorithm upgrade there re some corresponding changes such as key size and key slot number key tools and remote procedure call RPC toolkit version In CV2x one-time programmable OTP can store three key pairs In CV5x CV7x CV3 OTP can store sixteen key pairs thus this is a capability enhancement Due to changes in the key selection approach Ambarella has introduced a new bootstrapper BST and To maintain compatibility with the original BST header the current design is as follows when secure boot is enabled ROM code will treat that the BST has a header when secure boot is disabled ROM code will treat the BST has no header If customers choose secure boot firmware FW POC 6 must be always ON POC 6 is unable to toggle secure boot on/off unlike CV2x Because secure USB boot mode is available when secure boot is enabled users can use USB boot to flash new FW Secure boot is not required to be turned off POC 6 does not need to be pulled off When secure boot is enabled on CV5x CV7x CV3 USB boot mode is still available UST also has a signature If costumers want to disable secure USB boot test_pogram_otp firmware with TrustZone or test_otp firmware without TrustZone can be used or Since secure USB boot also has signature protection it s NOT recommended to disable this feature secure USB boot can be used as a recovery mode in RMA process In CV5x CV7x CV3 secure boot will only take effect after Customers must write all public keys into OTP and lock them once If customers use the RPC approach the remote server changed from tz_dev_server to tz_dev_server_v2 and the usage is the same tz_dev_server_v2 autoapprove maxaccount d Below are the steps to program keys in CV5x CV7x CV3 step 2 and 3 are additional steps with the RPC server Generate sixteen key pairs use key_tool_ed25519 in ambarella/packages/security/key_tools/prebuild/key_tool_ed25519 Name key0 the first key used for the firmware as pri_rot.bin and copy it to the RPC server s folder Set up server and daemon refer to ambarella/packages/security/build/trustzone_secure_boot_toolkit_help.txt Compile the firmware Program sixteen keys into OTP and lock them Program the firmware If root of trust RoT key revocation is required the key index in FW and RoT key at the server side must always match For example the process is as shown replace nth pri_rot.bin at the server side restart the server change BST s key index to nth and recompile the SDK</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">user_privacy_protection</field>
    <field name="url">d3/d97/user_privacy_protection.html</field>
    <field name="keywords"></field>
    <field name="text">User Privacy Protection User Privacy Protection User privacy protection is a production-level concept Ambarella’s chips and software development kit SDK include essential base functions for user privacy protection The Ambarella Flexible Linux SDK supports image video processing and video content analysis VCA which can retrieve information without using personal information The secure storage can be used to protect data on the device The secure connection prevents information from leaking during the transfer The recommended principle of the user privacy protection is as follows Personal privacy information remains with the device The information is stored in encrypted form with a hardware-planted key and is never exposed to the external world As a result only the device retains the key Only the information without privacy can be transferred to the cloud server The transfer process is performed via a secure connection with bi-directional authentication</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">crypto_performance</field>
    <field name="url">d4/dc0/crypto_performance.html</field>
    <field name="keywords"></field>
    <field name="text">Crypto Performance Crypto Performance Version Updated Date Modification 0.0.1 2 0 2 3 1 2 1 7 Initial Version Armv8 includes a crypto extension which is a hardware module dedicated for crypto computation such as the advanced encryption standard AES and secure hash algorithm SHA It can be used with the Armv8 crypto extension instructions Ambarella recommends using it in conjunction with the OpenSSL library as it comes equipped with Armv8 crypto extension instructions As OpenSSL provides many approaches for running the same computations as AES users must choose the approach that utilizes the Armv8 crypto extension instructions not doing so can produce lower-than-expected results Rather than using OpenSSL users can directly utilize the Armv8 crypto instructions Refer to the following sample code Rather than using ambarella/security/crypto_engine/src/armv8_crypto_extension choose “computing via Armv8 crypto instructions” in OpenSSL refer to the sample code located at Ambarella/security/crypto_performance/openssl To obtain the crypto performance benchmarks refer to ambarella/security/crypto_performance/openssl/help_crypto_performance.txt The CV5x crypto performance table is provided below Broad configurations with different CPU dynamic random-access memory DRAM frequency settings can result in slight differences Table 1 2 Crypto Performance Table Category Cryptography Algorithm Computing Operation Performance Symmetric cryptography for data encryption AES-128 AES-128 GCM block size 1 0 2 4 1 1 6 2 MB per second AES-128 CTR block size 1 0 2 4 1 8 8 1 MB per second AES-128 CBC block size 1 0 2 4 1 9 8 2 MB per second AES-192 AES-192 GCM block size 1 0 2 4 1 0 7 1 MB per second AES-192 CTR block size 1 0 2 4 1 6 3 9 MB per second AES-192 CBC block size 1 0 2 4 1 7 4 3 MB per second AES-256 AES-256 GCM block size 1 0 2 4 9 9 2 MB per second AES-256 CTR block size 1 0 2 4 1 4 6 1 MB per second AES-256 CBC block size 1 0 2 4 1 5 3 4 MB per second SM4 SM4 block size 1 0 2 4 byte 6 0 MB per second Asymmetric cryptography for authentication digital signature sign verify RSA-2048 RSA-2048 sign 1 8 9 times per second RSA-2048 verify 6 8 8 9 times per second RSA-3072 RSA-3072 sign 6 0 times per second RSA-3072 verify 3 1 1 7 times per second RSA-4096 RSA-4096 sign 2 6 times per second RSA-4096 verify 1 7 6 7 times per second ECDSA NIST-p224 ECDSA NIST-p224 sign 6 8 2 7 times per second ECDSA NIST-p224 verify 2 8 3 0 times per second ECDSA NIST-p256 ECDSA NIST-p256 sign 1 2 1 9 3 times per second ECDSA NIST-p256 verify 3 5 4 5 times per second ECDSA NIST-p384 ECDSA NIST-p384 sign 2 8 9 times per second ECDSA NIST-p384 verify 3 9 1 times per second ECDSA NIST-p521 ECDSA NIST-p521 sign 7 0 5 times per second ECDSA NIST-p521 verify 3 3 0 times per second ED25519 ED25519 sign 1 3 5 4 5 times per second ED25519 verify 4 4 5 2 times per second Secure hash function SHA2 SHA2-256 block size 1 0 2 4 1 0 0 1 MB per second SHA2-384 block size 1 0 2 4 2 6 1 MB per second SHA2-512 block size 1 0 2 4 2 6 1 MB per second SHA3 SHA3-256 block size 1 0 2 4 2 0 1 MB per second SHA3-384 block size 1 0 2 4 1 5 6 MB per second SHA3-512 block size 1 0 2 4 1 0 8 MB per second SM3 SM3 1 4 8 MB per second HMAC HMAC SHA2 HMAC SHA2-256 block size 1 0 2 4 9 8 0 MB per second HMAC SHA2-512 block size 1 0 2 4 2 5 5 MB per second HMAC SHA3 HMAC SHA3-256 block size 1 0 2 4 1 9 7 MB per second HMAC SHA3-512 block size 1 0 2 4 1 0 7 MB per second The CV5x crypto performance table in the open portable trusted execution environment OP-TEE is provided below Board configurations with different CPU DRAM frequency settings can result in slight differences Table 1 2 Crypto Performance in OP-TEE Table Category Cryptography Algorithm Computing Operation Performance Symmetric cryptography for data encryption AES-128 AES-128 GCM buffer size 1 3 1 0 7 2 8 1 4 MB per second AES-128 CTR buffer size 1 3 1 0 7 2 1 1 0 0 MB per second AES-128 CBC buffer size 1 3 1 0 7 2 6 7 9 MB per second AES-192 AES-192 GCM buffer size 1 3 1 0 7 2 7 6 9 MB per second AES-192 CTR buffer size 1 3 1 0 7 2 1 0 0 6 MB per second AES-192 CBC buffer size 1 3 1 0 7 2 6 0 7 MB per second AES-256 AES-256 GCM buffer size 1 3 1 0 7 2 7 1 8 MB per second AES-256 CTR buffer size 1 3 1 0 7 2 9 4 1 MB per second AES-256 CBC buffer size 1 3 1 0 7 2 5 5 6 MB per second Secure hash function SHA2 SHA2-256 buffer size 1 3 1 0 7 2 7 1 0 MB per second SHA2-384 buffer size 1 3 1 0 7 2 5 2 MB per second SHA2-512 buffer size 1 3 1 0 7 2 5 2 MB per second For other chips such as CV7x CV3 users can refer to Crypto_Performace to test the crypto performance for chips</field>
  </doc>
  <doc>
    <field name="type">source</field>
    <field name="name">security_main_page.h</field>
    <field name="url">d5/d3e/security__main__page_8h_source.html#l00001</field>
    <field name="keywords"></field>
    <field name="text"></field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">secure_hardware</field>
    <field name="url">da/d0f/secure_hardware.html</field>
    <field name="keywords"></field>
    <field name="text">Secure Hardware Secure Hardware Version Updated Date Modification 0.0.1 2 0 2 3 1 2 1 7 Initial Version One-time programmable OTP is a hardware component inside the CV5x CV7x CV3 system on chip SoC The total size of OTP is 8 KB OTP can be programmed only once if programmed incorrectly the chip will become unusable Ambarella s OTP has 3 2 7 6 8 bits The layout of OTP is divided into two sections the Ambarella-defined sections which comprises the first 1 6 1 2 8 bits and the user-defined sections which comprises the remainder The following table displays the properties of the Ambarella-defined OTP Table 1 1 OTP Data Layout No Bit Address DEC Bit Address HEX Bits OTP Function Lock Bit 1 0 6 3 0 x0000 0 x003F 6 4 Reserved by Ambarella Lock bit 0 2 6 4 8 6 0 x0040 0 x0056 2 3 sys_config Lock bit 3 3 8 7 9 2 0 x0057 0 x005C 6 unused 4 9 3 9 3 0 x005D 0 x005D 1 sys_config 5 9 4 9 5 0 x005E 0 x005F 2 sys_config 6 9 6 1 1 8 0 x0060 0 x0076 2 3 sys_config 7 1 1 9 1 2 4 0 x0077 0 x007C 6 unused 8 1 2 5 1 2 5 0 x007D 0 x007D 1 sys_config 9 1 2 6 1 2 6 0 x007F 0 x007E 1 sys_config 1 9 1 2 7 1 2 7 0 x007F 0 x007F 1 efuse_disable_jtag 1 1 1 2 8 1 9 1 0 x0080 0 x00BF 6 4 Reserved by Ambarella Lock bit 2 1 2 1 9 2 2 2 3 0 x00C0 0 x00DF 3 2 write_lock No lock 1 3 2 2 4 2 5 5 0 x00E0 0 x00FF 3 2 cst_seed Lock bit 4 1 4 2 5 6 3 8 3 0 x0100 0 x017F 1 2 8 Unique ID Lock bit 1 1 5 3 8 4 5 1 1 0 x0180 0 x01FF 1 2 8 cst_cuk Lock bit 4 1 6 5 1 2 7 6 7 0 x0200 0 x02FF 2 5 6 Reserved by Ambarella Lock bit 0 1 7 7 6 8 1 5 9 9 9 0 x0300 0 x3E7F 1 5 2 3 2 Reserved by Ambarella 1 8 1 6 0 0 0 1 6 0 1 5 0 x3E80 0 x3E8F 1 6 data_invalid No lock 1 9 1 6 0 1 6 1 6 0 1 6 0 x3E90 0 x3E90 1 anti_rollback_en 2 0 1 6 0 1 7 1 6 0 1 7 0 x3E91 0 x3E91 1 secure_usb_boot_disable 2 1 1 6 0 1 8 1 6 0 3 1 0 x3E92 0 x3E9F 1 4 misc_config 2 2 1 6 0 3 2 1 6 1 2 7 0 x3EA0 0 x3EFF 9 6 bst_ver_cnt 2 3 1 6 1 2 8 1 6 2 5 5 0 x3F00 0 x3F7F 1 2 8 serial_number Lock bit 5 2 4 1 6 2 5 6 1 6 3 8 3 0 x3F00 0 x3FFF 1 2 8 OTP_TEST Lock bit 6 2 5 1 6 3 8 4 1 6 6 3 9 0 x4000 0 x40FF 2 5 6 HUK Lock bit 1 1 2 6 1 6 6 4 0 1 6 8 9 5 0 x4100 0 x41FF 2 5 6 USER_CUK Lock bit 1 2 2 7 1 6 8 9 6 1 7 1 5 1 0 x4200 0 x42FF 2 5 6 AES_KEY_0 Lock bit 1 3 2 8 1 7 1 5 2 1 7 4 0 7 0 x4300 0 x43FF 2 5 6 AES_KEY_1 Lock bit 1 4 2 9 1 6 4 0 8 1 7 6 6 3 0 x4400 0 x44FF 2 5 6 AES_KEY_2 Lock bit 1 5 3 0 1 6 6 6 4 1 7 9 1 9 0 x4500 0 x45FF 2 5 6 AES_KEY_3 Lock bit 1 6 3 1 1 7 9 2 0 1 8 1 7 5 0 x4600 0 x46FF 2 5 6 ECC_KEY_0 Lock bit 1 7 3 2 1 8 1 7 6 1 8 4 3 1 0 x4700 0 x47FF 2 5 6 ECC_KEY_1 Lock bit 1 8 3 3 1 8 4 3 2 1 8 6 8 7 0 x4800 0 x48FF 2 5 6 ECC_KEY_2 Lock bit 1 9 3 4 1 8 6 8 8 1 8 9 4 3 0 x4900 0 x49FF 2 5 6 ECC_KEY_3 Lock bit 2 0 3 5 1 8 9 4 4 1 9 1 9 9 0 x4A00 0 x4AFF 2 5 6 USER_SLOT_0 Lock bit 2 1 3 6 1 9 2 0 0 1 9 4 5 5 0 x4B00 0 x4BFF 2 5 6 USER_SLOT_1 Lock bit 2 2 3 7 1 9 4 5 6 1 9 7 1 1 0 x4C00 0 x4CFF 2 5 6 USER_SLOT_2 Lock bit 2 3 3 8 1 9 7 1 2 1 9 9 6 7 0 x4D00 0 x4DFF 2 5 6 USER_SLOT_3 Lock bit 2 4 3 9 1 9 9 6 8 2 0 2 2 3 0 x4E00 0 x4EFF 2 5 6 USER_SLOT_4 Lock bit 2 5 4 0 2 0 2 2 4 2 0 4 7 9 0 x4F00 0 x4FFF 2 5 6 USER_SLOT_5 Lock bit 2 6 4 1 2 0 4 8 0 2 0 7 3 5 0 x5000 0 x50FF 2 5 6 ROT_KEY_0 Lock bit 8 4 2 2 0 7 3 6 2 0 9 9 1 0 x5100 0 x51FF 2 5 6 ROT_KEY_1 4 3 2 0 7 3 6 2 0 9 9 1 0 x5200 0 x52FF 2 5 6 ROT_KEY_2 4 4 2 0 9 9 2 2 1 5 0 3 0 x5300 0 x53FF 2 5 6 ROT_KEY_3 4 5 2 1 5 0 4 2 1 7 5 9 0 x5400 0 x54FF 2 5 6 ROT_KEY_4 4 6 2 1 7 6 0 2 2 0 1 5 0 x5500 0 x55FF 2 5 6 ROT_KEY_5 4 7 2 2 0 1 6 2 2 2 7 1 0 x5600 0 x56FF 2 5 6 ROT_KEY_6 4 8 2 2 2 7 2 2 2 5 2 7 0 x5700 0 x57FF 2 5 6 ROT_KEY_7 4 9 2 2 5 2 8 2 2 7 8 3 0 x5800 0 x58FF 2 5 6 ROT_KEY_8 5 0 2 2 7 8 4 2 3 0 3 9 0 x5900 0 x59FF 2 5 6 ROT_KEY_9 5 1 2 3 0 4 0 2 3 2 9 5 0 x5A00 0 x5AFF 2 5 6 ROT_KEY_10 5 2 2 3 2 9 6 2 3 5 5 1 0 x5B00 0 x5BFF 2 5 6 ROT_KEY_11 5 3 2 3 5 5 2 2 3 8 0 7 0 x5C00 0 x5CFF 2 5 6 ROT_KEY_12 5 4 2 3 8 0 8 2 4 0 6 3 0 x5D00 0 x5DFF 2 5 6 ROT_KEY_13 5 5 2 4 0 6 4 2 4 3 1 9 0 x5E00 0 x5EFF 2 5 6 ROT_KEY_14 5 6 2 4 3 2 0 2 4 5 7 5 0 x5F00 0 x5FFF 2 5 6 ROT_KEY_15 5 7 2 4 5 7 6 2 4 8 3 1 0 x6000 0 x60FF 2 5 6 MONO_COUNT_0 No lock 5 8 2 4 8 3 2 2 5 0 8 7 0 x6100 0 x61FF 2 5 6 MONO_COUNT_1 5 9 2 5 0 8 8 2 5 5 9 9 0 x6200 0 x63FF 5 1 2 MONO_COUNT_2 6 0 2 5 6 0 0 2 6 6 2 3 0 x6400 0 x67FF 1 0 2 4 USER_DATA_0 6 1 2 6 6 2 4 2 7 6 4 7 0 x6800 0 x6BFF 1 0 2 4 USER_DATA_1 6 2 2 7 6 4 8 2 8 6 7 1 0 x6C00 0 x6FFF 1 0 2 4 USER_DATA_2 6 3 2 8 6 7 2 2 9 6 9 5 0 x7000 0 x73FF 1 0 2 4 USER_SLOT_6 Lock bit 2 7 6 4 2 9 6 9 6 3 0 7 1 9 0 x7400 0 x77FF 1 0 2 4 USER_SLOT_7 Lock bit 2 8 6 5 3 0 7 2 0 3 1 7 4 3 0 x7800 0 x7BFF 1 0 2 4 USER_SLOT_8 Lock bit 2 9 6 6 3 1 7 4 4 3 2 7 6 7 0 x7C00 0 x7FFF 1 0 2 4 USER_SLOT_9 Lock bit 3 0 The Ambarella software development kit SDK supports programming OTP with or without a trusted operating system TOS such as the open programmable trusted execution environment OP-TEE When there is a TOS use test_program_otp When there is no TOS use test_otp The test_program_otp includes the client application CA and the pseudo trusted application PTA to program read the OTP CA SDK/external/tee/optee_test/host/test_program_otp.c PTA SDK/external/tee/optee_os/core/arch/arm/pta/pta_ambarella_otp.c Below are test_program_otp options The following are the test_program_otp prerequisites The following completes an OTP daily test The test_otp functions when there is no TOS OP-TEE depending on the amba_otp driver Further it includes a similar option to the test_program_otp as shown below The following performs an OTP daily test The table below describes each OTP region’s typical scenario ‘Mandatory’ means this region’s definition is defined by Ambarella ‘Recommended’ means this region can be customized If users want to change a recommended region’s usage the corresponding changes in code are also required Table 1 2 Typical Scenarios for Each OTP Region OTP Region Definition Scenario Comment sys_config Mandatory Configuration System configuration efuse_disable_jtag Mandatory Configuration Disable hardware debug port write_lock Mandatory Lock bits Each bit locks an OTP region cst_seed Recommended Planted seed key Customer-planted seed Unique ID Mandatory Unique ID Chip-unique ID cst_cuk Recommended Planted seed key Customer-planted key data_invalid Mandatory Secure boot For RoT key revocation secure_usb_boot_disable Mandatory Configuration Disables secure USB boot misc_config Recommended Configuration Customized configuration bst_ver_cnt Recommended Anti-rollback Monotonic counters can be used by the OTA program serial_number Recommended Serial number Product serial number OTP_TEST Recommended OTP function test OTP read write function test HUK Mandatory Chip key Root of TEE secure storage USER_CUK Recommended Planted seed key User-planted key AES_KEY_0 AES_KEY_3 Recommended Data encryption key Data encryption key users can specify their access to be secure world only or normal world accessible ECC_KEY_0 ECC_KEY_3 Recommended Authentication key Authentication key users can specify their access to be secure world only or normal world accessible USER_SLOT_0 USER_SLOT_5 Recommended Lockable data Customized data lockable ROT_KEY_0 ROT_KEY_15 Mandatory Root of trust key RoT key MONO_COUNT_0 MONO_COUNT_2 Recommended Anti-rollback Monotonic counters can be used by OTA program USER_DATA_0 USER_DATA_2 Recommended Data Customized data USER_SLOT_6 USER_SLOT_9 Recommended Lockable data Customized data lockable There are three types of unique IDs The first is the 2 5 6 bit digital signal processor DSP unique ID which is available after booting the DSP The second type is the 1 2 8 bit Ambarella-unique ID inside the OTP These two ID types are maintained by Ambarella and are easily accessible to the user The third type is another 1 2 8 bit space inside the OTP for the user’s unique ID Users can define and program their own ID Use the input output control IOCTL IAV_IOC_QUERY_INFO The sample code is provided below When Arm TrustZone is enabled use the following steps to read the unique ID When TrustZone is disabled use the amba_otp driver to access OTP with the configuration below This module is mutually exclusive with TrustZone therefore if TrustZone is enabled it will not function Amba build Yocto build Next use the following steps to read the Ambarella-unique ID The following reads the unique ID with test_otp The hardware monotonic counter is used to prevent a downgrade attack A downgrade attack refers to an attacker downgrading or rolling back firmware to an older version in order to exploit the known security vulnerabilities A version binding check with the hardware monotonic counter can detect and prevent this kind of attack There are three monotonic counters on CV5x CV7x CV3 the first two are 2 5 6 bits and the third is 5 1 2 bits The CV5x CV7x CV3 chip family includes true random number generator TRNG hardware The entropy source of the TRNG is the thermal noise of the SoC The Ambarella Linux SDK has enabled it in both the rich OS Linux and the TOS OP-TEE Drivers can be found in the following paths TRNG driver in OP-TEE ambarella/boot/tee/optee_os/core/drivers/ambarella_trng.c TRNG driver in Linux ambarella/kernel/linux-5.15 c TRNG driver in AMBoot ambarella/boot/amboot/src/bld/rng.c Sample code in Linux ambarella/security/validation/rng_quality Use the command below to obtain the random number from the TRNG Check the following configuration to build a binary with TRNG enabled To enable the hardware RNG in Linux select the following command OP-TEE-OS uses the hardware RNG No extra user application code is required To enable test_random in Linux select the following command Amba build Yocto build Generate RNG on the device Check the RNG quality Users can use the tools provided by NIST to check the RNG quality For more details about the tools refer to The Ambarella SDK provides this tool in ambarella/security/validation/rng_quality/sts-2.1.2 JTAG and USB boot are used only for debugging purposes Ambarella recommends that users disable them in an actual-use cases Force USB boot is automatically disabled when secure boot is enabled The JTAG eFUSE bit OTP63 must be set for JTAG and then JTAG can be disabled Use either of the following commands Or The two commands above set the JTAG eFUSE bit After the JTAG eFUSE bit has been set the JTAG_EN register AHBSP_JTAG_EN_REG can toggle JTAG on off mmio_clrbits_32(AHBSP_JTAG_EN_REG, BIT(0)) The logic is provided as shown in the table below Table 1 3 Logic JTAG eFUSE and Register Logic Table JTAG_en 0 JTAG_en 1 JTAG_efuse 0 JTAG available JTAG available JTAG_efuse 1 JTAG NOT available JTAG available In the flexible Linux SDK the JTAG_en is 0 by default The scenarios are as follows JTAG_en 0 JTAG_efuse 0 in the development stage JTAG is available for debugging purposes JTAG_en 0 JTAG_efuse will be set to 1 in the factory during the mass-production MP process then the JTAG is disabled JTAG not available to enhance the product’s security level JTAG_en 1 JTAG_efuse 1 performed by special firmware the special firmware writes JTAG_en to 1 in the secure world bring back the JTAG for the return material authorization RMA process’s debugging and analysis Users can add mmio_setbits_32(AHBSP_JTAG_EN_REG, BIT(0)) in ambarealla/boot/tee/arm-trusted-firmware/ambarella/ambarella_security.c to enable JTAG for the RMA process</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">system_reinforcement</field>
    <field name="url">db/d12/system_reinforcement.html</field>
    <field name="keywords"></field>
    <field name="text">System Reinforcement System Reinforcement The secure enhanced bootloader SEBLD is a bootloader with public key authentication only users who pass the authentication can execute commands inside the BLD console The BLD generates a random challenge to the user with an embedded public key and users must provide the correct response the digital signature of the random challenge Otherwise the commands in the BLD are not executed Only the private key owner can generate the correct response The SEBLD’s public key is embedded inside the BLD firmware For RSA2048 SHA256 the public key is in C source file format located in the folder ambarella/security/boot_security/locker_pubkey.c For ED25519 SHA512 the public key is embedded with bin format located in the folder ambarella/security/tz_sb_keys/local_keys/sebld_keys/ed25519/ pub_sebld.bin Before this feature is used users should already have their own key pair This can be performed by generating a new key pair or using an existing key pair The private key should be kept confidential Use the command below to replace the default key pairs that accompany the software development kit SDK Replace the existing private key in ambarella/security/tz_sb_keys/local_keys/sebld_keys Use the command below to derive the corresponding public key The private key should be kept confidential Ambarella recommends removing both pri_sebld.bin from the source code after the public key is derived Ambarella recommends storing the lock unlock state in the configuration CFG partition However because the CFG partition is not enabled by default users must first enable it To enable the CFG partition follow the steps below Yocto build is used as an example If using the legacy firmware layout the CFG partition must be selected in menuconfig If using the flexible firmware layout add the CFG partition in the profile file Use the command below to generate a blank cfg.bin Or use the pre-generated blank cfg.bin file in ambarella/security/boot_security/cfg.bin Modify ambarella/boards/cv5_timn/bsp.h and then set AMBOOT_CFG_SIZE If there is no CFG partition in a product the backup plan is to store the lock state in the PTB partition Check the MACROs in ambarella/security/boot_security/locker.c for SDK 1.0 use the keys in ambarella/packages/security/boot_security/locker.c “STORE_LOCK_STATUS” indicates the locker state “STORE_IN_CFG” indicates that the locker state should be stored in the CFG partition rather than in the PTB partition Android Fastboot tools can be downloaded from There are two approaches to enter Android Fastboot on an evaluation kit EVK board Execute “Fastboot” on the AMBoot console Enter Android Fastboot directly via general purpose input output GPIO If the product does not have a serial port Ambarella recommends that users choose the latter approach For the latter approach the board support package BSP code must be modified in order to enter into Android Fastboot directly via GPIO_DEBUG Add the highlighted part below in ambarella/boards/cv5_timn/bsp/bsp.c There are two approaches to execute commands in the bootloader the first uses the AMBoot console the second uses Android Fastboot The following sections demonstrate these two approaches using the ed25519 key for example Compile options To enable SEBLD select the following items in “make menuconfig” Amba build Yocto build Enter the AMBoot console press Enter and reboot Get the challenge The 4 0 byte challenge is shown below Use the private key to sign the challenge ED25519 for example RSA2048 is similar Use the signature to unlock the BLD in the AMBoot console When the bootloader is unlocked inputting help lists the available commands Lock BLD The message below signifies that no command is available after it is locked Compile Options To enable SEBLD and Android Fastboot select the following items in “make menuconfig” Amba build Yocto build Follow the steps below to execute the lock and unlock functions Enter Android Fastboot by pressing the GPIO_DEBUG button and rebooting An example of the board entering Android Fastboot is provided below Figure 1-1 Android Fastboot Get the challenge Use the private key to sign the challenge The signature file is sebld.sign Copy sebld.sign to the Android Fastboot tool folder Upload the signature to the board Unlock the BLD The following message will be displayed if the unlock was successful Figure 1-2 Unlock Android Fastboot Successful Then the other Android Fastboot commands are available for use For example the “boot” command can download firmware such as AmbaUSB Lock the BLD SELinux is the primary mandatory access control MAC mechanism built into a number of GNU Linux distributions SELinux originally began as the Flux Advanced Security Kernel FLASK developed by the Utah University Flux team and the U.S Department of Defense The development was later enhanced by the National Security Agency NSA and released as an open source software OSS The following figure shows a high-level diagram of the SELinux core components that manage the enforcement of the policy and is comprised of the following An object manager that knows the actions required for a particular resource such as a file and can enforce those actions for example allows it to write to a file if permitted by the policy A security server that makes decisions regarding the subject’s right to perform the requested action on the object based on the existing security policy rules A security policy that describes the rules using the SELinux policy language An access vector cache AVC that improves system performance by caching security server decisions Figure 2-1 High-Level Core SELinux Components Mandatory access control is a type of access control in which the operating system OS is used to constrain a user or process the subject from accessing or performing an operation on an object such as file disk memory and more Each of the subjects and objects include a set of security attributes that can be interrogated by the OS to check if the requested operation can be performed For SELinux the following are true Subjects are processes Objects are system resources such as files and sockets Security attributes are the security context The security server within the Linux kernel authorizes access using the security policy that describes the rules that must be enforced Users in GNU Linux are generally associated with human users such as Alice and Bob or operator system functions such as admin While this can be implemented in SELinux SELinux usernames are generally groups or classes of users For example all standard system users can be assigned an SELinux username of user_u Administration staff can be assigned under staff_u To further control access to type enforcement TE domains SELinux uses role-based access control RBAC This feature enables SELinux users to be associated with one or more roles where each role is then associated with one or more domain types as shown in the figure below Figure 2-2 Role-Based Access Control SELinux requires security context to be associated with each process or subject and object that is used by the security server to decide if access is permitted as defined by the policy The security context is additionally known as a ‘security label’ Within SELinux the security context is represented as variable-length strings that define the SELinux user their role a type identifier and an optional MCS MLS security range level shown below user:role type range The following table describes the user role type and range within the security context Table 2 1 Security Context User Role Type Range The SELinux user identity can be associated with one or more roles that the SELinux user is allowed to use The SELinux role can be associated with one or more types that the SELinux user is allowed to access When a type is associated with a process it defines what processes or domains the SELinux user the subject can access When a type is associated with an object it defines what access permissions are available to the SELinux object This field is known as a level it is only present if the policy supports MCS or MLS The entry can consist of the following A single security level that contains a sensitivity level and zero or more categories for example s0 s1 c0 A range that consists of two security levels separated by a hyphen for example ss0-s15 c0.c1023 A subject is an active entity generally in the form of a person process or device that enables information to flow among objects or that changes the system state Within SELinux a subject is an active process with an associated security context However a process can also be referred to as an object depending on the context For example A running process such as an active entity is a subject because it causes information to flow among objects or can change the system state The process can also be referred to as an object because each process has an associated object class called “process.” This process “object” defines what permissions the policy is allowed to grant or deny on the active process Within SELinux an object is a resource such as files sockets pipes or network interfaces that are accessed via processes also known as subjects These objects are classified according to which resource they provide access permissions relevant to their purpose for example read receive and write and are assigned a security context Each object consists of a class identifier that defines its purpose for example file or socket along with a set of permissions also known as access vectors that describe what services the object can manage read write send and so on When an object is instantiated it will be allocated a name for example a file could be called configured a socket or my_connection and a security context for example system_u:object_r selinux_config_t SELinux includes three major operation modes Enforcing SELinux is enforcing the loaded policy Permissive SELinux has loaded the policy but is not enforcing the policy rules This is generally used for testing as the audit log contains the AVC-denied messages Disabled The SELinux infrastructure is not enabled therefore no policy can be loaded These flags are set in the file SELinux includes two main types of audit events AVC audit events and SELinux-aware application events AVC audit events are generated by the AVC subsystem as a result of access denials or where specific events have requested an audit message SELinux-aware application events are generated by the SELinux kernel services and SELinux-aware applications for events such as system errors initialization policy loading changing Boolean states setting of enforcing permissive mode and relabeling AVC Audit Events The table below describes the general format of AVC audit messages in log when access has been denied or an audit event has been specifically requested Table 2 2 AVC Audit Message Description Keyword Description type For SELinux AVC events type AVC – for kernel events&lt;br&gt; type USER_AVC – for user-space object manager events The AVC event can always be tied to the relevant SYSCALL event as they have the same serial_nmuber in the msg audit time serial_number field msg Contains the audit keyword with a reference number for example msg audit 1243332701.74 1 0 1 avc Will be either denied when access has been denied or granted when an audit allow rule has been defined by the policy pid If it is a task log the process ID pid and the name of the executable file comm comm capability If it is a capability event log the identifier path If it is a file system event log the relevant information Note that the name field may not always be present name dev ino laddr If it is a socket event log the source destination address and ports for IP4 and IP6 sockets AF_INET lport faddr fport path If it is a file socket event log the path AF_UNIX saddr If it is a network event log the source destination addresses and ports with the network interface for IP4 or IP6 networks AF_INET src daddr dest netif sauid IPSec security association identifiers hostname addr terminal resid X-Windows resource ID and type restype scontext The security context of the source or subject tcontext The security context of the target or object tclass The object class of the target or object The following is an audit.log example Currently only EXT4 can completely support SELinux label with XATTR and change it UBIFS can label XATTR but cannot change it Only embedded multi-media card eMMC storage can support the EXT4 file system There are two methods for configuring SELinux on the Ambarella platform using the default configuration by Ambarella or manually setting up the SELinux configuration Use the Default Configuration Ambarella offers a default configuration to set up SELinux Follow the steps below to set up the SELinux configuration Setting Up SELinux Configuration Manually SELinux can be set up manually Follow the steps below to set up SELinux in menuconfig If using SELinux with the UBIFS file system in select in When using the UBIFS file system in rootfs rootfs select Initialize file labeling with XATTR For SELinux if the SELinux file_context file must be changed then change the file context address Print Security Context The command Z is used to print the security context for the file For example Get the SELinux Status sestatus is used to obtain the status of the system running SELinux Usage sestatus OPTION v verbose check of process and file contexts b display the current state of Booleans If there are no options sestatus displays the SELinux status For example SELinux mode changes using setenforce which is recovered after a reboot If users want to change the SELinux mode permanently or disable SELinux they must modify For more information refer to 2.2.4 SELinux Configuration Files Change the Security Context chcon is used to change the security context For example Only an eMMC board with an EXT4 file system can change the security context This configuration file controls the SELinux state it is located in It uses the following parameters Editing the value in this file can change the SELinux state as follows Table 2 3 Values SELinux SELinux Type This entry can contain one of three values Enforcing SELinux security policy is enforced Permissive SELinux logs warnings instead of enforcing the policy Disabled No SELinux policy is loaded The policy_name is used as the directory name where the active policy and its configuration files will locate and load the policy contained within this directory structure policy_name Each file discussed in this section is related to the policy name as follows policy_name Ambarella uses targeted by default Seusers The seusers file is used by login programs and maps the GNU Linux user to the SELinux user A typical login sequence would be as follows Using the GNU Linux user_id look up the seuser_id from this file If an entry cannot be found use __default__entry To determine the remaining context to be used as the security context read the user_id file If this file is not present check for a default context in the file If no default context is found read the file to enable a failed safe context to be set Example of seusers file contents Policy policy ver This is the binary policy file that is loaded into the kernel to enforce the policy Contexts customizable_types The customizable_types file contains a list of types that will not be re-labeled by the setfiles or restorecon commands The commands check this file before re-labeling and exclude those in the list unless the –F flag is used Example of file contents Contexts default_contexts The default_context file is used by SELinux-aware applications that are required to set a security context for user processes generally the login applications The following is an example of default_contexts contents Contexts Files file_contexts The file_contexts file is used by a number of SELinux-aware commands setfiles fixfiles matchpatchcon and restorecon to re-label either part or all of the file system The format of the file_context file is as follows Each line within the file consists of the following Table 2 4 Parameters for file_context pathname_regexp file_type opt_security_context An entry that defines the path name that may be in the form of a regular expression One of the following optional file_type entries b Block device c Character device d Directory p Named pipe l Symbolic link s Socket file This can be either The security context A value of can be used to indicate that matching files must not be re-labeled The following is an example of file_contexts contents Users can customize their own policy to fit their systems by adding a new SELinux module Create Module CIL Files To create a new module create a cil file and write the rules This rule indicates that when the source file is system_logind_t the targeted file is init_var_lib_t the object class is lnk_file and the object permission is read Thus the operation is allowed Install the Module Use the semodule –i to install the module Update the Module Obtain cil files from the module if the user already has the cil files this step can be skipped Add the rules to the cil file Install a new module Check the Policy Use selinux_check_access to determine if the rules have been written into the policy If the module was not successfully installed the following error message appears TEE is a specification standard from GlobalPlatform GP a non-profit industry association One of TEE’s implementations is Arm TrustZone For more information about GP visit the following link TEE specification can be found here filter-committee tee For more information about TEE programming users can refer to TEE API and TEE client API specifications as follows GPD_TEE_Internal_Core_API_Specification_v1.3.1_PublicRelease_CC.pdf and TEE_Client_API_Specification-V1.0_c.pdf Arm TrustZone technology offers an efficient system-wide approach to security with hardware-enforced isolation built into the CPU TrustZone provides the perfect starting point for establishing a device root of trust RoT based on platform security architecture PSA guidelines For more information visit Figure 3 1 System Diagram of Arm TrustZone On Ambarella platforms Arm TrustZone can be enabled in the flexible Linux SDK In the flexible Linux SDK Linux functions as the rich OS the open portable trusted execution environment OP-TEE as the trusted operating system TOS and Arm trusted firmware ATF as the trusted firmware secure monitor The hypervisor and multiple-rich OS are not implemented in the SDK The following diagram illustrates Arm TrustZone in the Ambarella Flexible Linux SDK Figure 3 2 Arm TrustZone in Linux SDK ATF is the reference software for Arm TrustZone It implements a secure monitor which manages the switch between the normal world rich OS and the secure world secure OS ATF also implements authentication during the boot stage secure boot During this process the Ambarella Linux SDK employs a partial authentication chain for secure boot via the built-in hardware engine BL2 authenticates BL31 BL32 and BL33 OP-TEE is an open source project which implements the GlobalPlatform TEE system architecture specifications and serves as a TOS OP-TEE provides the TEE application programming interface API and the TEE client API and implements a TEE-suppliant The TEE API as defined by the GlobalPlatform TEE standard is for the development of trusted applications TAs The TOS is accessible from the rich OS Linux using the GlobalPlatform TEE client API specification The TEE client API is used to trigger the secure execution of applications within the TEE The TEE-supplicant loads the TA from the rich OS into the secure OS for execution The following diagram shows the software stack of Arm TrustZone Linux OP-TEE and ATF Figure 3 3 Software Stack of TrustZone Linux OP-TEE and ATF Refer to to access the OP-TEE home page Refer to to access the project Refer to to check OP-TEE documents The TA functions in the secure world in OP-TEE It can be a user TA which operates in the TEE user space or a pseudo TA PTA which operates in the TEE kernel space The user TA includes a signature and resides in the normal world storage The PTA is embedded in the trusted OS OP-TEE-OS Each TA includes a universally unique identifier UUID as its identity When a normal TA is requested it is loaded by a TEE-supplicant in rich the OS and conveyed to the secure world after the digital signature has been verified The client application CA functions in the normal world The SDK locations for the modules are as follows TEE_Client_API SDK/ambarella/boot/tee/optee_client/libteec RPC service SDK/ambarella/boot/tee/optee_client/tee-supplicant OP-TEE driver SDK/ambarella/kernel/linux-5.15 TEE_Internal_API SDK/ambarella/boot/tee/optee_os/lib/libutee/include OP-TEE’s user TAs are signed by SDK/ambarella/boot/tee/optee_os/keys/default_ta.pem Each TA in the secure world should include a UUID to enable the CA application to locate it through the TEE API in the normal world The following lists locations of the source files ATF SDK/ambarella/boot/tee/arm-trusted-firmware Cryptography library SDK/ambarella/boot/tee/mbedtls OP-TEE_OS SDK/ambarella/boot/tee/optee_os OP-TEE_Client SDK/ambarella/boot/tee/optee_client OP-TEE_Test SDK/ambarella/boot/tee/optee_test To prevent the software version from being rolled backed by a hacker a method used by hackers to exploit known security vulnerabilities in older software versions the Ambarella CV5x CV7x series provides a hardware monotonic counter which can be used for anti-rollback Ambarella recommends removing or disabling hardware debug ports including force USB boot and joint test action group JTAG On CV5x force USB boot is disabled when secure boot is enabled Additionally there is an eFUSE bit that can be used to disable JTAG Ambarella recommends disabling all ports for non-secure protocols The following is a widely used non-secure protocol list Telnet port 2 3 file transfer protocol FTP port 2 1 trivial file transfer protocol TFTP port 6 9 hypertext transfer protocol HTTP port 8 0 and system gateway port 1 9 5 3 1 For remote login secure shell SSH is more secure than Telnet and HTTPS is more secure than HTTP The following command enables users to check what port is opened using the portscan tool nmap Hackers commonly use buffer overflow attacks To resist a buffer overflow attack Ambarella recommends that users enable the following items supported by the SDK Additionally users should remove reduce software bugs especially string manipulation functions Users are forbidden from using unsafe string functions such as strcpy strcat and sprintf As an alternative Ambarella recommends using strncpy and snprintf Address space layout randomization ASLR increases the difficulty of a buffer overflow attack Linux supports ASLR Use the command below to enable it on Ambarella chips Position independent executable PIE enables code to be executed at different places thus increasing the difficulty of a buffer overflow attack PIE is supported by the GNU compiler collection GCC as shown below No-eXecute protect NX prevents execution on the no-execute part and is enabled by default in GCC The following demonstrates how to enable and disable NX Disable NX z execstack Enable NX z noexecstack GCC supports stack protection The compile option enables the stack protector Protect functions that have string char local variables fstack-protector Protect all functions fstack-protector-all FORTIFY is a GCC feature that can be used for code and runtime checks if there is a potential buffer overflow risk Buffer overflow check at the compile stage D_FORTIFY_SOURCE 1 Buffer overflow check at both the compile and runtime stages D_FORTIFY_SOURCE 2 GCC supports read-only relocation RELRO which means the relocation region is read-only RELRO can increase the difficulty of a buffer overflow attack and can be used to protect the global offset table GOT By default the RELRO setting is partial partial RELRO means the GOT is writable Disable RELRO z norelro Partial RELRO z relro z lazy Full RELRO z relro z now Dynamic random-access memory DRAM scrambling is automatically enabled when secure boot is enabled it is designed to prevent a potential sniffer on the physical DRAM memory Regarding CVE fixes Ambarella synchronizes up to the latest version of the Linux kernel and open sourse software OSS modules then provide the updates inside the SDK package quarterly or bi-quarterly for both Linux kernel and OSS module fixes For these open source modules Ambarella relies only on the community updates but will not provide its own fixes for these modules This is a general support rule of CVE fixes for all Cooper Linux SDK customers</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">design_guide</field>
    <field name="url">db/df1/design_guide.html</field>
    <field name="keywords"></field>
    <field name="text">Design Guide Design Guide Version Updated Date Modification 0.0.1 2 0 2 3 1 2 1 7 Initial version There are some differences between different CV5x CV7x CV3 chips This chapter provides important information relating to the design stage To toggle secure boot on off use POC 6 the dual in-line package DIP switch on the development board Do not use on the development board or on the evaluation kit EVK Users must send the hardware schematic diagram to the Ambarella hardware team to review in order to guarantee that the schematic is correct In the mass-production MP process users must write all three root of trust RoT keys into one-time programmable OTP because leaving blank RoT key slots can cause security issues in the product must be applied during the MP process in order to guarantee that there is no way to bypass the secure boot check</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">key_management</field>
    <field name="url">db/dfb/key_management.html</field>
    <field name="keywords"></field>
    <field name="text">Key Management Key Management Version Updated Date Modification 0.0.1 2 0 2 3 1 2 1 7 Initial Version Key management is a crucial aspect of security Secure boot is based on the digital signature process which requires a private key to generate the signature sign signature as well as a public key to verify it Private keys must be kept confidential as the public keys are deployed on the device Ambarella chips use one-time programmable OTP to prevent tampering of public keys As private keys are required for compiling firmware they are located in the Arm® trusted firmware ATF open portable trusted execution environment OP-TEE source code directory Developers QAs maintainers and manufacturers can access private keys directly thus presenting a high risk of key leakage To address this issue the Ambarella Flexible Linux Software Development Kit SDK introduces the remote procedure call RPC toolkit The Ambarella SDK also supports cloud-based key management via the Amazon key management service KMS for secure boot and Arm® TrustZone® Because cloud-based KMS is provided by the cloud service vendor this feature is provided as a separate patch it is not a standard part of the Ambarella SDK This feature can be requested from the Ambarella contact window Detailed descriptions of cloud-based key management is beyond the scope of this document This chapter provides an overview of key management Section Section Section Section Section The local root of trust RoT public key PK can be found at ambarella/security/tz_sb_keys/local_keys/rot_keys/ed25519/pub_rot.bin and tThe remote RoT PK can be found on the server side at ambarella/security/build/tz_dev_server/pub_rot.bin The RoT PK is programmed into one-time programmable OTP and is used as the root of trust for secure boot The ATF keys are derived from the RoT key and then embedded in the firmware binary For OP-TEE the trusted application TA public key is embedded into the OP-TEE-OS binary The public key for authenticating the Linux kernel is embedded into the AMBoot binary There are 1 6 RoT key slots in OTP customers MUST program 1 6 RoT keys during the mass-production MP process Leaving empty RoT key slots can lead to system security risks There are three major keys the RoT key which is used for secure boot the kernel key for Linux kernel authentication and the TA key for TA binary authentication In the default approach these keys can be found in the source code directory RoT private key ambarella/security/tz_sb_keys/local_keys/rot_keys/ed25519/pri_rot.bin Kernel private key ambarella/security/tz_sb_keys/local_keys/kernel_keys/ed25519/pri_kernel.bin CoT root key ambarella/security/tz_sb_keys/local_keys/cot_root_keys/rsa2048/pri_cot_root.pem TA private key ambarella/boot/tee/optee_os/keys/default_ta.pem In this section Ambarella introduces a new method of key management the RPC toolkit This kit is compatible with the original tools in ATF OP-TEE while restricting private key access to administrators With the RPC toolkit developers quality assurances QAs maintainers and manufacturers can compile ATF OP-TEE without directly accessing the private key This toolkit contains a daemon program tool proxies on the developer side a server that maintains the private keys and a signing service The makefile can request a signing service via tool proxies which connects the daemon Then the daemon requests the signing service over a TLS connection with the server which is a safe connection used to prevent a The following diagram shows the three components of the development toolkit the developer server the daemon and the tool proxy Developers can share a single server with both an individual daemon and with the tool proxies Figure 1-1 RPC Toolkit The tool proxies provide identical services with the original tools in ATF OP-TEE However there is one difference the private keys are not local they exist only on the remote server side The keys on the server are located in the following paths RoT private key ambarella/security/build/tz_dev_server/rot_private.pem Kernel private key ambarella/security/build/tz_dev_server/kernel_private.pem CoT root key ambarella/security/build/tz_dev_server/pri_cot_root.pem TA private key ambarella/security/build/tz_dev_server/default_ta.pem There are 1 6 RSA key slots in OTP which makes it possible to revoke the RoT key The manufacturer should writes all 1 6 RSA keys in OTP and then locks them during the manufacturing stage so that each key can cover several years For example the first key can cover ten years the second key can cover the next ten years and so on Although there is an invalid bit in OTP for the first two keys the last key cannot be revoked When a key is marked as invalid secure boot will switch to the next key A brief example of the public key revocation mechanism there are invalid bits for the first two RoT keys Secure read-only memory ROM BST BL2 checks those invalid bits before loading the RoT key If the invalid bit is set Secure ROM BST BL2 will load the next key For users working with one project only one key set is sufficient The project leader chooses the key set and then sends it to the other members in the project It is acceptable to use an existing key set for this use case The following sections describe how to generate a new key set as well as how to use an existing key set for both local and RPC approaches Use the commands below to generate new keys The SDK is released with default key pairs so the commands are used to replace the default set Ensure that new keys are necessary before proceeding and remember to save the generated keys Generate a new pair of RoT keys including the public key bin Generate a new kernel private key Generate a new TA private key Generate a new CoT Root private key When users prepare the development server these keys will automatically be generated There is a key index field in the BST header Users can modify ambarella/boot/amboot/vif/bst.info to specify the RoT key index BST_SEC_KEYINX 0 x0000 When compiling the SDK users must ensure that the secure boot configuration is selected If the system includes Arm TrustZone use xxxx_trustzone_config If the system does not include Arm TrustZone use xxxx_secure_boot_without_trustzone_config The steps for compiling are as follows Amba build Yocto build By default the compiler chooses the local approach private keys in a local place in the source code To use the RPC approach select the following items in make menuconfig Amba build Yocto build The “local port” is used for the development tool proxy and daemon If several developers use the same PC or server for compiling each developer must choose a different port Users must ensure that the RPC development server and the daemon are configured before compiling to use the remote approach Instructions on how to configure the correct environment are described in the next section Compile the SDK OP-TEE versions 3.8 and later require Python 3 3.6.9 Users must ensure that the build machine has the correct Python version If a Python report error occurs users must install the related Python modules using the following commands The RPC toolkits can be found under ambarella/security/build Compiled development server Compiled development daemon Compiled tool proxies For detailed steps refer to ambarella/security/build/trustzone_secure_boot_toolkit_help.txt Running the server program on the privileged server requires several keys and a certificate Refer to the following steps to generate the keys and to start the server program Create a server identity key pair Ambarella strongly recommends that users select a passphrase that is more secure than “1234” as shown in the example below openssl genpkey algorithm RSA out server_priv_key.pem pkeyopt rsa_keygen_bits 2 0 4 8 pkeyopt rsa_keygen_pubexp 6 5 5 3 7 pass pass 1 2 3 4 aes-256-cbc Generate the self-signed certificate openssl req new x509 days 3 6 5 0 key server_priv_key.pem out server.crt subj CN/ST SH/L PD/O amba/OU system/CN amba/emailAddress abcdefg ambarella.com Run the development server The folder db stores all approved developer accounts The first time the development server operates the application asks the user to generate the private keys Type “y” Enter to run the server Running the development daemon as a client requires an identity key and a public key from the server server_pub_key.txt The administrator must distribute the server’s public key to developers who can then compile the SDK using the secure boot feature Follow the hints provided in tz_dev_daemon to generate an identity key Generate an RSA key pair Remember to use a passphrase that is more secure than the one shown below Run the development daemon with the IP port and local port of the remote server This enables the compiler tools to make the request The first time the daemon operates the user will be asked to register a new account Enter a unique name then type “y” Enter to proceed The newly registered account must be approved by the administrator On the server side a prompt appears awaiting administrator approval Administrators must type “y” Enter to approve the registered user After the new registration is complete the daemon begins running If the account is already registered the daemon will begin running after login The mutual authentication of the server and the daemon are based on their key pairs If the public key is not programmed into OTP the first two authentications will be skipped Secure ROM BST BST BL2 There are three public key slots in OTP The manufacturer can revoke the first two public keys after some time For example it is possible to revoke the first key after a decade the second key after the next decade and keep the last key for the remaining years However the last key is irrevocable To prevent an attacker from programming the last public key Ambarella strongly recommends that the manufacturer programs all three keys in OTP at the factory Use the following steps to program the OTP with the RSA public key with Arm TrustZone Use the following steps to program the OTP with the RSA public key without Arm TrustZone The rot_public.bin is located in a local folder or on the remote server For more details refer to Public Keys on the Device During the debugging process Ambarella recommends that users enable secure boot with a power-on configuration POC pin which is revocable In the manufacturing stage secure boot must be permanently enabled so that attackers cannot disable it on the real product Force USB boot is automatically disabled when secure boot is enabled POC 6 must be pulled high with a secure boot-enabled image otherwise the boot-up will fail All 1 6 RoT keys must be locked explicitly first then secure boot can take effect Otherwise the ROM checks BST and the BST check of BL2 will be skipped Use the eFUSE bit to permanently set secure boot If secure boot is permanently enabled the POC pin cannot enable or disable secure boot Because this process is irrevocable use caution while performing this operation When the system is with Arm TrustZone When the system is without Arm TrustZone Typically this step is performed during the manufacturing process On the CV5x CV7x CV3 EVK board the compiler must additionally select in menuconfig If the public key is not programmed in OTP or if secure boot is disabled the first two authentications will be skipped The console will print a Skipping ROTPK verification message as shown below If the public key is programmed in OTP and secure boot is enabled the full chain of authentications will take effect The console prints the message as shown below For APIs that can revoke the first two public keys use the command below with Arm TrustZone For APIs that can revoke the first two public keys use the command below without Arm TrustZone</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">security_overview</field>
    <field name="url">dc/de9/security_overview.html</field>
    <field name="keywords"></field>
    <field name="text">Overview Overview The Ambarella system on chip SoC provides a total system security solution called Pan Shi Pan Shi covers six major aspects System integrity protection System reinforcement Data storage protection Data transfer protection Intellectual property protection User privacy protection Pan Shi includes both hardware chip-level and circuit-level security design and software firmware operating system OS as well as user-space software security design Pan Shi employs highly-advanced cryptography algorithms and widely-used security protocols industry standard architecture and security methodology The Pan Shi design philosophy is open flexible efficient renewable defense in depth DID and compartmental making it an optimal solution for system security Figure 1-1 Six Major Aspects of Pan Shi This section provides the guidelines for the system and software design of the Pan Shi security solution which is provided in the Ambarella Flexible Linux Software Development Kit SDK The following essential security features for Pan Shi will be introduced Secure boot Trusted execution environment TEE and Arm® TrustZone® Secure enhanced bootloader BLD Data encryption and secure storage Unit license protection ULP Neural network NN model protection Mandatory access control MAC mechanism such as SELinux Secure hardware Unique ID One-time programmable OTP True random number generator TRNG And more The table on the following page shows the relationship between Pan Shi and the detailed security features Pan Shi Aspect Security Feature Brief Description System integrity protection Secure boot Guarantees that the booted firmware is not tampered with Secure over the air OTA Guarantees that the upgraded firmware is not tampered with Linux dm-verity Detects if the file system has been tampered with System reinforcement Secure enhanced bootloader Authenticates before executing the command in the bootloader Secure enhanced Linux Mandatory access control Arm® TrustZone® Trusted execution environment Anti-rollback Prevents the rollback attack Disable hardware debug port Prevents attacks via the hardware debug tool Disable non-secure protocol port Minimizes attacking surface Resistance to the buffer overflow attack Increases the difficulty of the buffer overflow attack Dynamic random-access memory DRAM scrambling Prevents runtime memory sniffers Data storage protection Linux dm-crypt Partition encryption Secure storage by OP-TEE Secure storage Data encryption and data at rest protection Data encryption and data at rest protection Data transfer protection TLS in Linux Secures connection between the Linux application and the cloud TLS in OP-TEE Secures connection between the trusted application TA and the cloud Secure connection in CVflow® Secures the connection between CVflow® and the cloud Intellectual property protection ULP by CVflow® and CV0 Unit license by CVflow and CV0 NN model protection NN model protection by CVflow User privacy protection Application programming interface API for vision processing Secure vision processing API for secure storage Stores data securely on the device API for secure transfer Transfers only non-user privacy data to cloud securely The following diagram shows the software framework of the SoC Figure 2-1 Software Hierarchy on Chip The following diagram shows the software framework for the Linux PC Figure 2-2 Software Hierarchy for the Linux PC The following describes the partitions Bootstrap BST The BST size is 8 KB with a 3 2 byte signature at the tail BST is signed with the root of trust RoT key Arm-trusted firmware ATF ATF stores BL2 ATF BL2 is used to load and verify the following modules BL31 BL32 BL33 chain of trust CoT and DTB ATF is signed with the RoT key Bootloader BLD BLD stores the firmware-in-package FIP which includes BL31 BL32 and BL33 BL31 is the secure monitor for ATF BL32 is the trusted OS OP-TEE-OS and BL33 is for the AMBoot other bootloader BL31 BL32 and BL33 are signed with keys in CoT certificates Primary PRI secondary SEC PRI SEC stores the Linux kernel The Linux kernel is signed with a kernel key Linux LNX LNX stores the Linux file system Partition table PTB</field>
  </doc>
  <doc>
    <field name="type">source</field>
    <field name="name">security_chapters_page.h</field>
    <field name="url">de/dae/security__chapters__page_8h_source.html#l00001</field>
    <field name="keywords"></field>
    <field name="text">retval flprog_get_part_table ptb retval retval ptb dev rsv printf retval ptb dev rsv retval code subsection sebld_user_guide User Guide There are two approaches to execute commands in the bootloader the first uses the AMBoot console the second uses Android Fastboot The following sections demonstrate these two approaches the ed25519 key example subsubsection sebld_via_amboot_console Via AMBoot Console Compile options To enable SEBLD select the following items in “make menuconfig” B Amba build B code build$ make menuconfig security boot security security boot_security Security Enhanced BLD Support locker code B Yocto build B code build$ make menuconfig meta ambasecurity recipes boot security boot security meta ambasecurity recipes boot security boot security Security Enhanced BLD Support locker code Enter the AMBoot console press &lt;B&gt; Enter&lt;/B&gt; and reboot Get the challenge code amboot sebld challenge code The challenge is shown below code amboot sebld challenge fa3177810ee1078bb34f8118539e9046n4q6a6x5 code Use the key to sign the challenge ED25519 example RSA2048 is similar code build$ cd ambarella packages security build sebld_tool build$ sebld_disable fa3177810ee1078bb34f8118539e9046n4q6a6x5 ed25519 keys local_keys sebld_keys ed25519 pri_sebld bin dbf7f77265bb9f2e9e92f2539af6900e2ffa96de854f82df28d754c71601e20964814d65930a5e6cb796b925d07920e4c87dcbd81d90f744e000d7e1ef860c0b endcode Use the signature to unlock the BLD in the AMBoot console code amboot sebld challenge fa3177810ee1078bb34f8118539e9046n4q6a6x5 amboot sebld disable dbf7f77265bb9f2e9e92f2539af6900e2ffa96de854f82df28d754c71601e20964814d65930a5e6cb796b925d07920e4c87dcbd81d90f744e000d7e1ef860c0b store signature dbf7f77265bb9f2e9e92f2539af6900e2ffa96de854f82df28d754c71601e20964814d65930a5e6cb796b925d07920e4c87dcbd81d90f744e000d7e1ef860c0b endcode When the bootloader is unlocked inputting help lists the available commands Lock BLD code amboot selbd enable endcode The message below signifies that no command is available after it is locked code amboot help Security Enhanced BLD is enable endcode subsubsection sebld_via_android_fastboot Via Android Fastboot Compile Options To enable SEBLD and Android Fastboot select the following items in “make menuconfig” B Amba build B code build$ make menuconfig boot amboot boot ambamk Ambarella Bootloader Configuration AMBoot Options Common Boot Options security boot security security boot_security Security Enhanced BLD Support locker code B Yocto build B code build$ make menuconfig meta ambabsp recipes bsp amboot meta ambabsp recipes bsp boot Ambarella Bootloader Configuration AMBoot Options Common Boot Options Android Fastboot Support meta ambasecurity recipes boot security boot security meta ambasecurity recipes boot security boot security Security Enhanced BLD Support locker code Follow the steps below to execute the lock and unlock functions Enter Android Fastboot by pressing the GPIO_DEBUG button and rebooting An example of the board entering Android Fastboot is provided below anchor Android_Fastboot image html android_fastboot_console png Get the challenge code host$ fastboot exe getvar challenge challenge fa3177810ee1078bb34f8118539e9046l7r5a4v6 Finished Total time s code Use the key to sign the challenge code build$ cd ambarella packages security build sebld_tool build$ sebld_disable fa3177810ee1078bb34f8118539e9046l7r5a4v6 ed25519 keys local_keys sebld_keys ed25519 pri_sebld bin code The signature file is sebld sign Copy sebld sign to the Android Fastboot tool folder Upload the signature to the board code host$ fastboot exe signature sebld sign code Unlock the BLD code host$ fastboot exe oem unlock code The following message will be displayed the unlock was successful anchor Unlock_Android_Fastboot_Successful image html unlock_android_fastboot png Then the other Android Fastboot commands are available use For example the “boot” command can download firmware such as AmbaUSB code host$ fastboot exe boot bld_release bin code Lock the BLD code host$ fastboot exe boot bld_release bin code section selinux Secure Enhanced Linux SELinux subsection selinux_overview SELinux Overview subsubsection selinux_introduction Introduction SELinux is the primary mandatory access control MAC mechanism built into a number of GNU Linux distributions SELinux originally began as the Flux Advanced Security Kernel FLASK developed by the Utah University Flux team and the U S Department of Defense The development was later enhanced by the National Security Agency NSA and released as an open source software OSS subsubsection core_selinux_components Core SELinux Components The following figure shows a high level diagram of the SELinux core components that manage the enforcement of the policy and is comprised of the following An manager that knows the actions required a particular resource such as a file and can enforce those actions example allows it to write to a file permitted by the policy A security server that makes decisions regarding the subject’s right to perform the requested action on the object based on the existing security policy rules A security policy that describes the rules the SELinux policy language An access vector cache AVC that improves system performance by caching security server decisions anchor High_Level_Core_SELinux_Components image html high_level_core_selinux_components png subsubsection mandatory_access_control Mandatory Access Control Mandatory access control is a type of access control in which the operating system OS is used to constrain a user or process the subject from accessing or performing an operation on an object such as file disk memory and more Each of the subjects and objects include a set of security attributes that can be interrogated by the OS to check the requested operation can be performed For SELinux the following are Subjects are processes Objects are system resources such as files and sockets Security attributes are the security context The security server within the Linux kernel authorizes access the security policy that describes the rules that must be enforced subsubsection selinux_users SELinux Users Users in GNU Linux are generally associated with human users such as Alice and Bob or system functions such as admin While can be implemented in SELinux SELinux usernames are generally groups or classes of users For example all standard system users can be assigned an SELinux username of user_u Administration staff can be assigned under staff_u subsubsection rbac Role Based Access Control To further control access to type enforcement TE domains SELinux uses role based access control RBAC This feature enables SELinux users to be associated with one or more roles where each role is then associated with one or more domain types as shown in the figure below anchor Role_Based_Access_Control image html role_based_access_control png subsubsection security_context Security Context SELinux security context to be associated with each process or subject and that is used by the security server to decide access is permitted as defined by the policy The security context is additionally known as a ‘security label’ Within SELinux the security context is represented as variable length strings that define the SELinux user their role a type identifier and an optional MCS MLS security range level shown below user role type range The following table describes the user role type and range within the security context table caption Table Security Context caption tr th align User th align Role th align Type th align Range tr td The SELinux user identity can be associated with one or more roles that the SELinux user is allowed to use td The SELinux role can be associated with one or more types that the SELinux user is allowed to access td When a type is associated with a process it defines what processes or domains the SELinux user the subject can access When a type is associated with an object it defines what access permissions are available to the SELinux td This field is known as a level it is only present the policy supports MCS or MLS The entry can consist of the following br A single security level that contains a sensitivity level and zero or more categories example s0 s1 c0 A range that consists of two security levels separated by a hyphen example ss0 s15 c0 c1023 table subsubsection selinux_subjects Subjects A subject is an active entity generally in the form of a person process or device that enables information to flow among objects or that changes the system state Within SELinux a subject is an active process with an associated security context However a process can also be referred to as an object depending on the context For example A running process such as an active entity is a subject because it causes information to flow among objects or can change the system state The process can also be referred to as an because each process has an associated called “process ” This process “object” defines what permissions the policy is allowed to grant or deny on the active process subsubsection selinux_objects Objects Within SELinux an is a resource such as files sockets pipes or network interfaces that are accessed via processes also known as subjects These objects are classified according to which resource they provide access permissions relevant to their purpose example read receive and write and are assigned a security context Each consists of a identifier that defines its purpose for example file or socket along with a set of permissions also known as access vectors that describe what services the can manage read write send and so on When an is instantiated it will be allocated a name example a file could be called configured a socket or my_connection and a security context example system_u object_r selinux_config_t subsubsection selinux_modes SELinux Modes SELinux includes three major operation modes Enforcing SELinux is enforcing the loaded policy Permissive SELinux has loaded the policy but is not enforcing the policy rules This is generally used testing as the audit log contains the AVC denied messages Disabled The SELinux infrastructure is not enabled therefore no policy can be loaded These flags are set in the etc selinx config file subsubsection auditing_selinux_events Auditing SELinux Events SELinux includes two main types of audit events AVC audit events and SELinux aware application events AVC audit events are generated by the AVC subsystem as a result of access denials or where specific events have requested an audit message SELinux aware application events are generated by the SELinux kernel services and SELinux aware applications events such as system errors initialization policy loading changing Boolean states setting of enforcing permissive mode and relabeling b AVC Audit Events b The table below describes the general format of AVC audit messages in var log audit audit log when access has been denied or an audit has been specifically requested table caption Table AVC Audit Message Description caption tr th align Keyword th align Description tr td type&lt;td&gt; For SELinux AVC events br type AVC – kernel events&lt;br&gt; type USER_AVC – user space manager events&lt;br&gt; The AVC can always be tied to the relevant SYSCALL as they have the same serial_nmuber in the msg audit time serial_number field tr td msg&lt;td&gt; Contains the audit keyword with a reference number example msg audit tr td avc&lt;td&gt; Will be either denied when access has been &lt;B&gt; denied B or &lt;B&gt; granted B when an audit allow rule has been defined by the policy tr td pid td rowspan If it is a task log the process ID pid and the name of the executable file comm tr td comm tr td capability	&lt;td&gt; If it is a capability event log the identifier tr td path td rowspan If it is a file system event log the relevant information Note that the name field may not always be present tr td name tr td dev tr td ino tr td laddr td rowspan If it is a socket event log the source destination address and ports IP4 and IP6 sockets AF_INET tr td lport tr td faddr tr td fport tr td path&lt;td&gt; If it is a file socket event log the path AF_UNIX tr td saddr td rowspan If it is a network event log the source destination addresses and ports with the network for IP4 or IP6 networks AF_INET tr td src tr td daddr tr td dest tr td netif tr td sauid td rowspan IPSec security association identifiers tr td hostname tr td addr tr td terminal tr td resid td rowspan X Windows resource ID and type tr td restype tr td scontext&lt;td&gt; The security context of the source or subject tr td tcontext&lt;td&gt; The security context of the target or tr td tclass&lt;td&gt; The of the target or object table The following is an audit log example code type AVC msg audit avc denied rename for pid comm name dev dm ino scontext test_u staff_r oddjob_mkhomedir_t s0 tcontext test_u object_r gnome_home_t s0 tclass lnk_file type AVC msg audit avc denied unlink for pid comm name dev dm ino scontext test_u staff_r oddjob_mkhomedir_t s0 tcontext system_u object_r gnome_home_t s0 tclass lnk_file type SYSCALL msg audit arch syscall success yes exit a0 d2760 a1 d2850 a2 da6660 a3 cb550 items ppid pid auid uid gid euid suid fsuid egid sgid fsgid tty none ses comm exe subj test_u staff_r oddjob_mkhomedir_t s0 key null endcode subsection selinux_amba_user_guide SELinux User Guide for Ambarella subsubsection amba_selinux_support Ambarella SELinux Support Currently only EXT4 can completely support SELinux label with XATTR and change it UBIFS can label XATTR but cannot change it note Only embedded multi media card eMMC storage can support the EXT4 file system subsubsection enable_selinux_on_amba Enable SELinux on the Ambarella Platform There are two methods for configuring SELinux on the Ambarella platform using the default configuration by Ambarella or manually setting up the SELinux configuration b Use the Default Configuration b br Ambarella offers a default configuration to set up SELinux Follow the steps below to set up the SELinux configuration code build$ make sync_build_mkcfg build$ make xxxxx_selinux_config build$ make defconfig_pulbic_linux build$ make –j16 endcode b Setting Up SELinux Configuration Manually b SELinux can be set up manually Follow the steps below to set up SELinux in menuconfig code build$ make linux_menuconfig General steps Auditing support Security options Enable different security models Enable the securityfs filesystem Socket and Networking Security Hooks NSA SELinux support NSA SELinux boot parameter NSA SELinux runtime disable NSA SELinux Development Support NSA SELinux AVC Statistics NSA SELinux checkreqprot default value First legacy to be initialized SELinux lockdown yama loadpin safesetid integrity selinux Ordered list of enabled LSMs endcode note If using SELinux with the UBIFS file system in select in code build$ make menuconfig prebuild oss prebuild audit prebuild oss armv8 a audit Add audit service into root_fs prebuild policycoreutils prebuild oss armv8 a policycoreutils SELINUX policy from Fedora system Add restorecond service into root_fs endcode note When using the UBIFS file system in rootfs rootfs select Initialize file labeling with XATTR For SELinux if the SELinux file_context file must be changed then change the file context address subsubsection selinux_command SELinux Commands b Print Security Context b br The command Z is used to print the security context for the file process user For example code board ls Z system_u object_r usr_t s0 selinux_test txt board id Z system_u system_r local_login_t s0 s0 c0 c1023 board ps Z grep nginx system_u system_r httpd_t s0 root nginx master process usr sbin nginx c etc nginx nginx conf system_u system_r httpd_t s0 nginx nginx worker process system_u system_r httpd_t s0 nginx nginx worker process system_u system_r httpd_t s0 nginx nginx worker process system_u system_r httpd_t s0 nginx nginx worker process endcode B Get the SELinux Status b br sestatus is used to obtain the status of the system running SELinux Usage sestatus OPTION v verbose check of process and file contexts b display the current state of Booleans If there are no options sestatus displays the SELinux status For example code board sestatus SELinux status enabled SELinuxfs mount sys fs selinux SELinux root directory etc selinux Loaded policy name targeted Current mode permissive Mode from config file permissive Policy MLS status enabled Policy deny_unknown status allowed Memory protection checking requested insecure Max kernel policy version b Get and Modify SELinux Mode b br getenforce is used to get the mode SELinux is running in setenforce is used to modify the mode SELinux is running in Use Enforcing or to put SELinux in enforcing mode Use Permissive or to put SELinux in permissive mode For example code board getenforce Permissive board setenforce board getenforce Enforcing endcode note SELinux mode changes using setenforce which is recovered after a reboot If users want to change the SELinux mode permanently or disable SELinux they must modify etc selinux config For more information refer to ref selinux_config_files b Change the Security Context b br chcon is used to change the security context code Usage chcon OPTIONS CONTEXT FILE chcon OPTIONS u USER r ROLE l RANGE t TYPE FILE chcon OPTIONS reference RFILE FILE v Verbose c Report changes made h Affect symlinks instead of their targets f Suppress most error messages reference RFILE Use RFILE allow systemd_rfkill_t init_var_lib_t lnk_file read</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">data_transfer_protection</field>
    <field name="url">df/d19/data_transfer_protection.html</field>
    <field name="keywords"></field>
    <field name="text">Data Transfer Protection Data Transfer Protection For data transfer protection Ambarella recommends choosing the widely used transport layer security TLS it is the best practice for data transfer protection The Ambarella software development kit SDK supports TLS in both Linux and the trusted operating system TOS open portable trusted execution environment OP-TEE Additionally a similar secure connection is supported in CVflow Secure socket layer SSL and its successor TLS are protocols for establishing authenticated and encrypted links between networked computers SSL encrypts the data being transmitted so that a third party cannot eavesdrop on the transmission and view the data being transmitted Only the user’s computer and the secure server are able to recognize the data SSL protocols include the SSL record protocol handshake protocol change-cipher specification protocol and alert protocol The figure below shows the SSL protocol stack Table 1 1 SSL Protocol Stack Handshake Protocol Change Cipher Spec Protocol Alert Protocol HTTP SSL Record Protocol TCP IP SSL record protocol provides two services to the SSL connection Confidentality Message integrity In the SSL record protocol application data is divided into fragments The fragments are compressed and then the encrypted MAC generated by algorithms such secure hash protocol SHA is appended Subsequently the encryption of the data is completed and the last SSL header is appended to the data The handshake protocol is used to establish sessions This protocol enables the client and the server to mutually authenticate by sending a series of messages to one another This protocol uses the SSL record protocol Unless the handshake protocol is completed the SSL record output will be in a pending state After the handshake protocol the pending state is converted into the current state The change-cipher protocol consists of a single message which is one byte in length and can have only one value This protocol causes the pending state to be copied into the current state This protocol is used to convey SSL-related alerts to the peer entity Each message in this protocol contains two bytes 1 byte level and 1 byte alert An SSL session is established over a TCP socket The following sequence demonstrates the flow for an existing TCP application that has been modified to use SSL CLIENT_HELLO the client sends a CLIENT_HELLO command to the server which includes the following The highest SSL and TLS version supported by the client Ciphers supported by the client listed in order of preference Data compression methods supported by the client Session ID If the client is starting a new SSL session the session ID is 0 Random data generated by the client for use in the key generation process SERVER_HELLO the server sends a SERVER_HELLO command to the client which includes the SSL or TLS version that will be used for the SSL session The cipher will also be used for the SSL session Note that the session ID is for the SSL session Additionally random data will be generated by the server for use in the key generation process CERTIFICATE the server sends the CERTIFICATE command This command includes the server’s certificate and optionally a chain of certificates beginning with the certificate of the client application CA that assigned the server’s certificate SERVER_DONE the server sends the SERVER_DONE command which indicates that the server has completed this phase of the SSL handshake If client authentication is performed additional commands will flow between the client and the server following the SERVER_DONE command CERTIFICATE_VERIFY the client informs the server that it has verified the server’s certificate CHANGE_CIPHER_SPEC the client sends the CHANGE_CIPHER_SPEC command This command indicates that the contents of subsequent SSL record data sent by the client during the SSL session will be encrypted The 5 byte SSL record headers are never encrypted FINSHED the client sends the FINSHED command This command includes a digest of all SSL handshake commands that have flowed between the server and the client up to this point The figure below demonstrates an SSL handshake Figure 1-1 SSL Handshake Ambarella uses OpenSSL in the normal world and MbedTLS in the secure world to set up TLS connections Users can set up a TLS server and make a connection with the chip The TLS client can be set up in both the normal world Linux and the secure world OP-TEE The path for example code of the TLS server is packages/security/reference_code/openssl_tls_test/openssl_tls_test_server Ambarella uses OpenSSL to set up a TLS connection in the normal world The TLS work flow is provided as shown below World Figure 1-2 TLS Connection Between the Server and Normal World The path for example code of the TLS client in the normal world is packages/security/reference_code/openssl_tls_test/openssl_tls_test_client CVflow supports ED25519 and X25519 which provide support for secure connections</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">sys_integrity_protection</field>
    <field name="url">df/d7d/sys_integrity_protection.html</field>
    <field name="keywords"></field>
    <field name="text">System Integrity Protection System Integrity Protection Secure boot is a mechanism which guarantees that only the trusted firmware is executed Typically the digital signature is used to identify if the loaded firmware is secure or corrupt Only the private key owner is able to generate the correct digital signature and the public key on the device is protected by hardware such as one-time programmable OTP The private key and the public key in OTP constitute the The boot sequence includes several components which must authenticate the following component before it can be executed The complete authentication chain that includes the and the successfully achieves the secure boot Code execution begins with the code built into the system on chip SoC s read-only memory ROM The ROM code with the digital signature check capability is called Secure ROM The following diagram illustrates the Authentication_Chain_of_the_Secure_Boot_With_Arm_TrustZone and Authentication_Chain_of_the_Secure_Boot_Without_Arm_TrustZone The black line indicates the boot sequence while the blue dashed line represents the authentication key and target Figure 1-1 Authentication Chain of Secure Boot With Arm® TrustZone® Figure 1-2 Authentication Chain of the Secure Boot Without Arm TrustZone The secure boot authentication chain includes three stages as follows First the Secure ROM code covers ROM to bootstrapper BST and BST to BL2 ATF Next the Arm trusted firmware ATF BL2 code covers the second stage BL2 ATF to BL31 ATF BL2 ATF to BL32 OP-TEE BL2 ATF to BL33 AMBoot Finally the AMBoot code BL33 covers the third stage BL33 AMBoot to the Linux kernel OTP stores the root of trust RoT public key PK The RoT PK is used to authenticate the BST and the ATF BL2 The keys in chain of trust CoT certificates are used to authenticate BL31 BL32 and BL33 The kernel key authenticates the Linux kernel ATF defines the CoT which describes the root key CoT root and its derived keys The figure illustrates the ATF chain of trust Figure 1-3 Chain of Trust as Defined by ATF The secure boot employs EdDSA ED25519 and SHA2-512 for digital signature authentication The CoT in ATF uses RSA or ellipse curve cryptography ECC as an asymmetric cryptography When a secure operating system OS BL32 is required for Arm TrustZone it will require approximately 1 6 MB of memory The tables below provide the different system memory layouts with and without Arm TrustZone Users can also update the BL33 start address and the Linux kernel start address in menuconfig Amba build Yocto build When the bootloader BLD address changes with Arm TrustZone enabled the firmware programming start address must be changed accordingly Otherwise the firmware programming will conflict with the bootloader in memory Re-downloading non-TrustZone firmware will fail for example when the board is using TrustZone-enabled firmware To prevent this potential failure change the firmware programming start address of the non-TrustZone firmware then re-compile Users can refer to ambarella boot amboot doc mem_layout.txt Table 1 1 System Memory Layouts with Arm TrustZone Major Sub1 Sub2 Start Address End Address Total Size Secure World Memory ATF BL2 0 x00000000 0 x0007FFFF 5 1 2 KB ATF BL31 0 x00080000 0 x000FFFFF 5 1 2 KB Open portable trusted execution environment OP-TEE BL32 Trusted execution environment TEE memory 0 x00100000 0 x001FFFFF 1 MB Trusted application TA memory 0 x00200000 0 x013FFFFF 1 8 MB Normal World Memory Shared memory 0 x01400000 0 x017FFFFF 4 MB EL2 RSVD 0 x01800000 0 x01BFFFFF 4 MB BLD BL33 0 x01C00000 0 x01FFFFFF 4 MB Linux 0 x02000000 Total 3 2 MB Table 1 2 System Memory Layouts without Arm TrustZone Modules Start Address End Address Total Size ATF BL2 0 x00000000 0 x0007FFFF 5 1 2 KB ATF BL31 0 x00080000 0 x000FFFFF 5 1 2 KB BLD BL33 0 x00100000 0 x0047FFFF 3.5 MB Linux 0 x01C00000 Total size 2 8 MB Refer to Key Management for more information Users can upgrade each partition with the tools provided by Ambarella When secure boot is enabled partitions such as BST BLD ATF and primary PRI are signed The items below list their locations Amba build BST ambarella/out/ board bin.signed BLD ambarella/out/ board bin ATF ambarella/out/ board bin.signed PRI ambarella/out/ board SIGNED Yocto build BST ambarella/out/ board 0-r0/amboot-1.0 bin.signed BLD ambarella/tmp/work/cortexa53-crypto-poky-linux/amboot/1.0 bin ATF ambarella/tmp/work/cortexa53-crypto-poky-linux/amboot/1.0 bin.signed PRI ambarella/out/ board 15.112 To enable the upgrade tool select the following items in make menuconfig Amba build Yocto build Place or mount the partition to be upgraded on the board use partition file for example Upgrade the partition with tools Below are two examples one for the electronic logic gate NAND and one for the embedded multi-media controller eMMC The following lists the partition file locations BST partition file ATF partition file BLD partition file BAK partition file Linux kernel file Linux rootfs file The commands to erase upgrade partitions are as follows NAND Amba build Yocto build eMMC Amba build Yocto build Partitions are located in different places with different file systems users must change the upgrade command line to fit their own environment Users can find the partition location from the boot log Rescue mode uses the recovery partition BAK as a back-up boot option When there is an authentication failure or a digital signature check failure the boot can switch to rescue mode and boot from the recovery partition An authentication failure indicates unexpected contents in the external storage which could be caused by an attack an aging device sudden power loss or a system upgrade abortion among other causes Rescue mode enables manufacturers to attempt to repair the device online The figure below illustrates the boot sequence red text represents the partition names including rescue mode and the secure BAK partition with a digital signature In the BAK partition only BL2 BL31 BL32 and BL33 can be included Figure 1-4 Authentication Chain and Partition Layout in Rescue Mode Firmware inside the recovery partition also includes a valid digital signature If the BST is broken rescue mode cannot function the CPU will remain at Secure ROM until the damaged NAND is replaced Due to the BST code size limit selecting the normal boot path and the rescue boot path is explicitly triggered via the external microcontroller unit MCU therefore an external MCU is required for this rescue mode On chips such as CV5x CV7x on which the BST code size is sufficient in order to embed auto-selected and logic Ambarella plans to enable which can function without an external MCU In Rescue Mode V2 the system selects “normal boot path” or “rescue boot path” automatically at the bootloader stage If the “normal boot path” fails multiple times the system will reset and attempt the “rescue boot path” There are two copies for A/B ping-pong switching for the Linux kernel and rootfs partitions The PRI and LNX partitions are A’s kernel and rootfs while the PBA and ROM partitions are B’s kernel and rootfs A and B are also fail-safe the system will record the “last workable kernel and rootfs” If the “last workable kernel and rootfs” does not function the system marks the “last workable kernel and rootfs” to the other set and then resets the boot process Both the “normal boot path” and “rescue boot path” can function with A and B The success of kernel+Roofts boot is guarded by a watchdog by default the watchdog is internal If there is an external watchdog support for “disable external watchdog” must be added Figure 1-5 Authentication Chain and Partition Layout in Rescue Mode V2 、 Rescue Mode v2 is designed to guarantee fail-safes during system upgrade except in very extreme cases for example the BST partition upgrade is aborted or the BST partition is damaged The recommended upgrade processes for different scenarios are listed below Except for the “BST partition” issue all cases care fail-safe meaning that the system is able to boot into Linux and continue to complete the upgrade process The BST is located at the first NAND block The NAND manufacturer ensures that the first block is not easily corrupted OTA can perform a sanity check of the BST partition content before programming the BST partition a signature check with the RoT key inside OTP as well as a cyclic redundancy check CRC for the partition Because the BST partition is small the program runs quickly A sudden loss of power in such a small time frame is extremely unlikely The result is a well-designed OTA process that with Rescue Mode v2 covers almost all OTA failure cases Table 1-3.Recommended Upgrade Processes for Different Scenarios Scenarios Affect Partitions Recommended Steps Fail-safe Description Possibility Severity RoT key revocation BST ATF BLD BAK Step 1 upgrade BAK new key Step 2 revoke RoT key Step 3 upgrade BST new key Step 4 upgrade ATF Update BAK failed no issues the “normal boot path” is still OK Minor Revoke key failed no issues “normal boot path” is OK Minor Upgrade BST failed return material authorization RMA is required reprogram NAND or replace NAND Very small Critical Upgrade ATF BLD partition failed no problem “rescue boot path” is OK Minor Kernel key revocation BLD BAK PRI LNX PBA ROM Step 1 upgrade BAK new key Step 2 upgrade PBA ROM new key Step 3 upgrade ATF BLD new key Step 4 upgrade PRI LNX new key Update BAK failed no issues “normal boot path” is OK Minor Update PBA ROM failed no issues “normal boot path” is OK Minor Update ATF BLD failed no issues “rescue boot path B” is OK Very small Critical Update PRI LNX failed no issues “rescue boot path” B is OK Minor BST update bugfix BST Update BST Upgrade BST failed RMA is required reprogram NAND or replace NAND Very small Critical ATF update bugfix ATF BLD BAK Step 1 upgrade BAK Step 2 upgrade ATF BLD BAK failed no issues “normal boot path” is OK Minor Upgrade ATF BLD failed no issues “rescue boot path” is OK Minor OP-TEE OS and AMBoot update bugfix BLD BAK Step 1 upgrade BAK Step 2 upgrade BLD BAK failed no issues “normal boot path” is OK Minor Upgrade BLD failed no issues “rescue boot path” is OK Minor Update Linux maintain compatibility PRI LNX Update PRI LNX Upgrade PRI LNX failed no issues B PBA ROM is OK Minor Update Linux do not maintain compatibility PRI LNX PBA ROM Step 1 upgrade PBA ROM Step 2 upgrade PRI LNX Upgrade PBA ROM failed no issues A PRI LNX is OK Minor Upgrade PRI LNX failed no issues B PBA ROM is OK Minor Update Linux do not maintain compatibility BST ATF BLD BAK PRI LNX PBA ROM Step 1 upgrade BAK PBA and ROM Step 2 upgrade BST Step 3 upgrade ATF BLD PRI and LNX Upgrade BAK PBA ROM failed no issues “normal boot path” A is OK Minor Upgrade BST failed RMA is required reprogram NAND or replace NAND Very small Critical Upgrade ATF BLD PRI LNX failed no issues “rescue boot path” B is OK Minor Getting Started To build firmware with Rescue Mode v2 the following configurations must be selected in menuconfig Or users can use the existing board configuration xxx_rescue_config or xxx_emmc_rescue_config Select Recovery Firmware Images in menuconfig Select Without External MCU in menuconfig Select Without External MCU in menuconfig Select mtd-utils in menuconfig NAND Select the bootstat driver in menuconfig If using eMMC the boot arguments bootargs must be changed In ambarella/ board bsp/xxx.dts change the bootargs to console ttyS0 noinitrd root rw rootfstype ext4 rootwait Check the Current Boot Mode Users can check the kernel command line to see which partitions are used for the file system NAND If the file system is from the LNX partition the kernel command line is printed as follows console ttyS0 ubi.mtd lnx root ubi0 rootfs rw rootfstype ubifs If the file system is from the ROM partition the kernel command line is printed as follows console ttyS0 ubi.mtd rom root ubi0 rootfs rw rootfstype ubifs eMMC If the file system is from the LNX partition the kernel command line is printed as follows console ttyS0 noinitrd root rw rootfstype ext4 rootwait If the file system is from the ROM partition the kernel command line is printed as follows console ttyS0 noinitrd root rw rootfstype ext4 rootwait Check the Current Boot Path System Upgrade with RoT Key Revocation Upgrade the BAK partition with a new RoT key NAND eMMC Check if the system boots successfully from Upgrade the BST partition with a new RoT key Revoke key1 new RoT key NAND eMMC Check if the system fails at the BST stage and then check if it can recover a Boot will fail at the BST stage several times there is no print at the serial port b The system will boot from Upgrade the ATF partition to the new RoT key NAND eMMC Check if the system fails at the BL2 stage and then check if it can recover a Boot fails at the BL2 stage several times there is no b Then the system boots from Update the BLD partition with the new RoT key NAND eMMC Check if the system boots successfully from System Upgrade with Kernel Key Revocation Update the BAK PBA and ROM partitions with the new kernel key NAND eMMC Update the BLD partition with a new kernel key NAND eMMC Check if the system fails at the BLD stage then check if it can recover a Boot fails at the BLD stage several times PRI b Then the system will boot from Update the PRI partition with a new kernel key NAND eMMC Check if the system boots successfully from Update the LNX partition NAND eMMC Check if the system boots successfully from The device mapper’s “verity” target provides the transparent integrity checking of block devices using a cryptographic digest provided by the kernel crypto application programming interface API This target is read-only Dm-verity cannot function on memory technology devices MTDs The following lists the steps to set up dm-verity Configure the Linux kernel Configure the Ambarella platform Users can enable dm-crypt and test it from the user space Dm-crypt requires an extra partition to store hash maps the swap SWP partition is used as an example Amba build Yocto build Use the command below to generate a blank swp.bin Define the SWP partition size in ambarella/boards/ board_name h Follow the steps below to use dm-verity on the board Retrieve the file system block size on the PC Set up dm-verity on the board Partitions mmcblk0 p1(bst) p2(bld) p3(ptb) p4(atf) p5(pba) p6(pri) p7(lnx) p8(swp) Enter into AMBoot For setups using the device mapper on top of the asynchronously probed block devices MMC USB and more it may be necessary to tell dm-init to explicitly wait for them to become available before setting up the device mapper tables This can be performed with the dm-mod.waitfor module parameter which uses a list of devices to wait for Then the commandline written in AMBoot changes to the following If users are required to use signed device tree blob DTB and dm-verity together bootargs cannot be changed Follow the below steps to enable both Compile and generate the firmware with both the signed DTB and dm-verity save the rootfs.ext4 Burn the firmware to the board and run blockdev Create a hashtree using a rootfs partition on the evaluation kit EVK and save it to the hash_evk.img save the root hash and salt values to evk_verity.txt Change the LNX image to rootfs.ext4 saved in ste p1 set the SWP image to hash_evk.img and add dm-verity related commands to the command line Amba build Yocto build Compile and generate the new firmware with the rootfs.ext4 in step 1 the hash tree stored in the SWP partition and the signed DTB with bootargs that enable dm-verity The dm-verity feature must function with a read-only file system that runs on a block device SquashFS is a candidate Dm-verity cannot support unsorted block image file system UBIFS as UBIFS does not run on block devices Using initramfs is straight-forward and flexible enabling users to more-easily adjust or calculate verification arguments from Initramfs Usage make menuconfig_public_linux and ensure that the configurations below are enabled make menuconfig and ensure that the configurations below are enabled Add the options below into the kernel command line for example bootargs in device trees DTS Using initramfs may add undesirable boot time and storage requirements to the system If the system is operating with VERY strict boot timing or storage requirements skipping initramfs may be beneficial Usage make menuconfig_public_linux and ensure that the configurations below are enabled Use make to build the firmware Then users can find information related to dm-verity in info Add the options below into the kernel command line for example bootargs in DTS Here is used to pass DM table information into the kernel Its format is as follows Here Ambarella provides an example string for User-created strings must be different from this example All required values in dm-mod.create can be found in info uuid and minor are not required so they can be left empty num_sectors is calculated via Sector_size The most common value for Sector_size is 5 1 2 For details refer to LINUX/Documentation/admin-guide/device-mapper/dm-init.rst Build the firmware again via make amboot Do not use make to rebuild the firmware in this step otherwise the HASH value for SquashFS will be changed</field>
  </doc>
  <doc>
    <field name="type">page</field>
    <field name="name">index</field>
    <field name="url">index.html</field>
    <field name="keywords"></field>
    <field name="text">Ambarella Security Document Revision History Updated Date Modification 2 0 2 2 0 7 2 1 Initial Release The outline of Overview is listed as follows Section Section Section The outline of System Integrity Protection is listed as follows Section Section Section The outline of System Reinforcement is listed as follows Section Section Section Section Section Section Section Section Section The outline of Data Storage Protection is listed as follows Section Section Section The outline of Data Transfer Protection is listed as follows Section Section Section The outline of Intellectual Property Protection is listed as follows Section Section Section Section Section The outline of User Privacy Protection is listed as follows The outline of Secure Hardware is listed as follows Section 0 Revision History Section Section Section Section Section The outline of Key Management is listed as follows Section 0 Revision History Section Section Section Section Section The outline of Crypto Performance is listed as follows Section 0 Revision History The outline of Design Guide is listed as follows Section 0 Revision History Section Section Section The outline of security_validation_guide is listed as follows Section 0 Revision History Section Section Section Section Section Section Section Section Section Section Section Section Section The outline of Migration Guide is listed as follows Section 0 Revision History Section Section Section Section Section Section License Copyright c 2 0 2 4 Ambarella International LP This file and its contents are protected by intellectual property rights including without limitation U.S and/or foreign copyrights This Software is also the confidential and proprietary information of Ambarella International LP and its licensors You may not use reproduce disclose distribute modify or otherwise prepare derivative works of this Software or any portion thereof except pursuant to a signed license agreement or nondisclosure agreement with Ambarella International LP or its authorized affiliates In the absence of such an agreement you agree to promptly notify and return this Software to Ambarella International LP THIS SOFTWARE IS PROVIDED AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF NON-INFRINGEMENT MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED IN NO EVENT SHALL AMBARELLA INTERNATIONAL LP OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS COMPUTER FAILURE OR MALFUNCTION OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</field>
  </doc>
</add>
